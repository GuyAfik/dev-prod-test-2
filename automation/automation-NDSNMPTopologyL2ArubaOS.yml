args:
- description: Local Entry IP
  name: local_entry_ip
  required: true
- description: Network Discovery instance name
  name: nd_instance
  required: true
commonfields:
  id: NDSNMPTopologyL2ArubaOS
  version: -1
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
dockerimage: demisto/netutils:1.0.0.24101
enabled: true
engineinfo: {}
mainengineinfo: {}
name: NDSNMPTopologyL2ArubaOS
pswd: ""
runas: DBotWeakRole
runonce: false
script: |
  register_module_line('NDSNMPTopologyL2ArubaOS', 'start', __line__())



  # from pysnmp.hlapi import *
  import socket
  import re
  from ipaddress import IPv4Network
  from netaddr import IPNetwork, IPAddress

  NETWORK_DISCOVERY_INSTANCE=demisto.args().get("nd_instance")

  # ***************** VLAN FUNCTIONS ******************
  # Macros
  VLAN_ID = "vlan_id"
  VLAN_NAME = "vlan_name"
  VLAN_TYPE = "vlan_type"
  VLAN_IP = "vlan_ip"
  VLAN_INTF = "vlan_interface"
  VLAN_TRUNK_STATUS = "vlan_trunk"
  VLAN_LIST = "vlan_list"
  VLAN_IF_LIST = "vlan_interface_list"
  INTERFACE_LIST = "interface_list"
  VLAN_STR = "VLAN"
  VLAN_IF_IDX = "vlan_if_idx"
  VLAN_IF_NAME = "vlan_if_name"
  VLAN_IF_IP = "vlan_if_ipaddr"
  VLAN_PORT_LIST = "vlan_port_list"
  IF_LIST_VLAN = "if_list"
  VLAN_IF_IPMASK = "vlan_intf_ipmask"
  # Common utilities
  DOT = '.'
  YES = "yes"
  NO = "no"

  IF_IDX_TO_IF_NAME_OID               = '1.3.6.1.2.1.31.1.1.1.1'
  IF_IDX_TO_IF_DESC_OID               = '1.3.6.1.2.1.2.2.1.2'
  IF_IDX_TO_IP_ADDR_OID               = '1.3.6.1.2.1.4.20.1.2'
  IF_IDX_TO_MAC_ADDRESS_OID           = '1.3.6.1.2.1.2.2.1.6'
  IF_IDX_TO_OPER_STATUS_OID           = '1.3.6.1.2.1.2.2.1.8'

  IF_OPER_STATUS = "intf_operational_status"
  IF_INDEX = "intf_index"
  IF_NAME = "intf_name"
  IF_IP4_ADDR = "intf_ipv4_addr"
  IF_MAC_ADDR = "intf_mac_addr"

  # *************** Standard BRIDGE-MIB based VLAN Discovery Functions ***************
  # VLAN ID and L3 Functions for the ArubaOS
  ARUBAOS_MIB_DOT1Q_VLAN_MEMBER_TABLE_OID         = '1.3.6.1.4.1.14823.2.2.1.3.1.3.1'
  ARUBAOS_MIB_DOT1Q_VLAN_MEMBER_PORT_OID          = '1.3.6.1.4.1.14823.2.2.1.3.1.3.1.3'
  ARUBAOS_MIB_DOT1Q_VLAN_MEMBER_PORT_TRUNK_STATUS_OID = '1.3.6.1.4.1.14823.2.2.1.3.1.1.1.10'

  IP_CIDR_ROUTES_OID  = '1.3.6.1.2.1.4.24.4.1.5'

  IP_SUBNET      = "ip_subnet"
  IP_SUBNET_MASK = "ip_subnet_mask"
  IP_SUBNET_GATEWAY = "ip_subnet_gateway"
  IP_SUBNET_IF   = "ip_subnet_interface"
  IP_DEFAULT_ROUTE_ADDR = "0.0.0.0"

  # *************** Get L3 Network Information *********************
  IP_IF_LIST = "ip_interface_list"
  IP_SUBNET_LIST = "ip_subnet_list"

  def walk(ip,oid):
      response = demisto.executeCommand("nd-snmp-v2-walk-command", {
          "ip":ip,
          "oid": oid,
          "using": NETWORK_DISCOVERY_INSTANCE
      })
      if isError(response[0]):
          err_msg = 'Error, couldn\'t complete snmp v2 walk - '+str(response[0]['Contents'])
          raise Exception(err_msg)
      return response[0]['Contents']

  def remove_prefix(text, prefix):
      if text.startswith(prefix):
          return text[len(prefix):]
      return text

  def get_if_interface_info_from_name(host):
      if_info = {}
      # SNMP Walk to get IF Names
      raw_result = walk(host, IF_IDX_TO_IF_NAME_OID)
      for k, v in raw_result.items():
          if_idx = k.split('.')[-1]
          if if_idx not in if_info:
              if_info[if_idx] = {}
          if_info[if_idx][IF_NAME] = v.strip()

      # SNMP Walk to get IF IP address
      raw_result = walk(host, IF_IDX_TO_IP_ADDR_OID)
      for k, v in raw_result.items():
          if_idx = v
          ip = '.'.join(k.strip().split('.')[-4:])
          if is_valid_ipv4_address(ip):
              if if_idx in if_info:
                  if_info[if_idx][IF_IP4_ADDR] = ip
      raw_result = walk(host, IF_IDX_TO_MAC_ADDRESS_OID)
      for k, v in raw_result.items():
          if(v!=''):
              if_idx = k.strip().split('.')[-1]
              mac = remove_prefix(v,"0x")
              if if_idx in if_info:
                  mac_colon = ':'.join(mac[i:i + 2] for i in range(0, 12, 2))
                  if_info[if_idx][IF_MAC_ADDR]=mac_colon
      raw_result = walk(host, IF_IDX_TO_OPER_STATUS_OID)
      for k, v in raw_result.items():
          if (v != ''):
              if_idx = k.strip().split('.')[-1]
              if if_idx in if_info:
                  val=''
                  if v == '1':
                      val='up'
                  elif v == '2':
                      val='down'
                  elif v == '3':
                      val='testing'
                  elif v == '4':
                      val='unknown'
                  elif v == '5':
                      val='dormant'
                  elif v == '6':
                      val='notPresent'
                  else:
                      val='lowerLayerDown'

                  if_info[if_idx][IF_OPER_STATUS] = val
      # Return the IP Interface list
      return if_info

  def is_valid_ipv4_address(address):
      try:
          socket.inet_pton(socket.AF_INET, address)
      except AttributeError:  # no inet_pton here, sorry
          try:
              socket.inet_aton(address)
          except socket.error:
              return False
          return address.count('.') == 3
      except socket.error:  # not a valid address
          return False

      return True

  def get_arubaos_vlan_port_trunk_status(host, result_map, if_info_map):
      # SNMP Walk to get VLAN Portlist
      raw_result = walk(host, ARUBAOS_MIB_DOT1Q_VLAN_MEMBER_PORT_TRUNK_STATUS_OID)
      for k, v in raw_result.items():
          vlan_id = k.split('.')[-2]
          port_idx = k.split('.')[-1]
          # If VLAN_ID exists, if port is present in the list and update Trunk status
          if port_idx in if_info_map:
              port_name = if_info_map[str(port_idx)][IF_NAME]
              if v == '1':
                  trunk_status = NO
              else:
                  trunk_status = YES
              if port_name not in result_map:
                  result_map[port_name] = {}
                  result_map[port_name][IF_INDEX] = port_idx
                  result_map[port_name][IF_NAME] = port_name
                  result_map[port_name][VLAN_ID] = vlan_id
              result_map[port_name][VLAN_TRUNK_STATUS] = trunk_status
      if_indexes = if_info_map.keys()
      for if_idx in if_indexes:
          if_name = if_info_map[if_idx][IF_NAME]
          if if_name not in result_map:
              result_map[if_name] = {}
          if IF_IP4_ADDR in if_info_map[if_idx]:
              ip = if_info_map[if_idx][IF_IP4_ADDR]
              result_map[if_name][IF_IP4_ADDR] = ip
          if IF_MAC_ADDR in if_info_map[if_idx]:
              mac = if_info_map[if_idx][IF_MAC_ADDR]
              # mac_colon =  ':'.join(mac[i:i + 2] for i in range(0, 12, 2))
              result_map[if_name][IF_MAC_ADDR] = mac

  # GET Port list for each VLAN
  def get_arubaos_vlan_portlist_info(host, result_map, if_info_map):
      # SNMP Walk to get VLAN Portlist
      raw_result = walk(host, ARUBAOS_MIB_DOT1Q_VLAN_MEMBER_PORT_OID)
      for k, v in raw_result.items():
          vlan_id = k.split('.')[-2]
          port_idx = v
          if str(port_idx) in if_info_map:
              port_name = if_info_map[str(port_idx)][IF_NAME]
          else:
              port_name = port_idx
           # Add Port index and interface name to this VLAN
          if port_name not in result_map:
              result_map[port_name] = {}
          result_map[port_name][IF_INDEX] = port_idx
          result_map[port_name][IF_NAME] = port_name
          result_map[port_name][VLAN_ID] = vlan_id
      # SNMP WALK to get Port Trunk Status
      get_arubaos_vlan_port_trunk_status(host, result_map, if_info_map)
      if_indexes = if_info_map.keys()
      for if_idx in if_indexes:
          if_name = if_info_map[if_idx][IF_NAME]
          if if_name not in result_map:
              result_map[if_name] = {}
          if IF_IP4_ADDR in if_info_map[if_idx]:
              ip = if_info_map[if_idx][IF_IP4_ADDR]
              result_map[if_name][IF_IP4_ADDR] = ip
          if IF_MAC_ADDR in if_info_map[if_idx]:
              mac = if_info_map[if_idx][IF_MAC_ADDR]
              result_map[if_name][IF_MAC_ADDR] = mac
          if IF_OPER_STATUS in if_info_map[if_idx]:
              operational_status = if_info_map[if_idx][IF_OPER_STATUS]
              result_map[if_name][IF_OPER_STATUS] = operational_status

  # VLAN ID and L3 Functions for the ArubaOS
  ARUBAOS_MIB_DOT1Q_VLAN_TABLE_OID         = '1.3.6.1.4.1.14823.2.2.1.3.1.2.1'
  ARUBAOS_MIB_DOT1Q_VLAN_ID_OID_PREFIX     = '1.3.6.1.4.1.14823.2.2.1.3.1.2.1.1'
  ARUBAOS_MIB_DOT1Q_VLAN_NAME_OID_PREFIX   = '1.3.6.1.4.1.14823.2.2.1.3.1.2.1.2'
  ARUBAOS_MIB_DOT1Q_VLAN_STATUS_OID_PREFIX = '1.3.6.1.4.1.14823.2.2.1.3.1.2.1.3'

  ARUBAOS_MIB_DOT1Q_VLAN_ID_IF_INFO_OID        = '1.3.6.1.4.1.14823.2.2.1.3.1.4.1'
  ARUBAOS_MIB_DOT1Q_VLAN_ID_IF_IDX_OID         = '1.3.6.1.4.1.14823.2.2.1.3.1.4.1.1'
  ARUBAOS_MIB_DOT1Q_VLAN_ID_IF_DESC_OID        = '1.3.6.1.4.1.14823.2.2.1.3.1.4.1.2'
  ARUBAOS_MIB_DOT1Q_VLAN_ID_IF_IPADDR_OID      = '1.3.6.1.4.1.14823.2.2.1.3.1.4.1.6'
  ARUBAOS_MIB_DOT1Q_VLAN_ID_IF_IPMASK_OID      = '1.3.6.1.4.1.14823.2.2.1.3.1.4.1.7'

  # GET VLAN ID information - name, ip address/subnet
  def get_arubaos_vlan_id_if_entry(host, result_map, if_ip_map, ip_subnet_list):
      # SNMP Walk to get VLAN ID and Names
      raw_result = walk(host, ARUBAOS_MIB_DOT1Q_VLAN_ID_IF_INFO_OID)
      for k, v in raw_result.items():
          vlan_id = k.split('.')[-1]
          # VLAN ID IF Idx
          if k.startswith(ARUBAOS_MIB_DOT1Q_VLAN_ID_IF_IDX_OID):
              if vlan_id not in result_map:
                  result_map[vlan_id] = {}
                  result_map[vlan_id][VLAN_ID] = vlan_id
              result_map[vlan_id][VLAN_IF_IDX] = v
              # Get VLAN Interface Name
              if v in if_ip_map:
                  vlan_intf_name = if_ip_map[v][IF_NAME]
                  result_map[vlan_id][VLAN_IF_NAME] = vlan_intf_name
                  result_map[vlan_id][IP_SUBNET] = get_ip_subnet_using_vlan_name(vlan_intf_name,ip_subnet_list)
          # VLAN ID IF IP Address
          if k.startswith(ARUBAOS_MIB_DOT1Q_VLAN_ID_IF_IPADDR_OID):
              if vlan_id not in result_map:
                  result_map[vlan_id] = {}
                  result_map[vlan_id][VLAN_ID] = vlan_id
              result_map[vlan_id][VLAN_IF_IP] = v
          # VLAN ID IF IP Mask
          if k.startswith(ARUBAOS_MIB_DOT1Q_VLAN_ID_IF_IPMASK_OID):
              if vlan_id not in result_map:
                  result_map[vlan_id] = {}
                  result_map[vlan_id][VLAN_ID] = vlan_id
              result_map[vlan_id][VLAN_IF_IPMASK] = v

  def get_arubaos_vlan_id_info(host, result_map, if_ip_map, ip_subnet_list):
      # SNMP Walk to get VLAN ID and Names
      raw_result = walk(host, ARUBAOS_MIB_DOT1Q_VLAN_NAME_OID_PREFIX)
      for k, v in raw_result.items():
          vlan_id = k.split('.')[-1]
          if vlan_id not in result_map:
              result_map[vlan_id] = {}
          result_map[vlan_id][VLAN_ID] = vlan_id
          result_map[vlan_id][VLAN_NAME] = v.strip()
      # SNMP Walk to get VLAN ID Interface IP info
      get_arubaos_vlan_id_if_entry(host, result_map, if_ip_map, ip_subnet_list)
      print(result_map)

  def get_ip_subnet_using_vlan_name(vlan_intf_name, ip_subnet_list):
      if len(ip_subnet_list) > 0:
          for k, v in ip_subnet_list.items():
              if IP_SUBNET_IF in v.keys() and IP_SUBNET in v.keys():
                  ip_subnet_interface = v[IP_SUBNET_IF]
                  if ip_subnet_interface == vlan_intf_name:
                      ip_subnet = v[IP_SUBNET]
                      return ip_subnet
      return ""

  def get_arubaos_vlan_info(host):
      result_map = {}
      vlan_id_map = {}
      vlan_intf_map = {}
      if_info_map = {}

      # Get interface information
      if_info_map = get_if_interface_info_from_name(host)
      if len(if_info_map) == 0:
          return result_map

      #Return the IP_SUBNET_LIST information
      ip_subnet_list = get_ip_subnet_info(host, if_info_map)
      result_map[IP_SUBNET_LIST] = ip_subnet_list

      # Get VLAN ID information
      get_arubaos_vlan_id_info(host, vlan_id_map, if_info_map, ip_subnet_list)
      if len(vlan_id_map) == 0:
          return result_map
      else:
          result_map[VLAN_LIST] = vlan_id_map

      # Get VLAN Interface information
      get_arubaos_vlan_portlist_info(host, vlan_intf_map, if_info_map)
      if len(vlan_intf_map) == 0:
          return result_map
      else:
          result_map[INTERFACE_LIST] = vlan_intf_map

      result_map['default_gateway_list'] = get_default_gateway_list(ip_subnet_list)
      # result_map['node_ip']=host
      # result_map['node_mac_address']=get_mac_address_from_interface_info(host, if_info_map)
      return result_map

  def get_default_gateway_list(ip_subnet_list):
      default_gateway_list={}
      if len(ip_subnet_list) > 0:
          for k,v in ip_subnet_list.items():
              if isinstance(v, dict) and 'ip_subnet_gateway' in v.keys():
                  ip_subnet_gateway = v['ip_subnet_gateway']
                  separator = "."
                  default_gateway_subnet = findLongestMatch(ip_subnet_gateway,ip_subnet_list)
                  if default_gateway_subnet == '':
                      default_gateway_subnet = separator.join(ip_subnet_gateway.split(separator, 3)[:-1])
                      default_gateway_subnet = default_gateway_subnet+".0/24"
                  default_gateway_list[ip_subnet_gateway]={"interface":[],"default_gateway_subnet":default_gateway_subnet}
      return default_gateway_list

  def findLongestMatch(ipaddr, ip_subnet_list):
      longest_prefix = 32
      longest_match = ''
      for k, v in ip_subnet_list.items():
          ip_subnet = v['ip_subnet']
          if ip_subnet != '0.0.0.0':
              ip_subnet_mask = v['ip_subnet_mask']
              try:
                  ip = IPv4Network(ip_subnet+'/'+ip_subnet_mask)

                  if IPAddress(ipaddr) in IPNetwork(ip_subnet+'/'+str(ip.prefixlen)):
                      if ip.prefixlen < longest_prefix:
                          longest_prefix = ip.prefixlen
                          longest_match=ip_subnet+'/'+str(ip.prefixlen)
              except Exception as e:
                  demisto.error('error while loading IPv4Network/IPAddress: '+ str(e))

      return longest_match

  def findLongestMatch(ipaddr, ip_subnet_list):
      longest_prefix = 32
      longest_match = ''
      for k, v in ip_subnet_list.items():
          ip_subnet = v['ip_subnet']
          if ip_subnet != '0.0.0.0':
              ip_subnet_mask = v['ip_subnet_mask']
              try:
                  ip = IPv4Network(ip_subnet+'/'+ip_subnet_mask)

                  if IPAddress(ipaddr) in IPNetwork(ip_subnet+'/'+str(ip.prefixlen)):
                      if ip.prefixlen < longest_prefix:
                          longest_prefix = ip.prefixlen
                          longest_match=ip_subnet+'/'+str(ip.prefixlen)
              except Exception as e:
                  demisto.error('error while loading IPv4Network/IPAddress: '+ str(e))

      return longest_match

  def get_ip_subnet_info(host, ip_if_list):
      ip_subnet_info = {}
      # SNMP Walk to get IF Names
      raw_result = walk(host, IP_CIDR_ROUTES_OID)
      for k, v in raw_result.items():
          ip_rem_prefix = remove_prefix(k, IP_CIDR_ROUTES_OID)
          ip_entry = ip_rem_prefix.split('.')
          # return_outputs("ip entry: ",ip_entry)
          if len(ip_entry) == 14:
              # Get IP address
              ip_addr = '.'.join(ip_entry[1:5])
              ip_mask = '.'.join(ip_entry[5:9])
              if ip_mask == '255.255.255.255':
                  continue
              if ip_addr not in ip_subnet_info:
                  ip_subnet_info[ip_addr] = {}
              ip_subnet_info[ip_addr][IP_SUBNET] = ip_addr
              # Get IP Subnet Mask

              ip_subnet_info[ip_addr][IP_SUBNET_MASK] = ip_mask
              # Get Gateway if present
              ip_gateway = '.'.join(ip_entry[10:14])
              if ip_gateway != IP_DEFAULT_ROUTE_ADDR:
                  ip_subnet_info[ip_addr][IP_SUBNET_GATEWAY] = ip_gateway
              # Get IF name
              if v in ip_if_list:
                  ip_subnet_info[ip_addr][IP_SUBNET_IF] = ip_if_list[v][IF_NAME]

      # Return the IP Subnet list
      return ip_subnet_info

  def main():
      try:
          # LOCAL_ENTRY_IP = '10.6.72.136'
          LOCAL_ENTRY_IP = demisto.args().get('local_entry_ip')
          arubaos_vlan_info = get_arubaos_vlan_info(LOCAL_ENTRY_IP)
          # return_outputs("finished SNMP probing for Aruba OS VLAN data for Node!")
          return_results(arubaos_vlan_info)
      except Exception as e:
          raise Exception("Failed to get Aruba OS Node VLAN data: %s" % str(e))

  if __name__ in ('__main__', '__builtin__', 'builtins'):
      main()

  register_module_line('NDSNMPTopologyL2ArubaOS', 'end', __line__())
scripttarget: 0
subtype: python3
tags: []
timeout: 100800h0m0s
type: python
