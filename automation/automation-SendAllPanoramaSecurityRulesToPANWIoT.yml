args:
- description: Panorama Instance name
  name: panorama_instance
commonfields:
  id: SendAllPanoramaSecurityRulesToPANWIoT
  version: -1
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
dockerimage: demisto/netutils:1.0.0.24101
enabled: true
engineinfo: {}
mainengineinfo: {}
name: SendAllPanoramaSecurityRulesToPANWIoT
pswd: ""
runas: DBotWeakRole
runonce: false
script: |
  register_module_line('SendAllPanoramaSecurityRulesToPANWIoT', 'start', __line__())


  import ipaddress
  import netaddr

  USING_PANORAMA_INSTANCE = demisto.args().get('panorama_instance')
  PANAROMA_DEVICE_GROUPS_LIST_NAME = 'DeviceGroups_'+USING_PANORAMA_INSTANCE
  PANAROMA_ADDRESS_GROUPS_LIST_NAME = 'AddressGroups_'+USING_PANORAMA_INSTANCE
  PANAROMA_ADDRESSES_LIST_NAME = 'Addresses_'+USING_PANORAMA_INSTANCE
  PRE_RULEBASE = 'pre-rulebase'
  POST_RULEBASE = 'post-rulebase'


  def send_security_rules_to_panw_iot(device_group, subset_rules):
      res = demisto.executeCommand("panw-iot-3rd-party-send-panorama-rules",{'device_group':device_group,'security_rules':subset_rules})
      output = res[0]['Contents']
      return output

  def is_valid_cidr_or_ip_range(ip):
      is_valid_cidr_val = is_valid_cidr(ip)
      if is_valid_cidr_val == False:
          is_valid_range = is_valid_ip_range(ip)
          is_valid_range_bool = is_valid_range[0]
          range_to_cidr = is_valid_range[1]
          if is_valid_range_bool == False:
              return [False, ip]
          return [True, range_to_cidr]
      return [True,ip]


  def is_valid_cidr(ip):
      try:
          ip_addr = ipaddress.ip_network(ip)
      except Exception as e:
          demisto.error('Invalid cidr notation : '+ str(e))
          return False
      return True

  def is_valid_ip_range(ip):
      ip_range = ip.split('-')
      if(len(ip_range) == 2):
          startip=ip_range[0]
          endip=ip_range[1]
          try:
              cidrs = netaddr.iprange_to_cidrs(startip, endip)
              cidrs_str = []
              for cidr in cidrs:
                  cidrs_str.append(str(cidr.cidr))

              return [True, cidrs_str]
          except Exception as e:
              demisto.error('Invalid ip range : '+ str(e))
              return [False,ip]
      return [False,ip]

  def get_device_group_list_cache(list_name):
      res = demisto.executeCommand('getList', {'listName': list_name})
      if (
          not isinstance(res, list)
          or 'Contents' not in res[0]
          or not isinstance(res[0]['Contents'], str)
          or res[0]['Contents'] == 'Item not found (8)'
      ):
          raise Exception('No '+list_name+' cache available - '+list_name+' Cache is Empty'+ str(res[0]['Contents']))
      contents = res[0]['Contents']

      return contents

  def get_api_type():
      try:
          res = demisto.executeCommand("panw-panorama-api-type",{'using':USING_PANORAMA_INSTANCE})
          if (
                  not isinstance(res, list)
                  or 'Contents' not in res[0]
                  or not isinstance(res[0]['Contents'], str)
                  or res[0]['Contents'] == 'Item not found (8)'
              ):
                  return 'No Panorama api type found'
          return res[0]['Contents']
      except Exception as e:
          raise Exception('error while retrieving the panorama api type :'+str(e))

  def get_panorama_security_rules(device_group, pre_post):
      res = demisto.executeCommand("panw-panorama-list-rules",{'device_group':device_group, 'pre_post':pre_post,'using':USING_PANORAMA_INSTANCE})
      if (
              not isinstance(res, list)
              or 'Contents' not in res[0]
              or 'Request Failed.' in res[0]['Contents']
          ):
              demisto.info('No security rules available for device_group:' + str(device_group)+ ' pre_post:'+str(pre_post))
              return None
      return res[0]['Contents']


  def get_panorama_object_address_groups(device_group):
      res = demisto.executeCommand("panw-panorama-object-address-groups",{'device_group':device_group,'using':USING_PANORAMA_INSTANCE})

      if res[0]['Contents'] == None:
          return None
      if (
          not isinstance(res, list)
          or 'Contents' not in res[0]
          or 'Request Failed.' in res[0]['Contents']
      ):
          demisto.info('No panorama object address groups found for device_group:' + str(device_group))
          return None
      return res[0]['Contents']


  def get_panorama_object_address(device_group):
      res = demisto.executeCommand("panw-panorama-object-addresses",{'device_group':device_group,'using':USING_PANORAMA_INSTANCE})
      if res[0]['Contents'] == None:
          return None
      if (
          not isinstance(res, list)
          or 'Contents' not in res[0]
          or 'Request Failed.' in res[0]['Contents']
          or res[0]['Contents'] == None
      ):
          demisto.info('No panorama object addresses found for device_group:' + str(device_group))
          return None

      return res[0]['Contents']


  def get_obj_address_group_values(val):
      object_address_group_values=None
      for device_group in DEVICE_GROUPS:
          obj_address_group = get_panorama_object_address_groups(device_group)
          if obj_address_group:
              object_address_group_values = get_obj_address_values_from_obj_adresses_group(obj_address_group, val)
              if object_address_group_values:
                  return object_address_group_values
      return object_address_group_values

  def get_cidr_values_from_obj_adresses_and_its_group(val):
      object_address_group_values= get_obj_address_group_values(val)
      cidrs=[]
      if object_address_group_values:
          for each_object_address_group_value in object_address_group_values:
              for device_group in DEVICE_GROUPS:
                  obj_addresses = get_panorama_object_address(device_group)
                  if obj_addresses:
                      cidr_addr_val = get_cidr_values_from_obj_adresses(obj_addresses, each_object_address_group_value)
                      if cidr_addr_val:
                          cidrs.append(cidr_addr_val)
      else:
          for device_group in DEVICE_GROUPS:
              obj_addresses = get_panorama_object_address(device_group)
              if obj_addresses:
                  cidr_addr_val = get_cidr_values_from_obj_adresses(obj_addresses, val)
                  if cidr_addr_val:
                      cidrs.append(cidr_addr_val)
      return cidrs

  def get_xml_obj_address_group_values(val):
      object_address_group_values=None
      for device_group in DEVICE_GROUPS:
          if device_group=='Shared':
              device_group=device_group.lower()
          obj_address_group = get_panorama_object_address_groups(device_group)
          if obj_address_group:
              object_address_group_values = get_xml_obj_address_values_from_obj_adresses_group(obj_address_group, val)
              if object_address_group_values:
                  return object_address_group_values
      return object_address_group_values

  def get_ip_netmask_from_address_group(address_group, val):
      name = address_group['name']
      if name == val:
          members = address_group['members']
          for member in members:
              for address in ADDRESSES:
                  if address['name'] == member:
                      ip_netmask_range = address['ip_netmask_range']
                      if ip_netmask_range:
                          return ip_netmask_range
      return None

  def get_xml_ip_netmask_range_from_obj_adresses_and_its_group(val):
      if ADDRESS_GROUPS:
          for address_group in ADDRESS_GROUPS:
              ip_netmask_range = get_ip_netmask_from_address_group(address_group, val)
              if ip_netmask_range:
                  return ip_netmask_range
      for address in ADDRESSES:
          name = address['name']
          if name == val:
              ip_netmask_range = address['ip_netmask_range']
              return ip_netmask_range
      return None

  def isError(res):
      if (
              not isinstance(res, list)
              or 'Contents' not in res[0]
              or 'Request Failed.' in res[0]['Contents']
          ):
              demisto.info('No content available')
              return True
      return False

  def get_cidr_values_from_obj_adresses(obj_addresses, val):
      if obj_addresses:
          for each_obj_addresses in obj_addresses:
              if each_obj_addresses['@name'] == val:
                  if 'ip-netmask' in each_obj_addresses:
                      return each_obj_addresses['ip-netmask']
                  return each_obj_addresses['ip-range']
      return None

  def get_obj_address_values_from_obj_adresses_group(obj_addresses_group, val):
      try:
          if obj_addresses_group:
              for each_obj_addresses in obj_addresses_group:
                  if each_obj_addresses['@name'] == val:
                      return each_obj_addresses['static']['member']
          return None
      except Exception as e:
          raise Exception("Exception:"+str(e))

  def get_ip_netmask_or_range(entry):
      if 'ip-netmask' in entry:
          ip_netmask = entry['ip-netmask']
          if isinstance(ip_netmask, dict):
              return ip_netmask['#text']
          return ip_netmask
      elif 'ip-range' in entry:
          ip_range = entry['ip-range']
          if isinstance(ip_range, dict):
              return ip_range['#text']
          return ip_range
      demisto.info(f'No ip netmask or ip range exists in this entry: {entry} ')
      return None


  def get_xml_cidr_values_from_obj_adresses(obj_addresses, val):
      if obj_addresses:
          if 'entry' in  obj_addresses:
              entry = obj_addresses['entry']
          else:
              entry = obj_addresses
          if isinstance(entry, list):
              for each_obj_addresses in entry:
                  # return_outputs(f'each_obj_addresses: {each_obj_addresses}')
                  if each_obj_addresses['@name'] == val:
                      ip_range_or_netmask = get_ip_netmask_or_range(each_obj_addresses)
                      return ip_range_or_netmask
          else:
              # return_outputs(f'entry: {entry}')
              if entry['@name'] == val:
                  ip_range_or_netmask = get_ip_netmask_or_range(entry)
                  return ip_range_or_netmask
      return None

  def get_xml_obj_address_values_from_obj_adresses_group(obj_addresses_group, val):
      if obj_addresses_group:
          if 'entry' in  obj_addresses_group:
              entry = obj_addresses_group['entry']
          else:
              entry = obj_addresses_group
          if isinstance(entry, list):
              for each_obj_addresses in entry:
                  if each_obj_addresses['@name'] == val:
                      if 'static' in each_obj_addresses and 'member' in each_obj_addresses['static']:
                          members = each_obj_addresses['static']['member']
                          addressess=[]
                          if isinstance(members, list):
                              for each_member in members:
                                  if '#text' in each_member:
                                      address = each_member['#text']
                                  else:
                                      address = each_member
                                  addressess.append(address)
                          else:
                              if '#text' in members:
                                  address = members['#text']
                              else:
                                  address = members
                              addressess.append(address)
                          return addressess
          else:
              if entry['@name'] == val:
                  if 'static' in each_obj_addresses and 'member' in each_obj_addresses['static']:
                      members = entry['static']['member']
                      addressess=[]
                      if isinstance(members, list):
                          for each_member in members:
                              if '#text' in each_member:
                                  address = each_member['#text']
                              else:
                                  address = each_member
                              addressess.append(address)
                      else:
                          if '#text' in members:
                              address = members['#text']
                          else:
                              address = members
                          addressess.append(address)
                      return addressess
      return None

  def get_processed_sec_rules(device_group, pre_post):
      security_rules = get_panorama_security_rules(device_group, pre_post)
      demisto.info(f'pre_post: {pre_post} device_group: {device_group} and security_rules: {security_rules}')
      processed_security_rules=[]
      skipped_addresses=0
      skipped_rules=0
      if security_rules is not None:
          for each_security_rule in security_rules:
              destination = each_security_rule['destination']['member']
              source = each_security_rule['source']['member']
              dest_cidrs=[]
              src_cidrs=[]
              for each_dest in destination:
                  if each_dest.lower() == 'any':
                      continue
                  is_destination_valid_cidr_obj = is_valid_cidr_or_ip_range(each_dest)
                  is_destination_valid_cidr = is_destination_valid_cidr_obj[0]
                  valid_dest_cidr = is_destination_valid_cidr_obj[1]
                  if not is_destination_valid_cidr:
                      dest_cidrs_arr = get_cidr_values_from_obj_adresses_and_its_group(each_dest)
                      if len(dest_cidrs_arr)>0:
                          for each_dest in dest_cidrs_arr:
                              dest_cidrs.append(each_dest)
                      else:
                          skipped_addresses=skipped_addresses+1
                          demisto.info('skipped destination_address: '+each_dest + ' for security rule: '+each_security_rule['@name'])
                  else:
                      if isinstance(valid_dest_cidr, list):
                          dest_cidrs.extend(valid_dest_cidr)
                      else:
                          dest_cidrs.append(valid_dest_cidr)
              each_security_rule['destination']['member'] = dest_cidrs

              for each_src in source:
                  if each_src.lower() == 'any':
                      continue
                  is_source_valid_cidr_obj = is_valid_cidr_or_ip_range(each_src)
                  is_source_valid_cidr = is_source_valid_cidr_obj[0]
                  valid_src_cidr = is_source_valid_cidr_obj[1]
                  demisto.info('each_src: '+each_src+ ' is_source_valid_cidr:'+ str(is_source_valid_cidr)+ ' valid_src_cidr:'+str(valid_src_cidr))
                  if not is_source_valid_cidr:
                      src_cidr_arr = get_cidr_values_from_obj_adresses_and_its_group(each_src)
                      if len(src_cidr_arr)>0:
                          for each_src in src_cidr_arr:
                              src_cidrs.append(each_src)
                      else:
                          skipped_addresses=skipped_addresses+1
                          demisto.info('skipped source_address: '+each_src + ' for security rule: '+each_security_rule['@name'])
                  else:
                      if isinstance(valid_src_cidr, list):
                          src_cidrs.extend(valid_src_cidr)
                      else:
                          src_cidrs.append(valid_src_cidr)
              each_security_rule['source']['member']=src_cidrs
              if len(src_cidrs) != 0 and len(dest_cidrs) != 0:
                  processed_security_rules.append(each_security_rule)
              else:
                  skipped_rules=skipped_rules+1
                  demisto.info('skipped security rule'+str(each_security_rule))
      return {'processed_security_rules':processed_security_rules,'skipped_rules':skipped_rules,'skipped_addresses':skipped_addresses}

  def get_dest_cidrs(each_dest_text, dest_cidrs):
      if each_dest_text.lower() == 'any':
          return
      is_destination_valid_cidr_obj = is_valid_cidr_or_ip_range(each_dest_text)
      is_destination_valid_cidr = is_destination_valid_cidr_obj[0]
      valid_dest_cidr = is_destination_valid_cidr_obj[1]
      if not is_destination_valid_cidr:
          ip_netmask_range = get_xml_ip_netmask_range_from_obj_adresses_and_its_group(each_dest_text)
          if ip_netmask_range:
              is_valid_ip_netmask_range_obj = is_valid_cidr_or_ip_range(ip_netmask_range)
              is_ip_netmask_range_valid_cidr = is_valid_ip_netmask_range_obj[0]
              ip_netmask_range_cidr = is_valid_ip_netmask_range_obj[1]
              if is_ip_netmask_range_valid_cidr:
                  if isinstance(ip_netmask_range_cidr, list):
                      dest_cidrs.extend(ip_netmask_range_cidr)
                  else:
                      dest_cidrs.append(ip_netmask_range_cidr)
      else:
          if isinstance(valid_dest_cidr, list):
              dest_cidrs.extend(valid_dest_cidr)
          else:
              dest_cidrs.append(valid_dest_cidr)

  def get_src_cidrs(each_src_text,src_cidrs):
      if each_src_text.lower() == 'any':
          return
      is_source_valid_cidr_obj = is_valid_cidr_or_ip_range(each_src_text)
      is_source_valid_cidr = is_source_valid_cidr_obj[0]
      valid_src_cidr = is_source_valid_cidr_obj[1]
      if not is_source_valid_cidr:
          ip_netmask_range = get_xml_ip_netmask_range_from_obj_adresses_and_its_group(each_src_text)
          if ip_netmask_range:
              is_valid_ip_netmask_range_obj = is_valid_cidr_or_ip_range(ip_netmask_range)
              is_ip_netmask_range_valid_cidr = is_valid_ip_netmask_range_obj[0]
              ip_netmask_range_cidr = is_valid_ip_netmask_range_obj[1]
              if is_ip_netmask_range_valid_cidr:
                  if isinstance(ip_netmask_range_cidr, list):
                      src_cidrs.extend(ip_netmask_range_cidr)
                  else:
                      src_cidrs.append(ip_netmask_range_cidr)
      else:
          if isinstance(valid_src_cidr, list):
              src_cidrs.extend(valid_src_cidr)
          else:
              src_cidrs.append(valid_src_cidr)

  def get_xml_processed_sec_rules(device_group, pre_post):
      if device_group=='Shared':
          device_group=device_group.lower()
      security_rules = get_panorama_security_rules(device_group, pre_post)
      demisto.info(f'{pre_post} - panorama_security_rules: {security_rules}')
      processed_security_rules=[]
      skipped_rules=0
      skipped_addresses=0
      if security_rules is not None and isinstance(security_rules, list):
          for each_security_rule in security_rules:
              destination = None
              if 'destination' in each_security_rule and 'member' in each_security_rule['destination']:
                  destination = each_security_rule['destination']['member']
              source = None
              if 'source' in each_security_rule and 'member' in each_security_rule['destination']:
                  source = each_security_rule['source']['member']
              dest_cidrs=[]
              src_cidrs=[]
              if destination is not None and isinstance(destination, list):
                  for each_dest in destination:
                      if '#text' in each_dest:
                          each_dest_text = each_dest['#text']
                      else:
                          each_dest_text = each_dest
                      get_dest_cidrs(each_dest_text, dest_cidrs)
                  skipped_addresses = skipped_addresses+ (len(destination) - len(dest_cidrs))
                  each_security_rule['destination']['member'] = dest_cidrs
              elif destination is not None and isinstance(destination, dict):
                  if '#text' in destination:
                      destination_text = destination['#text']
                  else:
                      destination_text = destination
                  get_dest_cidrs(destination_text, dest_cidrs)
                  if len(dest_cidrs)==0:
                      skipped_addresses=skipped_addresses+1
                  each_security_rule['destination']['member'] = dest_cidrs
              elif destination is not None and isinstance(destination, str):
                  get_dest_cidrs(destination, dest_cidrs)
                  if len(dest_cidrs)==0:
                      skipped_addresses=skipped_addresses+1
                  each_security_rule['destination']['member'] = dest_cidrs

              if source is not None and isinstance(source, list):
                  for each_src in source:
                      if '#text' in each_src:
                          each_src_text = each_src['#text']
                      else:
                          each_src_text = each_src
                      get_src_cidrs(each_src_text,src_cidrs)
                  skipped_addresses = skipped_addresses+ (len(source) - len(src_cidrs))
                  each_security_rule['source']['member']=src_cidrs

              elif source is not None and isinstance(source, dict):
                  if '#text' in source:
                      src_text = source['#text']
                  else:
                      src_text = source
                  src_text = source['#text']
                  get_src_cidrs(src_text,src_cidrs)
                  if len(src_cidrs)==0:
                      skipped_addresses=skipped_addresses+1
                  each_security_rule['source']['member'] = src_cidrs

              elif source is not None and isinstance(source, str):
                  get_src_cidrs(source,src_cidrs)
                  if len(src_cidrs)==0:
                      skipped_addresses=skipped_addresses+1
                  each_security_rule['source']['member'] = src_cidrs
              if len(src_cidrs) != 0 and len(dest_cidrs) != 0:
                  processed_security_rules.append(each_security_rule)
              else:
                  skipped_rules=skipped_rules+1
                  demisto.info('skipped security rule'+str(each_security_rule['@name']))
      elif security_rules is not None and isinstance(security_rules, dict):
          destination = security_rules['destination']['member']
          source = security_rules['source']['member']
          dest_cidrs=[]
          src_cidrs=[]
          if destination is not None and isinstance(destination, list):
              for each_dest in destination:
                  if '#text' in each_dest:
                      each_dest_text = each_dest['#text']
                  else:
                      each_dest_text = each_dest
                  get_dest_cidrs(each_dest_text, dest_cidrs)
              skipped_addresses = skipped_addresses+ (len(destination) - len(dest_cidrs))
              security_rules['destination']['member'] = dest_cidrs
          elif destination is not None and isinstance(destination, dict):
              if '#text' in destination:
                  destination_text = destination['#text']
              else:
                  destination_text = destination
              get_dest_cidrs(destination_text, dest_cidrs)
              if len(dest_cidrs)==0:
                  skipped_addresses=skipped_addresses+1
              security_rules['destination']['member'] = dest_cidrs
          elif destination is not None and isinstance(destination, str):
              get_dest_cidrs(destination, dest_cidrs)
              if len(dest_cidrs)==0:
                  skipped_addresses=skipped_addresses+1
              security_rules['destination']['member'] = dest_cidrs

          if source is not None and isinstance(source, list):
              for each_src in source:
                  if '#text' in each_src:
                      each_src_text = each_src['#text']
                  else:
                      each_src_text = each_src
                  get_src_cidrs(each_src,src_cidrs)
              skipped_addresses = skipped_addresses+ (len(source) - len(src_cidrs))
              security_rules['source']['member']=src_cidrs

          elif source is not None and isinstance(source, dict):
              if '#text' in source:
                  src_text = source['#text']
              else:
                  src_text = source
              get_src_cidrs(src_text,src_cidrs)
              if len(src_cidrs)==0:
                  skipped_addresses=skipped_addresses+1
              security_rules['source']['member'] = src_cidrs

          elif source is not None and isinstance(source, str):
              get_src_cidrs(source,src_cidrs)
              security_rules['source']['member'] = src_cidrs
              if len(src_cidrs)==0:
                  skipped_addresses=skipped_addresses+1
          if len(src_cidrs) != 0 or len(dest_cidrs) != 0:
              processed_security_rules.append(security_rules)
          else:
              skipped_rules=skipped_rules+1
              demisto.info('skipped security rule: '+str(security_rules['@name']))

      return {'processed_security_rules':processed_security_rules,'skipped_rules':skipped_rules,'skipped_addresses':skipped_addresses}

  def process_panorama_rules(args):
      panorama_api_type = get_api_type()
      msgs={}
      updated=0
      upserted=0
      skipped_addresses=0
      skipped_rules=0
      if panorama_api_type == 'XML_API':
          device_groups_json = DEVICE_GROUPS
          for each_device_group in device_groups_json:
              if each_device_group=='Shared':
                  each_device_group=each_device_group.lower()
              pre_security_rules = get_xml_processed_sec_rules(each_device_group, PRE_RULEBASE)
              demisto.info('Device Group:'+each_device_group+' pre_security_rules - '+ str(pre_security_rules))
              post_security_rules = get_xml_processed_sec_rules(each_device_group, POST_RULEBASE)
              demisto.info('Device Group:'+each_device_group+' post_security_rules - '+ str(post_security_rules))
              msgs1 = batch_and_send_panorama_security_rules(each_device_group, pre_security_rules['processed_security_rules'])
              msgs2 = batch_and_send_panorama_security_rules(each_device_group, post_security_rules['processed_security_rules'])
              updated += msgs1['updated']
              upserted += msgs1['upserted']
              updated += msgs2['updated']
              upserted += msgs2['upserted']
              skipped_rules+=pre_security_rules['skipped_rules']
              skipped_addresses+=pre_security_rules['skipped_addresses']
              skipped_rules+=post_security_rules['skipped_rules']
              skipped_addresses+=post_security_rules['skipped_addresses']
      elif panorama_api_type == 'REST_API':
          device_groups_json = DEVICE_GROUPS
          for each_device_group in device_groups_json:
              pre_security_rules = get_processed_sec_rules(each_device_group, PRE_RULEBASE)
              demisto.info('Device group: '+str(each_device_group)+' pre_security_rules - '+ str(pre_security_rules))
              post_security_rules = get_processed_sec_rules(each_device_group, POST_RULEBASE)
              demisto.info('Device group: '+str(each_device_group)+' post_security_rules - '+ str(post_security_rules))
              msgs1 = batch_and_send_panorama_security_rules(each_device_group,pre_security_rules['processed_security_rules'])
              msgs2 = batch_and_send_panorama_security_rules(each_device_group,post_security_rules['processed_security_rules'])
              updated += msgs1['updated']
              upserted += msgs1['upserted']
              updated += msgs2['updated']
              upserted += msgs2['upserted']
              skipped_rules+=pre_security_rules['skipped_rules']
              skipped_addresses+=pre_security_rules['skipped_addresses']
              skipped_rules+=post_security_rules['skipped_rules']
              skipped_addresses+=post_security_rules['skipped_addresses']
      else:
          raise Exception('Invalid Panorama API type')
      # return msgs
      msgs['upserted']=upserted
      msgs['updated']=updated
      msgs['skipped_rules']=skipped_rules
      msgs['skipped_addresses']=skipped_addresses
      return msgs

  def batch_and_send_panorama_security_rules(device_group, security_rules):
      demisto.info('Device group: '+str(device_group)+' security_rules - '+ str(security_rules))
      total = len(security_rules)
      offset = 0
      page_length = 100
      messages={}
      updated=0
      upserted=0
      while total >= offset:
          new_offset = offset+page_length
          subset_rules = security_rules[offset:new_offset]
          offset = new_offset
          msg = send_security_rules_to_panw_iot(device_group, subset_rules)

          updated += msg['updated']
          upserted += msg['upserted']
      messages['updated'] = updated
      messages['upserted'] = upserted
      return messages

  def main():
      try:
          global DEVICE_GROUPS, ADDRESSES, ADDRESS_GROUPS
          DEVICE_GROUPS = json.loads(get_device_group_list_cache(PANAROMA_DEVICE_GROUPS_LIST_NAME))
          ADDRESSES = json.loads(get_device_group_list_cache(PANAROMA_ADDRESSES_LIST_NAME))
          ADDRESS_GROUPS = json.loads(get_device_group_list_cache(PANAROMA_ADDRESS_GROUPS_LIST_NAME))
          results = process_panorama_rules(demisto.args())
          updated=results['updated']
          upserted=results['upserted']
          skipped_addresses = results['skipped_addresses']
          skipped_rules = results['skipped_rules']
          msg = f'{updated} Security Rules updated and {upserted} Security Rules upserted'
          # return_results(msg)
          report_summary = {}
          report_summary.update({f'Total Security Rules Updated': updated})
          report_summary.update({f'Total Security Rules Upserted': upserted})
          report_summary.update({f'Total Security Rules Skipped': skipped_rules})
          # report_summary.update({f'Total Source/Destination addresses skipped': skipped_addresses})

          return_results(
              CommandResults(
                  readable_output=tableToMarkdown("Panorama Security Rules Summary:", report_summary, removeNull=True),
                  outputs_prefix="PaloAltoIoTIntegrationBase.Status",
                  outputs=msg
              )
          )
      except Exception as ex:
          demisto.error(traceback.format_exc())  # print the traceback
          return_error(f'Failed to execute SendAllPanoramaSecurityRulesToPANWIoT. Error: {str(ex)}')


  ''' ENTRY POINT '''
  if __name__ in ('__main__', '__builtin__', 'builtins'):
      main()


  register_module_line('SendAllPanoramaSecurityRulesToPANWIoT', 'end', __line__())
scripttarget: 0
subtype: python3
tags: []
timeout: 100800h0m0s
type: python
