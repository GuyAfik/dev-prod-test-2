args:
- description: Active Tanium Instance
  name: active_tanium_instance
- description: Get severities to filter tanium data.
  isArray: true
  name: severities
commonfields:
  id: SendTaniumVulnerabilityToPANWIoT
  version: -1
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
dockerimage: demisto/panw-iot:1.0.0.79918
enabled: true
engineinfo: {}
mainengineinfo: {}
name: SendTaniumVulnerabilityToPANWIoT
pswd: ""
runas: DBotWeakRole
runonce: false
script: |
  register_module_line('SendTaniumVulnerabilityToPANWIoT', 'start', __line__())


  import json
  import traceback
  import time
  import uuid
  import re

  TANIUM_ACTIVE_INSTAMCE = demisto.args().get("active_tanium_instance")

  def sendStatusToPanwIotCloud(status, msg):
      """
      Reports status details back to PANW IoT Cloud.
      param status: Status (error, disabled, success) to be send to PANW IoT cloud.
      param msg: Debug message to be send to PANW IoT cloud.
      """
      resp = demisto.executeCommand(
          "panw-iot-3rd-party-report-status-to-panw",
          {
              "status": status,
              "message": msg,
              "integration_name": "tanium",
              "playbook_name": "Import Tanium Vulnerabilities to PANW IoT cloud",
              "asset_type": 'device',
              "custom_integration_name": TANIUM_ACTIVE_INSTAMCE,
              "timestamp": int(round(time.time() * 1000))
          },
      )

      if isError(resp[0]):
          err_msg = f'Error, failed to send status to PANW IoT Cloud - {resp[0].get("Contents")}'
          raise Exception(err_msg)


  def sendVulnerabilityToPanwIotCloud(taniumData, retry=0):
      """
      Sends vulnerabilities to PANW IoT Cloud.
      :type taniumData: ``array``
      :param taniumData: List of endpoints along with thier CVE findings to be sent to PANW IoT cloud
      """
      res = ""
      randomUuid = uuid.uuid4()
      resp = demisto.executeCommand(
          "panw-iot-3rd-party-report-vulnerabilities",
          {"VulnerabilityData": taniumData, "batchId": str(randomUuid), "IntegrationName": "tanium"},
      )
      if isError(resp[0]):
          if retry == 0:
              time.sleep(1)
              return sendVulnerabilityToPanwIotCloud(taniumData, retry=1)
          err_msg = f'Error, could not send endpoints to PANW IoT Cloud - {resp[0].get("Contents")}'
          raise Exception(err_msg)
      if isinstance(resp, list):
          res = resp[0].get("Contents",None)
      return res


  def isMacAddress(mac):
      """
      Test for valid mac address

      :type mac: ``str``
      :param mac: MAC address in the form of AA:BB:CC:00:11:22

      :return: True/False
      :rtype: ``bool``
      """

      if re.search(r"([0-9A-F]{2}[:]){5}([0-9A-F]){2}", mac.upper()) is not None:
          return True
      else:
          return False


  def isIpAddress(ip):
      """
      Test for valid ip address

      :type ip: ``str``
      :param ip: IP address in the form of 192.168.0.1

      :return: True/False
      :rtype: ``bool``
      """
      ipRegex = "^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$"
      if re.search(ipRegex, ip):
          return True
      else:
          return False


  def getIndexValue(data, ipAddress):
      """
      getIndexValue will get exact index_value from list of ipAddresses
      which we will use to get mac address from list of macAddresses.

      parameter data is the mac address data we got from Tanium Response.
      parameter ipAddress is the ipAddress we got from Tanium Response.

      """
      indexValue = ""
      if len(data) != 0:
          for _data in data:
              if _data.get("name", None) == "IP Address":
                  values = _data.get("values", None)
                  indexValue = values.index(ipAddress)
      return indexValue


  def getMacAddress(macData, ipAddress):
      """
      getMacAddress will get exact mac address corresponding to the management ip address of the endpoint.

      parameter macData is the mac address data we got from Tanium Response.
      parameter ipAddress is the ipAddress we got from Tanium Response.

      """
      macAddress = ""
      indexValue = getIndexValue(macData, ipAddress)
      if len(macData) != 0:
          for _data in macData:
              if isinstance(indexValue, int) and _data.get("name", None) == "MAC Address":
                  values = _data.get("values", None)
                  macAddress = values[indexValue]
                  if "-" in macAddress:
                      macAddress = macAddress.replace("-", ":")
      return macAddress


  def getFormattedDataForPayload(data):
      """
      getFormattedDataForPayload will format the Tanium response
      according to the payload which we will send to PAN API.

      parameter data is the Tanium Response.

      """
      payload = {}
      if data:
          ipAddress = data.get("ipAddress", None)
          if ipAddress:
              checkIpAddress = isIpAddress(ipAddress)
              if checkIpAddress:
                  payload["ipAddress"] = ipAddress
              macData = data.get("sensorReadings", {}).get("columns", None)
              if macData:
                  macAddress = getMacAddress(macData, ipAddress)
                  if macAddress:
                      checkMacAddress = isMacAddress(macAddress)
                      if checkMacAddress:
                          payload["deviceid"] = macAddress
              hostname = data.get("hostname", None)
              if hostname:
                  payload["hostname"] = hostname
              osType = data.get("os", {}).get("name", None)
              if osType:
                  payload["os"] = osType
              serialNumber = data.get("serialNumber", None)
              if serialNumber:
                  payload["serialNumber"] = serialNumber
      return payload


  def formatBatchData(cveData):
      if len(cveData) != 0:
          for _data in cveData:
              cvssScore = _data.get("cvssScore", 0)
              if cvssScore is None:
                  _data.update({"cvssScore": 0})
              _data.update({"severity": _data.pop("severityV3")})
      return cveData


  def paginateDevicePerApi(vulnerabilties):
      """
      paginateDevicePerApi will paginate the Tanium response and send 100 cve's per api call.

      parameter vulnerabilties is the Tanium Response.

      """
      count = 0
      data = vulnerabilties.get("data", {}).get("endpoints", {}).get("edges", {})[0].get("node", {})
      payload = getFormattedDataForPayload(data)
      allFindings = data.get("compliance", {}).get("cveFindings", None)
      if allFindings:
          for _data in range(0, len(allFindings), 100):
              # slice the list to get 100 objects
              batch = allFindings[_data:_data + 100]
              formatedData = formatBatchData(batch)
              count += len(formatedData)
              payload.update({"cve": formatedData})
              taniumData = [payload]
              demisto.info(f"Payload for PAN API :- {taniumData}")
              # make the API call
              resp = sendVulnerabilityToPanwIotCloud(taniumData)
      return count


  def getAllVulnerabilities(accessToken, severity):
      """

      getAllVulnerabilities will get all endpoints along with their vulnerabilties using
      graphQL query and pagination.

      parameter accessToken is the api token string.
      """

      initQuery = """
      {
          endpoints(first: 1%s) {
              totalRecords
              edges {
                  node {
                      name
                      ipAddress
                      serialNumber
                      sensorReadings(sensors: [{name: "Network Adapters"}]) {
                          columns {
                              name
                              values
                          }
                      }
                      os {
                          name
                      }
                      compliance {
                          cveFindings(filter: {
                              filters: [
                              {
                                  path: "severityV3",
                                  value: "%s"
                              }]
                          }) {
                              cveId
                              cveYear
                              cvssScore
                              firstFound
                              lastFound
                              severityV3
                              summary
                          }
                      }
                  }
              }
              pageInfo {
                  endCursor
                  hasPreviousPage
                  hasNextPage
              }
          }
      }

      """
      totalCount, totalEndpoints = 0, 0
      nextQuery = initQuery
      nextPageFilter = ''
      while True:
          count = 0
          formattedQuery = nextQuery % (nextPageFilter, severity)
          demisto.info(f"Updated Query for tanium :- {formattedQuery}")
          # Call the command which will send a request with the query to the GraphQL endpoint
          getVulnerabilities = demisto.executeCommand(
              "get-tanium-vulnerabilties", {"query": formattedQuery, "access_token": accessToken}
          )
          if isError(getVulnerabilities[0]):
              err_msg = f'Error, failed to import valunerabilties from Tanium - {getVulnerabilities[0].get("Contents")}'
              raise Exception(err_msg)
          if isinstance(getVulnerabilities, list):
              vulnerabilities = getVulnerabilities[0].get('Contents', None)
              if vulnerabilities:
                  if vulnerabilities.get("data", {}).get("endpoints", {}).get("totalRecords", None) == 0:
                      break
                  count = paginateDevicePerApi(vulnerabilities)
                  totalEndpoints = vulnerabilities.get("data", {}).get("endpoints", {}).get("totalRecords", None)
                  # extract the page information from the json object
                  hasNextPage = vulnerabilities.get("data", {}).get("endpoints", {}).get("pageInfo", {}).get("hasNextPage", None)
                  endCursor = vulnerabilities.get("data", {}).get("endpoints", {}).get("pageInfo", {}).get("endCursor", None)

                  totalCount = totalCount + count

                  # if the next page is "False" then we reached the end of the dataset!
                  if not hasNextPage:
                      break

                  nextPageFilter = f',after: "{endCursor}"'

      return totalCount, totalEndpoints


  def getSeverityFilteredData(accessToken, severities):
      """
      getSeverityFilteredData will update severityV3 filter according to the values selected by customer
      and fetch all the data from Tanium.

      parameter query is the GraphQL query.
      parameter accessToken is the api token string.

      """
      totalCount, endpoints = 0, 0
      # Loop over the severities list and execute the query with each value
      for severity in severities:
          count, totalEndpoints = getAllVulnerabilities(accessToken, severity)
          if totalEndpoints > endpoints:
              endpoints = totalEndpoints
          totalCount = totalCount + count
      if totalCount != 0 and endpoints != 0:
          statusMsg = f"Successfully imported {endpoints} Tanium Endpoints along with total {totalCount} vulnerabilties to PANW IoT"
      else:
          statusMsg = "Failed to get data from get-tanium-vulnerabilties command"
      return totalCount, endpoints, statusMsg


  def getNewAccessToken(accessTokenName):
      accessToken = ""
      result = demisto.executeCommand("get-access-token", {"name": accessTokenName})
      if isinstance(result, list) and len(result) != 0:
          if isError(result[0]) or "access_token" not in result[0].get("Contents", None):
              errMsg = f'Error, failed to fetch access token from Tanium - {result[0].get("Contents")}'
              raise Exception(errMsg)
          listData = result[0].get("Contents", None)
          if listData:
              demisto.executeCommand("createList", {"listName": accessTokenName, "listData": listData})
              accessToken = listData.get("access_token", "")
      return accessToken


  def fetchAccessToken(tokenData, accessTokenName):
      accessToken = ''
      fetchToken = demisto.executeCommand("fetch-access-token", {"token_data": tokenData})
      if isinstance(fetchToken, list) and len(fetchToken) != 0:
          if isError(fetchToken[0]) or "access_token" not in fetchToken[0].get("Contents", None):
              errMsg = f'Error, failed to fetch access token from Tanium - {fetchToken[0].get("Contents")}'
              raise Exception(errMsg)
          listData = fetchToken[0].get("Contents", None)
          if listData:
              if listData != json.loads(tokenData):
                  demisto.executeCommand("createList", {"listName": accessTokenName, "listData": listData})
              accessToken = listData.get("access_token", "")
      return accessToken


  def executeGetAccessTokenCmd(accessTokenName):
      accessToken = ""
      listData = demisto.executeCommand("getList", {"listName": accessTokenName})
      if isinstance(listData, list) and len(listData) != 0:
          tokenData = listData[0].get("Contents", None)
          if tokenData:
              if "access_token" not in tokenData:
                  accessToken = getNewAccessToken(accessTokenName)
                  return accessToken
              accessToken = fetchAccessToken(tokenData, accessTokenName)
      return accessToken


  def main():
      severities = demisto.args().get("severities")
      if severities is None or len(severities) == 0:
          severities = ["Critical", "High", "Medium"]
      accessTokenName = TANIUM_ACTIVE_INSTAMCE + "_token"
      try:
          accessToken = executeGetAccessTokenCmd(accessTokenName)
          if accessToken:
              count, endpoints, statusMsg = getSeverityFilteredData(accessToken, severities)
              sendStatusToPanwIotCloud("success", statusMsg)

              reportSummary = {"Asset Type": "Total Assets Reported"}
              reportSummary.update({"Endpoints": endpoints, "Vulnerabiltiy": count})
              return_results(
                  CommandResults(
                      readable_output=tableToMarkdown("Asset Report Summary:", reportSummary, removeNull=True),
                      outputs_prefix="tanium",
                  )
              )
          else:
              return return_error("No access token")
      except Exception as ex:
          sendStatusToPanwIotCloud("error", str(ex))
          demisto.error(traceback.format_exc())
          return_error(str(ex))


  if __name__ in ("__main__", "__builtin__", "builtins"):
      main()

  register_module_line('SendTaniumVulnerabilityToPANWIoT', 'end', __line__())
scripttarget: 0
subtype: python3
tags: []
timeout: 100800h0m0s
type: python
