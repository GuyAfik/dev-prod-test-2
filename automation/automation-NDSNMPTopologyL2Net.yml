args:
- description: Local Entry IP
  name: local_entry_ip
  required: true
- description: Network Discovery Instance
  name: nd_instance
  required: true
commonfields:
  id: NDSNMPTopologyL2Net
  version: -1
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
dockerimage: demisto/netutils:1.0.0.24101
enabled: true
engineinfo: {}
mainengineinfo: {}
name: NDSNMPTopologyL2Net
pswd: ""
runas: DBotWeakRole
runonce: false
script: |
  register_module_line('NDSNMPTopologyL2Net', 'start', __line__())


  # from pysnmp.hlapi import *
  import socket
  import re
  from ipaddress import IPv4Network
  from netaddr import IPNetwork, IPAddress
  # from snmp_common import *
  # from snmp_topology_l2_cisco import get_cisco_vlan_info
  # from snmp_topology_l2_arubaos import get_arubaos_vlan_info
  # from snmp_topology_l2_arista_switch import get_arista_vlan_info

  # ***************** VLAN FUNCTIONS ******************
  VLAN_LIST = "vlan_list"
  DEFAULT_GATEWAY_LIST="default_gateway_list"
  NETWORK_DISCOVERY_INSTANCE = demisto.args().get("nd_instance")

  # *************** Standard BRIDGE-MIB based VLAN Discovery Functions ***************
  # BRIDGE-MIB Functions for the VLANs
  BRIDGE_MIB_DOT1Q_VLAN_TABLE_OID               = '1.3.6.1.2.1.17.7.1.4.2'
  BRIDGE_MIB_DOT1Q_VLAN_ID_OID                  = '1.3.6.1.2.1.17.7.1.4.2.1.3'
  BRIDGE_MIB_VLAN_EGRESS_PORTS_OID_PREFIX       = 'SNMPv2-SMI::mib-2.17.7.1.4.2.1.4'
  BRIDGE_MIB_VLAN_RAW_EGRESS_PORTS_OID_PREFIX   = '1.3.6.1.2.1.17.7.1.4.2.1.4'
  BRIDGE_MIB_VLAN_UNTAGGED_PORTS_OID_PREFIX     = 'SNMPv2-SMI::mib-2.17.7.1.4.2.1.5'
  BRIDGE_MIB_VLAN_RAW_UNTAGGED_PORTS_OID_PREFIX = '1.3.6.1.2.1.17.7.1.4.2.1.5'
  BRIDGE_MIB_DOT1Q_VLAN_TABLE_FDBID_OID         = '1.3.6.1.2.1.17.7.1.4.2.1.3'


  # Supported Vendors
  SWITCH = "switch"
  VENDOR_CISCO = "cisco"
  VENDOR_ARUBAOS = "arubaos"
  VENDOR_ARISTA = "arista"
  VENDOR_CISCO_AIREOS_WLC = "controller"
  VENDOR_CISCO_CATALYST_WLC = "C9"
  VLAN_ID = "vlan_id"
  VLAN_TRUNK_STATUS = "vlan_trunk"
  NO = "no"
  VLAN_STR = "VLAN"
  VLAN_IF_IDX = "vlan_if_idx"
  VLAN_IF_NAME = "vlan_intf_name"
  VLAN_IF_IP = "vlan_intf_ipaddr"
  VLAN_IF_LIST = "vlan_interface_list"
  INTERFACE_LIST = "interface_list"

  SYS_DESC_OID  = '1.3.6.1.2.1.1.1'

  IP_CIDR_ROUTES_OID  = '1.3.6.1.2.1.4.24.4.1.5'

  IP_SUBNET      = "ip_subnet"
  IP_SUBNET_MASK = "ip_subnet_mask"
  IP_SUBNET_GATEWAY = "ip_subnet_gateway"
  IP_SUBNET_IF   = "ip_subnet_interface"
  IP_DEFAULT_ROUTE_ADDR = "0.0.0.0"

  # *************** Get L3 Network Information *********************
  IP_IF_LIST = "ip_interface_list"
  IP_SUBNET_LIST = "ip_subnet_list"

  # System Description for Vendor discovery
  def get_str_from_hex(val):
      #Check if the string starts with 0x then convert it to utf-8
      if val.startswith('0x'):
          try:
              ver = bytes.fromhex(remove_prefix(val, '0x')).decode('utf-8')
          except:
              ver = val
      else:
          ver = val
      return ver

  def get_vendor(host):
      try:
          raw_result = walk(host, SYS_DESC_OID)
          for k, v in raw_result.items():
              sys_desc = get_str_from_hex(v)
              if re.search(VENDOR_CISCO, sys_desc, re.IGNORECASE):
                  if re.search(VENDOR_CISCO_AIREOS_WLC, sys_desc, re.IGNORECASE):
                      return VENDOR_CISCO_AIREOS_WLC
                  else:
                      return VENDOR_CISCO
              elif re.search(VENDOR_ARUBAOS, sys_desc, re.IGNORECASE):
                  return VENDOR_ARUBAOS
              elif re.search(VENDOR_ARISTA, sys_desc, re.IGNORECASE):
                  return VENDOR_ARISTA
              else:
                  return "NA"
      except Exception as ex:
          print(ex)

  def walk(ip,oid):
      response = demisto.executeCommand("nd-snmp-v2-walk-command", {
          "ip":ip,
          "oid": oid,
          "using": NETWORK_DISCOVERY_INSTANCE
      })
      if isError(response[0]):
          err_msg = 'Error, couldn\'t snmp v2 walk - '+str(response[0]['Contents'])
          raise Exception(err_msg)
      return response[0]['Contents']


  # ***************** IP Interface Functions*************
  # Below two OIDs for VLAN Subnet discovery
  IF_IDX_TO_IF_NAME_OID               = '1.3.6.1.2.1.31.1.1.1.1'
  IF_IDX_TO_IF_DESC_OID               = '1.3.6.1.2.1.2.2.1.2'
  IF_IDX_TO_IP_ADDR_OID               = '1.3.6.1.2.1.4.20.1.2'
  IF_IDX_TO_MAC_ADDRESS_OID           = '1.3.6.1.2.1.2.2.1.6'
  IF_IDX_TO_OPER_STATUS_OID           = '1.3.6.1.2.1.2.2.1.8'

  IF_INDEX = "intf_index"
  IF_NAME = "intf_name"
  IF_IP4_ADDR = "intf_ipv4_addr"
  IF_MAC_ADDR = "intf_mac_addr"
  IF_OPER_STATUS = "intf_operational_status"

  def get_ip_interface_info(host):
      if_info = {}
      # SNMP Walk to get IF Names
      raw_result = walk(host, IF_IDX_TO_IF_DESC_OID)
      for k, v in raw_result.items():
          if_idx = k.split('.')[-1]
          if if_idx not in if_info:
              if_info[if_idx] = {}
          if_info[if_idx][IF_NAME] = v.strip()

      # SNMP Walk to get IF IP address
      raw_result = walk(host, IF_IDX_TO_IP_ADDR_OID)
      for k, v in raw_result.items():
          if_idx = v
          ip = '.'.join(k.strip().split('.')[-4:])
          if is_valid_ipv4_address(ip):
              if if_idx in if_info:
                  if_info[if_idx][IF_IP4_ADDR] = ip

      # SNMP Walk to get IF MAC address
      raw_result = walk(host, IF_IDX_TO_MAC_ADDRESS_OID)
      for k, v in raw_result.items():
          if(v!=''):
              if_idx = k.strip().split('.')[-1]
              mac = remove_prefix(v,"0x")
              if(len(mac) == 12):
                  mac_colon = ':'.join(mac[i:i + 2] for i in range(0, 12, 2))
              if if_idx in if_info:
                  if_info[if_idx][IF_MAC_ADDR]=mac_colon

      # SNMP Walk to get IF operational status
      raw_result = walk(host, IF_IDX_TO_OPER_STATUS_OID)
      for k, v in raw_result.items():
          if(v!=''):
              if_idx = k.strip().split('.')[-1]
              if if_idx in if_info:
                  val=''
                  if v == '1':
                      val='up'
                  elif v == '2':
                      val='down'
                  elif v == '3':
                      val='testing'
                  elif v == '4':
                      val='unknown'
                  elif v == '5':
                      val='dormant'
                  elif v == '6':
                      val='notPresent'
                  else:
                      val='lowerLayerDown'
                  if_info[if_idx][IF_OPER_STATUS]=val
      # Return the IP Interface list
      return if_info

  def is_valid_ipv4_address(address):
      try:
          socket.inet_pton(socket.AF_INET, address)
      except AttributeError:  # no inet_pton here, sorry
          try:
              socket.inet_aton(address)
          except socket.error:
              return False
          return address.count('.') == 3
      except socket.error:  # not a valid address
          return False

      return True

  # GET Port list for each VLAN and Trunk Status (Tagged = TRUNK)

  # Portlist is a bit map based on the position of the Interface index
  # For example: 0x08003 is IF indexes [9, 23, 24] based on the bit positions starting from left
  def get_std_vlan_untagged_interfaces_portlist(val, vlan_idx, result_map, if_info_map):
      port_str = remove_prefix(val.lstrip(), '0x')
      temp_list = '.'.join(str(int(a+b,16)) for a,b in zip(port_str[::2], port_str[1::2]) if a and b)
      # Parse through the DOT seperated list of Octets and convert them to Port list based on IF indexes
      base_idx = 0
      for v in temp_list.split("."):
          local_idx  = 1
          if v:
              v_int = int(v)
              while local_idx <= 8:
                  if v_int & 128 == 128:
                      port_idx = base_idx + local_idx
                      if str(port_idx) in if_info_map:
                          port_name = if_info_map[str(port_idx)][IF_NAME]
                      else:
                          port_name = port_idx
                      # Add Port index and interface name to this VLAN
                      if port_name not in result_map:
                          result_map[port_name] = {}
                          result_map[port_name][IF_INDEX] = port_idx
                          result_map[port_name][IF_NAME] = port_name
                          result_map[port_name][VLAN_ID] = vlan_idx
                      else:
                          result_map[port_name][VLAN_TRUNK_STATUS] = NO
                  v_int = v_int << 1
                  local_idx += 1
              base_idx += 8

  def get_std_vlan_untagged_portlist(k, v, result_map, if_info_map):
      if BRIDGE_MIB_VLAN_UNTAGGED_PORTS_OID_PREFIX not in k:
          if BRIDGE_MIB_VLAN_RAW_UNTAGGED_PORTS_OID_PREFIX not in k:
              return
      # GET VLAN ID
      vlan_idx = k.split('.')[-1]
      if vlan_idx != " " and len(vlan_idx) > 0:
          # Get port list/interfaces for this VLAN
          get_std_vlan_untagged_interfaces_portlist(v, vlan_idx, result_map, if_info_map)

  # Portlist is a bit map based on the position of the Interface index
  # For example: 0x08003 is IF indexes [9, 23, 24] based on the bit positions starting from left
  def get_std_vlan_interfaces_from_portlist(val, vlan_idx, result_map, if_info_map):
      port_str = remove_prefix(val.lstrip(), '0x')
      temp_list = '.'.join(str(int(a+b,16)) for a,b in zip(port_str[::2], port_str[1::2]) if a and b)
      # Parse through the DOT seperated list of Octets and convert them to Port list based on IF indexes
      base_idx = 0
      for v in temp_list.split("."):
          local_idx  = 1
          if v:
              v_int = int(v)
              while local_idx <= 8:
                  if v_int & 128 == 128:
                      port_idx = base_idx + local_idx
                      if str(port_idx) in if_info_map:
                          port_name = if_info_map[str(port_idx)][IF_NAME]
                      else:
                          port_name = port_idx
                      # Add Port index and interface name to this VLAN
                      if port_name not in result_map:
                          result_map[port_name] = {}
                      result_map[port_name][IF_INDEX] = port_idx
                      result_map[port_name][IF_NAME] = port_name
                      result_map[port_name][VLAN_ID] = vlan_idx
                  v_int = v_int << 1
                  local_idx += 1
              base_idx += 8

  def get_std_vlan_portlist(k, v, result_map, if_info_map):
      if BRIDGE_MIB_VLAN_EGRESS_PORTS_OID_PREFIX not in k:
          if BRIDGE_MIB_VLAN_RAW_EGRESS_PORTS_OID_PREFIX not in k:
              return
      # GET VLAN ID
      vlan_idx = k.split('.')[-1]
      if vlan_idx != " " and len(vlan_idx) > 0:
          # Get port list/interfaces for this VLAN
          get_std_vlan_interfaces_from_portlist(v, vlan_idx, result_map, if_info_map)

  def get_std_vlan_interface_info(host, result_map, if_info_map):
      # SNMP Walk to get IF Names
      raw_result = walk(host, BRIDGE_MIB_DOT1Q_VLAN_TABLE_OID)
      for k, v in raw_result.items():
          get_std_vlan_portlist(k, v, result_map, if_info_map)
          get_std_vlan_untagged_portlist(k, v, result_map, if_info_map)
      if_indexes = if_info_map.keys()
      for if_idx in if_indexes:
          if_name = if_info_map[if_idx][IF_NAME]
          if if_name not in result_map:
              result_map[if_name] = {}
          if IF_IP4_ADDR in if_info_map[if_idx]:
              ip = if_info_map[if_idx][IF_IP4_ADDR]
              result_map[if_name][IF_IP4_ADDR] = ip
          if IF_MAC_ADDR in if_info_map[if_idx]:
              mac = if_info_map[if_idx][IF_MAC_ADDR]
              # mac_colon = ':'.join(mac[i:i + 2] for i in range(0, 12, 2))
              result_map[if_name][IF_MAC_ADDR] = mac
          if IF_OPER_STATUS in if_info_map[if_idx]:
              operational_status = if_info_map[if_idx][IF_OPER_STATUS]
              result_map[if_name][IF_OPER_STATUS] = operational_status


  def remove_prefix(text, oid_prefix):
      if text.startswith(oid_prefix):
          return text[len(oid_prefix):]
      return text

  # GET VLAN ID information - name, ip address/subnet
  def get_std_vlan_id_if_entry(key, val, result_map, if_ip_map, ip_subnet_list):
      if VLAN_STR in val:
          vlan_id = remove_prefix(val, VLAN_STR)
          if_idx = key.split('.')[-1]
          if vlan_id not in result_map:
              result_map[vlan_id] = {}
          result_map[vlan_id][VLAN_ID] = vlan_id
          result_map[vlan_id][VLAN_IF_IDX] = if_idx
          if if_idx in if_ip_map:
              vlan_if_name = if_ip_map[if_idx][IF_NAME]
              result_map[vlan_id][VLAN_IF_NAME] = vlan_if_name
              result_map[vlan_id][IP_SUBNET] = get_ip_subnet_using_vlan_name(vlan_if_name,ip_subnet_list)
              if IF_IP4_ADDR in if_ip_map[if_idx]:
                  result_map[vlan_id][VLAN_IF_IP] = if_ip_map[if_idx][IF_IP4_ADDR]


  def update_ip_subnet_list_with_gateway_ip(vlan_id_map, ip_subnet_list):
      if len(vlan_id_map) > 0:
          for k,v in vlan_id_map.items():
              if 'vlan_intf_name' in v.keys() and 'vlan_ip' in v.keys():
                  vlan_intf_name = v['vlan_intf_name']
                  vlan_if_ip = v['vlan_ip']
                  if len(ip_subnet_list) > 0:
                      for k,v in ip_subnet_list.items():
                           if 'ip_subnet_interface' in v.keys():
                                  ip_subnet_interface = v['ip_subnet_interface']
                                  if vlan_intf_name == ip_subnet_interface:
                                      separator='.'
                                      gateway_ip = separator.join(vlan_if_ip.split(separator, 3)[:-1])
                                      default_gateway_ip = gateway_ip+".1"
                                      if default_gateway_ip in default_gateway_map.keys():
                                          v['gateway_ip']=default_gateway_ip
                                      else:
                                          v['gateway_ip']=vlan_if_ip
                                      continue



  def get_ip_subnet_using_vlan_name(vlan_intf_name, ip_subnet_list):
      if len(ip_subnet_list) > 0:
          for k, v in ip_subnet_list.items():
              if IP_SUBNET_IF in v.keys() and IP_SUBNET in v.keys():
                  ip_subnet_interface = v[IP_SUBNET_IF]
                  if ip_subnet_interface == vlan_intf_name:
                      ip_subnet = v[IP_SUBNET]
                      return ip_subnet
      return ""

  def get_std_vlan_id_info(host, result_map, if_ip_map, ip_subnet_list):
      # SNMP Walk to get VLAN IDs
      raw_result = walk(host, BRIDGE_MIB_DOT1Q_VLAN_TABLE_FDBID_OID)
      for k, v in raw_result.items():
          vlan_id = k.split('.')[-1]
          if vlan_id not in result_map:
              result_map[vlan_id] = {}
          result_map[vlan_id][VLAN_ID] = vlan_id

      # SNMP Walk to get IF Names
      raw_result = walk(host, IF_IDX_TO_IF_NAME_OID)
      for k, v in raw_result.items():
          get_std_vlan_id_if_entry(k, v, result_map, if_ip_map, ip_subnet_list)

  def get_std_vlan_info(host):
      result_map = {}
      vlan_id_map = {}
      vlan_intf_map = {}
      if_info_map = {}

      # Get interface information
      if_info_map = get_ip_interface_info(host)
      # return_outputs('ip_info_map:'+str(if_info_map))
      if len(if_info_map) == 0:
          return result_map

      # Get VLAN Interface information
      get_std_vlan_interface_info(host, vlan_intf_map, if_info_map)
      if len(vlan_intf_map) == 0:
          return result_map
      else:
          result_map[INTERFACE_LIST] = vlan_intf_map

      dhcp_ip_list = get_snmp_service_dhcp_info(host)
      result_map['dhcp_ip_list']=dhcp_ip_list

      #Return the IP_SUBNET_LIST information
      ip_subnet_list = get_ip_subnet_info(host, if_info_map, dhcp_ip_list)


      # Get VLAN ID and Interfaces information
      get_std_vlan_id_info(host, vlan_id_map, if_info_map, ip_subnet_list)

      update_ip_subnet_list_with_gateway_ip(vlan_id_map, ip_subnet_list)

      result_map[IP_SUBNET_LIST] = ip_subnet_list
      if len(vlan_id_map) == 0:
          result_map[VLAN_LIST] = {}
      else:
          result_map[VLAN_LIST] = vlan_id_map


      result_map[DEFAULT_GATEWAY_LIST] = get_default_gateway_list(ip_subnet_list)
      # result_map['node_ip']=host
      # result_map['node_mac_address']=get_mac_address_from_interface_info(ip, if_info_map)
      return result_map

  def get_default_gateway_list(ip_subnet_list):
      default_gateway_list={}
      if len(ip_subnet_list) > 0:
          for k,v in ip_subnet_list.items():
              if isinstance(v, dict) and 'ip_subnet_gateway' in v.keys():
                  ip_subnet_gateway = v['ip_subnet_gateway']
                  separator = "."
                  default_gateway_subnet = findLongestMatch(ip_subnet_gateway,ip_subnet_list)
                  if default_gateway_subnet == '':
                      default_gateway_subnet = separator.join(ip_subnet_gateway.split(separator, 3)[:-1])
                      default_gateway_subnet = default_gateway_subnet+".0/24"
                  default_gateway_list[ip_subnet_gateway]={"interface":[],"default_gateway_subnet":default_gateway_subnet}
      return default_gateway_list

  def findLongestMatch(ipaddr, ip_subnet_list):
      longest_prefix = 32
      longest_match = ''
      for k, v in ip_subnet_list.items():
          ip_subnet = v['ip_subnet']
          if ip_subnet != '0.0.0.0':
              ip_subnet_mask = v['ip_subnet_mask']
              try:
                  ip = IPv4Network(ip_subnet+'/'+ip_subnet_mask)

                  if IPAddress(ipaddr) in IPNetwork(ip_subnet+'/'+str(ip.prefixlen)):
                      if ip.prefixlen < longest_prefix:
                          longest_prefix = ip.prefixlen
                          longest_match=ip_subnet+'/'+str(ip.prefixlen)
              except Exception as e:
                  demisto.error('error while loading IPv4Network/IPAddress: '+ str(e))

      return longest_match

  def get_cisco_vlan_info(ip):
      response = demisto.executeCommand("NDSNMPTopologyL2Cisco", {
          "local_entry_ip":ip,
          "nd_instance": NETWORK_DISCOVERY_INSTANCE
      })
      if isError(response[0]):
          err_msg = 'Error while executing NDSNMPTopologyL2Cisco- '+str(response[0]['Contents'])
          raise Exception(err_msg)
      return response[0]['Contents']

  def get_arubaos_vlan_info(ip):
      response = demisto.executeCommand("NDSNMPTopologyL2ArubaOS", {
          "local_entry_ip":ip,
          "nd_instance": NETWORK_DISCOVERY_INSTANCE
      })
      if isError(response[0]):
          err_msg = 'Error while executing NDSNMPTopologyL2ArubaOS- '+str(response[0]['Contents'])
          raise Exception(err_msg)
      return response[0]['Contents']

  def get_arista_vlan_info(ip):
      response = demisto.executeCommand("NDSNMPTopologyL2AristaSwitch", {
          "local_entry_ip":ip,
          "nd_instance": NETWORK_DISCOVERY_INSTANCE
      })
      if isError(response[0]):
          err_msg = 'Error while executing NDSNMPTopologyL2AristaSwitch- '+str(response[0]['Contents'])
          raise Exception(err_msg)
      return response[0]['Contents']

  def get_snmp_service_dhcp_info(ip):
      response = demisto.executeCommand("NDSNMPServiceDHCP", {
          "local_entry_ip":ip,
          "nd_instance": NETWORK_DISCOVERY_INSTANCE
      })
      if isError(response[0]):
          err_msg = 'Error while executing NDSNMPServiceDHCP- '+str(response[0]['Contents'])
          raise Exception(err_msg)
      return response[0]['Contents']

  def get_snmp_service_dns_info(ip):
      response = demisto.executeCommand("NDSNMPServiceDNS", {
          "local_entry_ip":ip,
          "nd_instance": NETWORK_DISCOVERY_INSTANCE
      })
      if isError(response[0]):
          err_msg = 'Error while executing NDSNMPServiceDNS- '+str(response[0]['Contents'])
          raise Exception(err_msg)
      return response[0]['Contents']

  def get_ip_subnet_info(host, ip_if_list, dhcp_ip_list):
      ip_subnet_info = {}
      # SNMP Walk to get IF Names
      raw_result = walk(host, IP_CIDR_ROUTES_OID)
      for k, v in raw_result.items():
          ip_rem_prefix = remove_prefix(k, IP_CIDR_ROUTES_OID)
          ip_entry = ip_rem_prefix.split('.')
          if len(ip_entry) == 14:
              # Get IP address
              ip_addr = '.'.join(ip_entry[1:5])
              ip_mask = '.'.join(ip_entry[5:9])
              if ip_mask == '255.255.255.255':
                  continue
              if ip_addr not in ip_subnet_info:
                  ip_subnet_info[ip_addr] = {}
              ip_subnet_info[ip_addr][IP_SUBNET] = ip_addr
              # Get IP Subnet Mask
              ip_subnet_info[ip_addr][IP_SUBNET_MASK] = ip_mask
              # Get Gateway if present
              ip_gateway = '.'.join(ip_entry[10:14])
              if ip_gateway != IP_DEFAULT_ROUTE_ADDR:
                  ip_subnet_info[ip_addr][IP_SUBNET_GATEWAY] = ip_gateway
              # Get IF name
              if v in ip_if_list:
                  interface_name = ip_if_list[v][IF_NAME]
                  ip_subnet_info[ip_addr][IP_SUBNET_IF] = interface_name
                  ip_subnet_info[ip_addr]['dhcp_server_ip'] = get_dhcp_server_ip_using_ip_subnet_intf(interface_name, dhcp_ip_list)


      # Return the IP Subnet list
      return ip_subnet_info

  def get_dhcp_server_ip_using_ip_subnet_intf(ip_subnet_interface, dhcp_ip_list):

      for k, v in dhcp_ip_list.items():
          for each_intf in v:
              if 'interface_name' in each_intf.keys():
                  interface_name = each_intf['interface_name']
                  if interface_name == ip_subnet_interface:
                      return k
      return ""

  def check_if_network_device(result_map):
      if INTERFACE_LIST in result_map.keys():
          interface_list = result_map[INTERFACE_LIST]
          return len(interface_list)>0
      else:
          return False

      # if IP_SUBNET_LIST in l2l3.keys():
      #     ip_subnet_list = l2l3[IP_SUBNET_LIST]
      #     return len(ip_subnet_list) > 0
      # else:
      #     return False

      # if VLAN_LIST in l2l3.keys():
      #     vlan_list = l2l3[VLAN_LIST]
      #     return len(vlan_list) > 0
      # else:
      #     return False

  def get_vlan_info(host):
      result_map = {}
      # Get Vendor Specific Vlan information
      vendor = get_vendor(host)
      # return_outputs("Vendor: "+ str(vendor))

      if vendor == None or vendor == "NA":
          result_map = get_std_vlan_info(host)

      elif vendor == VENDOR_CISCO:
          result_map = get_cisco_vlan_info(host)
      elif vendor == VENDOR_ARUBAOS:
          result_map = get_arubaos_vlan_info(host)
      elif vendor == VENDOR_ARISTA:
          # return_outputs("Get l2 info for:", vendor)
          result_map = get_arista_vlan_info(host)



      # adding is_network_device
      is_network_device = check_if_network_device(result_map)
      result_map['is_network_device']=is_network_device
      # adding dhcp and dns info
      # dhcp_ip_list = get_snmp_service_dhcp_info(host)
      # result_map['dhcp_ip_list']=dhcp_ip_list
      dns_ip_list_map = get_snmp_service_dns_info(host)
      result_map['dns_ip_list']=dns_ip_list_map['dns_ip_list']
      # Return the result
      return result_map

  def main():
      try:
          ENTRY_IP = demisto.args().get('local_entry_ip')
          vlan_info = get_vlan_info(ENTRY_IP)
          # return_outputs("NDSNMPTopologyL2Net-finished SNMP probing for VLAN data for Node!"+str(vlan_info))
          # return_outputs(vlan_info)
          return_results(vlan_info)

      except Exception as e:
          raise Exception("NDSNMPTopologyL2Net - Failed to get Node VLAN data: %s" % str(e))



  if __name__ in ('__main__', '__builtin__', 'builtins'):
      main()

  register_module_line('NDSNMPTopologyL2Net', 'end', __line__())
scripttarget: 0
subtype: python3
tags: []
timeout: 100800h0m0s
type: python
