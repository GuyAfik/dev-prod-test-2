category: Network Security
commonfields:
  id: IronDefense
  version: -1
configuration:
- display: IronAPI Host/IP
  name: ironAPIHost
  required: true
  type: 0
- defaultvalue: "6942"
  display: IronAPI Port
  name: ironAPIPort
  required: true
  type: 0
- display: Username
  name: credentials
  required: true
  type: 9
- defaultvalue: "60"
  display: Request Timeout (Sec)
  name: requestTimeout
  required: false
  type: 0
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Incident type
  name: incidentType
  required: false
  type: 13
- defaultvalue: "true"
  display: Enable Alert Notification Ingestion (Refresh Not Supported)
  name: enableAlertNotifications
  required: false
  type: 8
- defaultvalue: "200"
  display: Alert Notification Limit Per Request. (Max 500)
  name: alertLimit
  required: false
  type: 0
- display: Alert Notification Categories to Exclude
  name: alertCategories
  options:
  - C2
  - Action
  - Access
  - Recon
  - Other
  required: false
  type: 16
- display: Alert Notification SubCategories to Exclude, See https://ironnet.atlassian.net/wiki/x/hADvGg
    for values (Enter in comma separated list format)
  name: alertSubCategories
  required: false
  type: 12
- defaultvalue: "0"
  display: Lower Bound of Severity for Alert Notification (0-1000)
  name: alertSeverityLower
  required: false
  type: 0
- defaultvalue: "1000"
  display: Upper Bound of Severity for Alert Notification (0-1000)
  name: alertSeverityUpper
  required: false
  type: 0
- display: Alert Notification Actions to Include (Alert Created enabled by default)
  name: alertActions
  options:
  - Alert Created
  - Alert Updated
  - Workflow Created
  - Workflow Updated
  - Alert Deleted
  - Note Created
  - Note Updated
  - Alert Event Added
  required: false
  type: 16
- defaultvalue: "false"
  display: Enable Event Notification Ingestion (Refresh Not Supported)
  name: enableEventNotifications
  required: false
  type: 8
- defaultvalue: "200"
  display: Event Notification Limit Per Request. (Max 500)
  name: eventLimit
  required: false
  type: 0
- display: Event Notification Categories to Exclude
  name: eventCategories
  options:
  - C2
  - Action
  - Access
  - Recon
  - Other
  required: false
  type: 16
- display: Event Notification SubCategories to Exclude, See https://ironnet.atlassian.net/wiki/x/hADvGg
    for values (Enter in comma separated list format)
  name: eventSubCategories
  required: false
  type: 12
- defaultvalue: "0"
  display: Lower Bound of Severity for Event Notification (0-1000)
  name: eventSeverityLower
  required: false
  type: 0
- defaultvalue: "1000"
  display: Upper Bound of Severity for Event Notification (0-1000)
  name: eventSeverityUpper
  required: false
  type: 0
- display: Event Notification Actions to Include (Event Created enabled by default)
  name: eventActions
  options:
  - Event Created
  - Event Retro Whitelisted
  - Event Added to Alert
  - Event Deleted
  - Event Alert Under Review
  - Event Alert Closed
  required: false
  type: 16
- defaultvalue: "false"
  display: Enable Dome Notification Ingestion (Refresh Not Supported)
  name: enableDomeNotifications
  required: false
  type: 8
- defaultvalue: "500"
  display: Dome Notification Limit Per Request. (Max 500)
  name: domeLimit
  required: false
  type: 0
- display: Dome Notification Types to Exclude
  name: domeCategories
  options:
  - Participant Added
  - Comment Added
  - Community Severity Changed
  - Community Severity Mismatched
  - Enterprise Severity Mismatched
  - Severity Suspicious
  - Severity Malicious
  - Joined High Risk
  - High Cognitive System Score
  required: false
  type: 16
- defaultvalue: "1"
  display: Alerts Fetch Interval
  name: alertFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.0.0
    itemVersion: 1.1.32
    packID: IronDefense
    packName: IronNet
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
defaultclassifier: IronDefense
defaultmapperin: IronDefense-mapper
description: The IronDefense Integration for Cortex allows users to interact with
  IronDefense alerts within Cortex. The Integration provides the ability to rate alerts,
  update alert statuses, add comments to alerts, to report observed bad activity,
  get alerts, get events, and get IronDome information.
detaileddescription: "### Partner Contributed Integration\n#### Integration Author:
  Iron Defense\nSupport and maintenance for this integration are provided by the author.
  Please use the following contact details:\n- **Email**: [support@ironnetcybersecurity.com](mailto:support@ironnetcybersecurity.com)\n-
  **URL**: [https://ironnet.atlassian.net/servicedesk/customer/portal/4](https://ironnet.atlassian.net/servicedesk/customer/portal/4)\n***\n#
  IronDefense Integration for Cortex\nThe IronDefense Integration allows users to
  interact with IronDefense alerts within Cortex. The \nIntegration provides the ability
  to rate alerts, update alert statuses, add comments to alerts, to report \nobserved
  bad activity, get alerts, get events, and get IronDome information.\n## Setup\nThe
  following table describes all the parameters required to setup the Integration.\n\n|
  Parameter                                      | Description                                                                                       |
  Example                  |\n|------------------------------------------------|---------------------------------------------------------------------------------------------------|--------------------------|\n|
  IronAPI Host/IP                                | The hostname or IP where IronAPI
  is hosted. This is provided by your IronNet Representative.      | example.ironapi.hostname
  |\n| IronAPI Port                                   | The port number IronAPI communicates
  on. This is provided by your IronNet Representative.         | 1234                     |\n|
  Username                                       | An IronVue user belonging to the
  \"IronAPI Access\" user group.                                     | email@company.com
  |\n| Password                                       | The password for the IronVue
  user.                                                                | my_secret_password
  \      |\n| Request Timeout (Sec)                          | The number of seconds
  before requests to IronAPI times out. The default value is 60 seconds.      | 60
  \                      |\n| Dome Notification Types to Exclude             | The
  list of Dome Notification types to exclude. Possible values are Participant Added,
  Comment Added, Community Severity Changed, Community Severity Mismatched, Enterprise
  Severity Mismatched, Severity Suspicious, Severity Malicious, Joined High Risk,
  and High Cognitive System Score. | Participant Added, Comment Added |\n| Disable
  all Dome Notification Ingestion        | Option to turn off ingestion of all Dome
  Notifications.                                           | true                     |\n|
  Alert Notification Categories to Exclude       | The list of Alert Notification
  categories to exclude. Possible values are C2, Action, Access, Recon, and Other.
  | Recon, Other |\n| Alert Notification SubCategories to Exclude    | The list of
  Alert Notification subcategories to exclude.                                          |
  DNS_TUNNELING, INTERNAL_PORT_SCANNING |\n| Lower Bound of Severity for Alert Notification
  | The minimum severity for an Alert Notifications to be ingested. Alerts with severities
  below this value will be excluded. | 400 |\n| Upper Bound of Severity for Alert
  Notification | The maximum severity for an Alert Notifications to be ingested. Alerts
  with severities above this value will be excluded. | 900 |\n| Disable all Alert
  Notification Ingestion       | Option to turn off ingestion of all Alert Notifications.
  \                                         | true                     |\n| Event
  Notification Categories to Exclude       | The list of Event Notification categories
  to exclude. Possible values are C2, Action, Access, Recon, and Other. | Recon, Other
  |\n| Event Notification SubCategories to Exclude    | The list of Event Notification
  subcategories to exclude.                                          | DNS_TUNNELING,
  INTERNAL_PORT_SCANNING |\n| Lower Bound of Severity for Event Notification | The
  minimum severity for an Event Notifications to be ingested. Events with severities
  below this value will be excluded. | 400 |\n| Upper Bound of Severity for Event
  Notification | The maximum severity for an Event Notifications to be ingested. Events
  with severities above this value will be excluded. | 900 |\n| Disable all Event
  Notification Ingestion       | Option to turn off ingestion of all Event Notifications.
  \                                         | true                     |\n| Dome Notification
  limit per request            | The limit on Dome Notifications returned per request.
  \                                            | 500                      |\n| Alert
  Notification limit per request           | The limit on Alert Notifications returned
  per request.                                            | 500                      |\n|
  Event Notification limit per request           | The limit on Event Notifications
  returned per request.                                            | 500                      |\n\n\n---\n[View
  Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/iron-defense)"
display: IronDefense (Partner Contribution)
image: data:image/png;base64,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
name: IronDefense
script:
  commands:
  - arguments:
    - description: The ID of the IronDefense alert.
      name: alert_id
      required: true
    - auto: PREDEFINED
      description: 'The severity rating of the alert. Can be: "Undecided", "Benign",
        "Suspicious", "Malicious".'
      name: severity
      predefined:
      - Undecided
      - Benign
      - Suspicious
      - Malicious
      required: true
    - auto: PREDEFINED
      description: 'Determines whether the rating was expected. Can be: "Unknown",
        "Expected", "Unexpected". Use "Unknown" if the rating is undecided.'
      name: expectation
      predefined:
      - Unknown
      - Expected
      - Unexpected
      required: true
    - description: Explains the rating of the alert.
      name: comments
      required: true
    - auto: PREDEFINED
      description: Whether to share the comment with IronDome.
      name: share_comment_with_irondome
      predefined:
      - "True"
      - "False"
      required: true
    description: Rates an IronDefense alert.
    name: irondefense-rate-alert
  - arguments:
    - description: The ID of the IronDefense alert.
      name: alert_id
      required: true
    - description: Explains the rating of the alert.
      name: comment
      required: true
    - auto: PREDEFINED
      description: Whether to share the comment with IronDome.
      name: share_comment_with_irondome
      predefined:
      - "True"
      - "False"
      required: true
    description: Adds a comment to an IronDefense alert.
    name: irondefense-comment-alert
  - arguments:
    - description: The ID of the IronDefense alert.
      name: alert_id
      required: true
    - auto: PREDEFINED
      description: 'The alert status to set. Can be: "Awaiting Review", "Under Review",
        "Closed".'
      name: status
      predefined:
      - Awaiting Review
      - Under Review
      - Closed
      required: true
    - description: Explains the status of the alert.
      name: comments
      required: true
    - auto: PREDEFINED
      description: Whether to share the comment with IronDome.
      name: share_comment_with_irondome
      predefined:
      - "True"
      - "False"
      required: true
    description: Sets the status of an IronDefense alert.
    name: irondefense-set-alert-status
  - arguments:
    - description: The name of the Threat Intelligence Rule (TIR) to be created.
      name: name
      required: true
    - description: A description of the observed bad endpoint.
      name: description
      required: true
    - description: The IP address of the observed bad endpoint.
      name: ip
    - description: The domain name of the observed bad endpoint.
      name: domain
    - description: The start time of the observed bad activity in RFC 3339 format
        (E.g. 2017-10-13T07:20:50.52Z).
      name: activity_start_time
      required: true
    - description: The end time of the observed bad activity in RFC 3339 format (E.g.
        2017-10-13T07:20:50.52Z).
      name: activity_end_time
      required: true
    description: Submits an observed bad endpoint to IronDefense to create Threat.
      Intelligence Rules (TIR).
    name: irondefense-report-observed-bad-activity
  - arguments:
    - description: The ID of the IronDefense event.
      name: event_id
      required: true
    description: Retrieves an IronDefense event.
    name: irondefense-get-event
    outputs:
    - contextPath: IronDefense.Event.id
      description: The event ID.
      type: String
    - contextPath: IronDefense.Event.alert_id
      description: The associated alert ID.
      type: String
    - contextPath: IronDefense.Event.category
      description: The event category.
      type: String
    - contextPath: IronDefense.Event.sub_category
      description: The event sub category.
      type: String
    - contextPath: IronDefense.Event.severity
      description: The event severity (0-1000).
      type: Number
    - contextPath: IronDefense.Event.confidence
      description: The event confidence (real number between 0-1).
      type: Number
    - contextPath: IronDefense.Event.created
      description: Time the event was created.
      type: Date
    - contextPath: IronDefense.Event.updated
      description: Time the event was last updated.
      type: Date
    - contextPath: IronDefense.Event.start_time
      description: The start time of this event's activity.
      type: Date
    - contextPath: IronDefense.Event.end_time
      description: The end time of this event's activity.
      type: Date
    - contextPath: IronDefense.Event.iron_dome_shared_time
      description: The time when the event was sent to IronDome - not present if not
        shared with irondome.
      type: Date
    - contextPath: IronDefense.Event.is_whitelisted
      description: True if the event activity was whitelisted, false otherwise.
      type: Boolean
    - contextPath: IronDefense.Event.is_blacklisted
      description: True if the event activity was blacklisted, false otherwise.
      type: Boolean
    - contextPath: IronDefense.Event.src_ip
      description: The source IP associated with this event.
      type: String
    - contextPath: IronDefense.Event.dst_ip
      description: The destination IP associated with this event.
      type: String
    - contextPath: IronDefense.Event.dst_port
      description: The destination port associated with this event.
      type: Number
    - contextPath: IronDefense.Event.ppp_domains
      description: Any domains associated with this event.
      type: String
    - contextPath: IronDefense.Event.primary_app_protocol
      description: The primary application protocol associated with this event.
      type: String
    - contextPath: IronDefense.Event.secondary_app_protocol
      description: The secondary application protocol associated with this event.
      type: String
    - contextPath: IronDefense.Event.bytes_in
      description: The byte count of incoming traffic for this event.
      type: Number
    - contextPath: IronDefense.Event.bytes_out
      description: The byte count of outgoing traffic for this event.
      type: Number
    - contextPath: IronDefense.Event.total_bytes
      description: The byte count of the total traffic (in either direction) for this
        event.
      type: Number
    - contextPath: IronDefense.Event.url
      description: The related URL for this event, if applicable.
      type: String
    - contextPath: IronDefense.Event.raw_data_formats
      description: The list of distinct raw data formats for this event.
      type: String
    - contextPath: IronDefense.Event.src_entity_attribute
      description: The source entity attribute related to this event, if one could
        be determined.
      type: String
    - contextPath: IronDefense.Event.src_entity_attribute_type
      description: The source entity attribute type related to this event, if one
        could be determined.
      type: String
    - contextPath: IronDefense.Event.dst_entity_attribute
      description: The destination entity attribute related to this event, if one
        could be determined.
      type: String
    - contextPath: IronDefense.Event.dst_entity_attribute_type
      description: The destination entity attribute type related to this event, if
        one could be determined.
      type: String
    - contextPath: IronDefense.Event.vue_url
      description: The url for displaying the event within IronVUE.
      type: String
    - contextPath: IronDefense.Event.Context.name
      description: The name of the context table.
      type: String
    - contextPath: IronDefense.Event.Context.columns
      description: Column values for the context table.
      type: String
  - arguments:
    - description: The list of Alert IDs to filter by.
      name: alert_id
    - auto: PREDEFINED
      description: The list of Alert categories to filter by.
      name: category
      predefined:
      - C2
      - Action
      - Access
      - Recon
      - Other
    - description: The list of Alert sub categories to filter by.
      name: sub_category
    - auto: PREDEFINED
      description: The list of Alert status to filter by.
      name: status
      predefined:
      - Awaiting Review
      - Under Review
      - Closed
    - auto: PREDEFINED
      description: The list of Alert analyst severity to filter by.
      name: analyst_severity
      predefined:
      - Undecided
      - Benign
      - Suspicious
      - Malicious
    - auto: PREDEFINED
      description: The list of Alert analyst expectation to filter by.
      name: analyst_expectation
      predefined:
      - Unknown
      - Expected
      - Unexpected
    - description: The minimum Alert severity to filter by. (0-1000).
      name: min_severity
    - description: The maximum Alert severity to filter by. (0-1000).
      name: max_severity
    - description: The minimum Alert created date to filter by in RFC 3339 format
        (E.g. 2017-10-13T07:20:50.52Z).
      name: min_created
    - description: The maximum Alert created date to filter by in RFC 3339 format
        (E.g. 2017-10-13T07:20:50.52Z).
      name: max_created
    - description: The minimum Alert updated date to filter by in RFC 3339 format
        (E.g. 2017-10-13T07:20:50.52Z).
      name: min_updated
    - description: The maximum Alert updated date to filter by in RFC 3339 format
        (E.g. 2017-10-13T07:20:50.52Z).
      name: max_updated
    - description: The minimum Alert first event created date to filter by in RFC
        3339 format (E.g. 2017-10-13T07:20:50.52Z).
      name: min_first_event_created
    - description: The maximum Alert first event created date to filter by in RFC
        3339 format (E.g. 2017-10-13T07:20:50.52Z).
      name: max_first_event_created
    - description: The minimum Alert last event created date to filter by in RFC 3339
        format (E.g. 2017-10-13T07:20:50.52Z).
      name: min_last_event_created
    - description: The maximum Alert last event created date to filter by in RFC 3339
        format (E.g. 2017-10-13T07:20:50.52Z).
      name: max_last_event_created
    - description: The minimum Alert first event start date to filter by in RFC 3339
        format (E.g. 2017-10-13T07:20:50.52Z).
      name: min_first_event_start_time
    - description: The maximum Alert first event start date to filter by in RFC 3339
        format (E.g. 2017-10-13T07:20:50.52Z).
      name: max_first_event_start_time
    - description: The minimum Alert last event end date to filter by in RFC 3339
        format (E.g. 2017-10-13T07:20:50.52Z).
      name: min_last_event_end_time
    - description: The maximum Alert last event end date to filter by in RFC 3339
        format (E.g. 2017-10-13T07:20:50.52Z).
      name: max_last_event_end_time
    - description: The list of Alert analytic versions to filter by.
      name: analytic_version
    - description: The limit on the number of Alerts to be returned.
      name: limit
    - description: The number of results to skip - used for paging the results.
      name: offset
    - description: The list of Alert fields to sort by.
      name: sort
    description: Pulls Alerts from IronDefense.
    name: irondefense-get-alerts
    outputs:
    - contextPath: IronDefense.Alert.id
      description: The ID of the alert.
      type: string
    - contextPath: IronDefense.Alert.category
      description: The category of the alert.
      type: string
    - contextPath: IronDefense.Alert.sub_category
      description: The subcategory of the alert.
      type: string
    - contextPath: IronDefense.Alert.severity
      description: The severity score of the alert. (0-1000).
      type: Number
    - contextPath: IronDefense.Alert.status
      description: The status of the alert.
      type: String
    - contextPath: IronDefense.Alert.analyst_severity
      description: The analyst severity of the alert.
      type: String
    - contextPath: IronDefense.Alert.analyst_expectation
      description: The analyst expectation of the alert.
      type: String
    - contextPath: IronDefense.Alert.created
      description: Time the alert was created in IronDefense.
      type: Date
    - contextPath: IronDefense.Alert.updated
      description: Time the alert was last updated in IronDefense.
      type: Date
    - contextPath: IronDefense.Alert.event_count
      description: The number of non-whitelisted events associated with this alert.
      type: Number
    - contextPath: IronDefense.Alert.FirstEventCreated
      description: The earliest created date of any associated event on this alert.
      type: String
    - contextPath: IronDefense.Alert.last_event_created
      description: The last created date of any associated event on this alert.
      type: String
    - contextPath: IronDefense.Alert.raw_data_format
      description: List of distinct raw data formats for this event.
      type: String
    - contextPath: IronDefense.Alert.aggregation_criteria
      description: Criteria used to build alert, specific to the event context fields.
      type: String
    - contextPath: IronDefense.Alert.vue_url
      description: The url for displaying the alert within IronVUE.
      type: String
    - contextPath: IronDefense.Query.GetAlerts.limit
      description: The maximum number of results that were requested to be returned.
      type: Number
    - contextPath: IronDefense.Query.GetAlerts.offset
      description: The number of results that were skipped - used for paging the results.
      type: Number
    - contextPath: IronDefense.Query.GetAlerts.total
      description: The total number of results possible from the query.
      type: Number
  - arguments:
    - description: The ID of the IronDefense alert.
      name: alert_id
      required: true
    description: Retrieves IronDome information for an IronDefense alert.
    name: irondefense-get-alert-irondome-information
    outputs:
    - contextPath: IronDome.Correlations.alert_id
      description: The alert ID the correlations are associated with.
      type: String
    - contextPath: IronDome.Correlations.dome_tag
      description: The IronDome tag.
      type: String
    - contextPath: IronDome.Correlations.correlation.correlations.ip
      description: The IP correlated on (if an IP correlation).
      type: String
    - contextPath: IronDome.Correlations.correlation.correlations.domain
      description: The Domain correlated on (if a Domain correlation).
      type: String
    - contextPath: IronDome.Correlations.correlation.correlations.behavior
      description: True if the correlation was behavior-based.
      type: Boolean
    - contextPath: IronDome.Correlations.correlation.correlations.enterprise_correlations
      description: The number of enterprise correlations.
      type: Number
    - contextPath: IronDome.Correlations.correlation.correlations.community_correlations
      description: The number of community correlations.
      type: Number
    - contextPath: IronDome.CorrelationParticipation.alert_id
      description: The alert ID the correlation participants are associated with.
      type: String
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.dome_tag
      description: The IronDome tag.
      type: String
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.behavior.malicious_count
      description: Count of malicious ratings.
      type: Number
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.behavior.suspicious_count
      description: Count of suspicious ratings.
      type: Number
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.behavior.benign_count
      description: Count of benign ratings.
      type: Number
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.behavior.whitelisted_count
      description: Count of whitelisted ratings.
      type: Number
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.behavior.comments_count
      description: Count of comments made.
      type: Number
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.behavior.activity_count
      description: Count of activity.
      type: Number
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.behavior.resource_owner
      description: True if the caller is the resource owner.
      type: Boolean
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.behavior.first_seen
      description: The time the activity was first seen.
      type: Date
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.behavior.last_seen
      description: The time the activity was last seen.
      type: Date
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.domain.malicious_count
      description: Count of malicious ratings.
      type: Number
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.domain.suspicious_count
      description: Count of suspicious ratings.
      type: Number
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.domain.benign_count
      description: Count of benign ratings.
      type: Number
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.domain.whitelisted_count
      description: Count of whitelisted ratings.
      type: Number
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.domain.comments_count
      description: Count of comments made.
      type: Number
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.domain.activity_count
      description: Count of activity.
      type: Number
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.domain.resource_owner
      description: True if the caller is the resource owner.
      type: Boolean
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.domain.first_seen
      description: The time the activity was first seen.
      type: Date
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.domain.last_seen
      description: The time the activity was last seen.
      type: Date
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.ip.malicious_count
      description: Count of malicious ratings.
      type: Number
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.ip.suspicious_count
      description: Count of suspicious ratings.
      type: Number
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.ip.benign_count
      description: Count of benign ratings.
      type: Number
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.ip.whitelisted_count
      description: Count of whitelisted ratings.
      type: Number
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.ip.comments_count
      description: Count of comments made.
      type: Number
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.ip.activity_count
      description: Count of activity.
      type: Number
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.ip.resource_owner
      description: True if the caller is the resource owner.
      type: Boolean
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.ip.first_seen
      description: The time the activity was first seen.
      type: Date
    - contextPath: IronDome.CorrelationParticipation.correlation_participation.ip.last_seen
      description: The time the activity was last seen.
      type: Date
    - contextPath: IronDome.CommunityComments.alert_id
      description: The alert ID associated with the community comments.
      type: String
    - contextPath: IronDome.CommunityComments.community_comments.created
      description: The time that the comment was created.
      type: Date
    - contextPath: IronDome.CommunityComments.community_comments.comment
      description: The comment text.
      type: String
    - contextPath: IronDome.CommunityComments.community_comments.dome_tags
      description: The IronDome tags related to the comment.
      type: String
    - contextPath: IronDome.CommunityComments.community_comments.enterprise
      description: True if enterprise.
      type: Boolean
    - contextPath: IronDome.CommunityComments.community_comments.self
      description: True if the comment was made by the caller.
      type: Boolean
    - contextPath: IronDome.CognitiveSystemScore.alert_id
      description: The alert ID associated with the cognitive system score.
      type: String
    - contextPath: IronDome.CognitiveSystemScore.cognitive_system_score
      description: The cognitive system score of the alert.
      type: Number
    - contextPath: IronDome.Notification.alert_id
      description: The alert ID associated with the IronDome notification.
      type: String
    - contextPath: IronDome.Notification.dome_notification.id
      description: The unique ID of the notification.
      type: String
    - contextPath: IronDome.Notification.dome_notification.category
      description: The category of Dome notification.
      type: String
    - contextPath: IronDome.Notification.dome_notification.created
      description: The category of Dome notification.
      type: Date
    - contextPath: IronDome.Notification.dome_notification.dome_tags
      description: The IronDome tags related to this notification.
      type: String
    - contextPath: IronDome.Notification.dome_notification.alert_ids
      description: The IDs of the alerts related to this notification.
      type: String
    - contextPath: IronDome.Notification.dome_notification.mismatch_details.enterprise_severities.analyst_severity
      description: The mismatched severity across correlated alerts within the enterprise.
      type: String
    - contextPath: IronDome.Notification.dome_notification.mismatch_details.enterprise_severities.count
      description: The count of mismatched severity with this analyst rating.
      type: Number
    - contextPath: IronDome.Notification.dome_notification.mismatch_details.community_severities.analyst_severity
      description: The mismatched severity across correlated alerts within the community.
      type: String
    - contextPath: IronDome.Notification.dome_notification.mismatch_details.community_severities.count
      description: The count of mismatched severity with this analyst rating.
      type: Number
    - contextPath: IronDome.Notification.dome_notification.severity_details.analyst_severity
      description: The analyst severity of the alert.
      type: String
    - contextPath: IronDome.Notification.dome_notification.comment_details.comment
      description: The comment text in the notification.
      type: String
    - contextPath: IronDome.Notification.dome_notification.severity_suspicious_details.domains
      description: The list of domains correlated on a suspicious alert.
      type: String
    - contextPath: IronDome.Notification.dome_notification.severity_suspicious_details.ips
      description: The list of IPs correlated on a suspicious alert.
      type: String
    - contextPath: IronDome.Notification.dome_notification.severity_suspicious_details.comments
      description: The comments about this suspicious alert correlation.
      type: String
    - contextPath: IronDome.Notification.dome_notification.severity_malicious_details.domains
      description: The list of domains correlated on a malicious alert.
      type: String
    - contextPath: IronDome.Notification.dome_notification.severity_malicious_details.ips
      description: The list of IPs correlated on a malicious alert.
      type: String
    - contextPath: IronDome.Notification.dome_notification.severity_malicious_details.comments
      description: The comments about this malicious alert correlation.
      type: String
    - contextPath: IronDome.Notification.dome_notification.severity_malicious_details.generated_threat_intel_rules.ip
      description: The IP of a Threat Intelligence rule that was automatically created
        based on an IronDome correlation.
      type: String
    - contextPath: IronDome.Notification.dome_notification.severity_malicious_details.generated_threat_intel_rules.domain
      description: The domain of a Threat Intelligence rule that was automatically
        created based on an IronDome correlation.
      type: String
    - contextPath: IronDome.Notification.dome_notification.severity_malicious_details.generated_threat_intel_rules.rule_id
      description: The rule ID of a Threat Intelligence rule that was automatically
        created based on an IronDome correlation.
      type: String
    - contextPath: IronDome.Notification.dome_notification.severity_malicious_details.generated_threat_intel_rules.vue_url
      description: The IronVUE URL of a Threat Intelligence rule that was automatically
        created based on an IronDome correlation.
      type: String
    - contextPath: IronDome.Notification.dome_notification.high_cognitive_system_score_details.enterprise_alert_score
      description: The alert score for the enterprise.
      type: Number
    - contextPath: IronDome.Notification.dome_notification.high_cognitive_system_score_details.cognitive_system_score
      description: The cognitive system score.
      type: Number
  - arguments:
    - description: The ID of the IronDefense alert to retrieve events for.
      name: alert_id
      required: true
    - description: The limit on the number of Events to be returned.
      name: limit
    - description: The number of results to skip - used for paging the results.
      name: offset
    description: Retrieves IronDefense Events for a given Alert ID.
    name: irondefense-get-events-from-alert
    outputs:
    - contextPath: IronDefense.Event.id
      description: The event ID.
      type: String
    - contextPath: IronDefense.Event.alert_id
      description: The associated alert ID.
      type: String
    - contextPath: IronDefense.Event.category
      description: The event category.
      type: String
    - contextPath: IronDefense.Event.sub_category
      description: The event sub category.
      type: String
    - contextPath: IronDefense.Event.severity
      description: The event severity (0-1000).
      type: Number
    - contextPath: IronDefense.Event.confidence
      description: The event confidence (real number between 0-1).
      type: Number
    - contextPath: IronDefense.Event.created
      description: Time the event was created.
      type: Date
    - contextPath: IronDefense.Event.updated
      description: Time the event was last updated.
      type: Date
    - contextPath: IronDefense.Event.start_time
      description: The start time of this event's activity.
      type: Date
    - contextPath: IronDefense.Event.end_time
      description: The end time of this event's activity.
      type: Date
    - contextPath: IronDefense.Event.iron_dome_shared_time
      description: The time when the event was sent to IronDome - not present if not
        shared with irondome.
      type: Date
    - contextPath: IronDefense.Event.is_whitelisted
      description: True if the event activity was whitelisted, false otherwise.
      type: Boolean
    - contextPath: IronDefense.Event.is_blacklisted
      description: True if the event activity was blacklisted, false otherwise.
      type: Boolean
    - contextPath: IronDefense.Event.src_ip
      description: The source IP associated with this event.
      type: String
    - contextPath: IronDefense.Event.dst_ip
      description: The destination IP associated with this event.
      type: String
    - contextPath: IronDefense.Event.dst_port
      description: The destination port associated with this event.
      type: Number
    - contextPath: IronDefense.Event.app_domains
      description: Any domains associated with this event.
      type: String
    - contextPath: IronDefense.Event.primary_app_protocol
      description: The primary application protocol associated with this event.
      type: String
    - contextPath: IronDefense.Event.secondary_app_protocol
      description: The secondary application protocol associated with this event.
      type: String
    - contextPath: IronDefense.Event.bytes_in
      description: The byte count of incoming traffic for this event.
      type: Number
    - contextPath: IronDefense.Event.bytes_out
      description: The byte count of outgoing traffic for this event.
      type: Number
    - contextPath: IronDefense.Event.total_bytes
      description: The byte count of the total traffic (in either direction) for this
        event.
      type: Number
    - contextPath: IronDefense.Event.url
      description: The related URL for this event, if applicable.
      type: String
    - contextPath: IronDefense.Event.raw_data_formats
      description: The list of distinct raw data formats for this event.
      type: String
    - contextPath: IronDefense.Event.src_entity_attribute
      description: The source entity attribute related to this event, if one could
        be determined.
      type: String
    - contextPath: IronDefense.Event.src_entity_attribute_type
      description: The source entity attribute type related to this event, if one
        could be determined.
      type: String
    - contextPath: IronDefense.Event.dst_entity_attribute
      description: The destination entity attribute related to this event, if one
        could be determined.
      type: String
    - contextPath: IronDefense.Event.dst_entity_attribute_type
      description: The destination entity attribute type related to this event, if
        one could be determined.
      type: String
    - contextPath: IronDefense.Event.vue_url
      description: The url for displaying the event within IronVUE.
      type: String
    - contextPath: IronDefense.Query.GetEvents.limit
      description: The maximum number of results that were requested to be returned.
      type: Number
    - contextPath: IronDefense.Query.GetEvents.offset
      description: The number of results that were skipped - used for paging the results.
      type: Number
    - contextPath: IronDefense.Query.GetEvents.total
      description: The total number of results possible from the query.
      type: Number
  dockerimage: demisto/python3:3.11.10.116949
  isfetch: true
  nativeimage:
  - "8.8"
  - "8.6"
  runonce: false
  script: |
    register_module_line('IronDefense', 'start', __line__())
    demisto.debug('pack name = IronNet, pack version = 1.1.32')


    import functools
    from typing import List, Dict
    from http.client import HTTPException

    import urllib3
    # Disable insecure warnings
    urllib3.disable_warnings()


    class XsoarLogger:
        """Wrapper class to add a prefix to all logging statements so they can be located more easily in the logs"""

        def __init__(self, d, log_prefix=''):
            self.demisto = d
            self.log_prefix = log_prefix

        def debug(self, msg):
            demisto.debug(self.log_prefix + msg)

        def error(self, msg):
            demisto.error(self.log_prefix + msg)


    class IronDefense:
        """Main class for performing plugin actions"""

        def __init__(self, demisto, session, host, port, credentials, logger, request_timeout=60.0):
            self.demisto = demisto
            self.session = session
            self.host = host
            self.port = port
            self.base_url = 'https://{}:{}/IronApi'.format(host, port)
            self.credentials = credentials
            self.request_timeout = request_timeout
            self.logger = logger

            self.session.headers.update({'Content-Type': 'application/json'})
            self._configure_session_auth(self.demisto.getIntegrationContext())

        ''' HELPER FUNCTIONS '''

        def _get_jwt(self, context):
            if context is None:
                return None

            try:
                return context.get('JWT')
            except KeyError:
                return None

        def _configure_session_auth(self, data):
            self.logger.debug('Getting jwt...')

            jwt = self._get_jwt(data)
            if jwt:
                # set the auth token if it exists
                self.session.headers.update({'Authorization': 'Bearer ' + jwt})

        def _http_request(self, method, uri, body='{}', headers={}, params={}, auth=None, files=None):
            # Makes an API call with the given arguments
            resp = self.session.request(
                method,
                self.base_url + uri,
                data=body,
                headers=headers,
                verify=False,
                params=params,
                files=files,
                timeout=self.request_timeout,
                auth=auth,
            )
            if resp.status_code == 401:
                if auth is not None:
                    # incorrect creds have been provided
                    return resp

                # the session has expired so we need to log in again
                self.logger.debug('Login required!')

                username = self.credentials.get('identifier')
                password = self.credentials.get('password')

                # retry the original request with basic auth credentials
                return self._http_request(method, uri,
                                          body=body,
                                          params=params,
                                          files=files,
                                          auth=(username, password))
            elif resp.status_code >= 500:
                self.logger.error('A server error has occurred. The response is: ' + json.dumps(resp.json()))

            if auth is not None:
                # persist the jwt
                jwt = resp.headers.get('auth-token')
                self.demisto.setIntegrationContext({
                    'JWT': jwt
                })

            return resp

        def _get_error_msg_from_response(self, resp):
            err_msg = resp.json().get('msg')
            if err_msg is None:
                err_msg = resp.text
            return err_msg

        def event_context_table_to_dict_list(self, event_context_table):
            # convert context from column format to row format for display
            num_rows = functools.reduce(lambda acc, col: len(col.get('values')) if len(col.get('values')) > acc else acc,
                                        event_context_table.get('columns'), 0)
            new_table_data: List[Dict[str, str]] = [{} for row in range(num_rows)]

            for column in event_context_table.get('columns'):
                # add the column to the table
                for row in range(num_rows):
                    # check if the column has the row data
                    if len(column.get('values')) - row > 0:
                        # insert column data
                        val = list(map(lambda d: str(list(d.values())[0]) if len(list(d.values())) > 0 else '',
                                       column.get('values')[row].get('data')))
                        table_row = new_table_data[row]
                        column_name = column.get('name')
                        table_row[column_name] = ','.join(val)
                    else:
                        # This column is missing data so just insert an empty string
                        new_table_data[row][column.get('name')] = ''

            return new_table_data

        def event_context_table_to_dict(self, event_context_table):
            table_data = {}
            for column in event_context_table.get('columns'):
                val = list(map(lambda d: str(list(d.values())[0]) if len(list(d.values())) > 0 else '',
                               column.get('values')[0].get('data')))
                table_data[column.get('name')] = ','.join(val)

            return table_data

        def event_context_table_contains_multi_columns(self, event_context_table):
            for column in event_context_table.get('columns'):
                if len(column.get('values')) > 1:
                    return True
            return False

        def create_markdown_link(self, link_text, url):
            return f'[{link_text}]({url})'

        def create_dome_markdown_link(self, link_text, alert_id):
            url = f'https://{self.host}/alerts/irondome?filter=alertId%3D%3D{alert_id}'
            return f'[{link_text}]({url})'

        '''MAIN FUNCTIONS'''

        def fetch_dome_incidents(self, dome_categories=None, dome_limit=200):
            self.logger.debug('Fetching Dome incidents...')
            res = []
            if dome_categories is not None:
                dome_cats = ['DNC_' + str(cat).replace(" ", "_").upper() for cat in dome_categories]
            else:
                dome_cats = []

            req_body = json.dumps({
                'limit': dome_limit
            })

            resp = self._http_request('POST', '/GetDomeNotifications', body=req_body)
            if resp.ok:
                # Filter notifications
                notifs = resp.json()
                self.logger.debug('json response is: ' + json.dumps(resp.json()))
                for n in notifs['dome_notifications']:
                    if n['category'] not in dome_cats:
                        n['type'] = 'dome'
                        notif = {
                            "name": str(n["category"]) + " IronDome Notification",
                            "details": "Received a {} IronDome Notification at {} from communities {}.".
                            format(n["category"], str(datetime.now()), n["dome_tags"]),
                            "occurred": n["created"],
                            "rawJSON": json.dumps(n)
                        }
                        res.append(notif)
            else:
                raise Exception('Fetch for DomeNotifications failed. Status code was ' + str(resp.status_code))

            self.logger.debug('{} Dome incident(s) fetched'.format(len(res)))
            return res

        def fetch_alert_incidents(self, alert_categories=None, alert_subcategories=None, alert_severity_lower=None,
                                  alert_severity_upper=None, alert_limit=200, alert_actions=None):
            self.logger.debug('Fetching Alert incidents...')
            res = []

            if alert_categories is not None:
                alert_cats = [str(cat).replace(" ", "_").upper() for cat in alert_categories]
            else:
                alert_cats = []

            if alert_subcategories is not None:
                asc = alert_subcategories.split(",")
                alert_subcats = [str(subcat).replace(" ", "_").upper() for subcat in asc]
            else:
                alert_subcats = []

            if alert_actions is None or len(alert_actions) == 0:
                alert_actions_to_ingest = ['ANA_ALERT_CREATED']
            else:
                alert_actions_to_ingest = ['ANA_' + str(alert_action).replace(" ", "_").upper() for alert_action in alert_actions]

            alert_sev_lower = int(alert_severity_lower) if alert_severity_lower is not None else 0
            alert_sev_upper = int(alert_severity_upper) if alert_severity_upper is not None else 1000

            req_body = json.dumps({
                'limit': alert_limit
            })

            resp = self._http_request('POST', '/GetAlertNotifications', body=req_body)
            if resp.ok:
                # Filter notifications
                notifs = resp.json()
                self.logger.debug('json response is: ' + json.dumps(resp.json()))
                for alert_notification in notifs['alert_notifications']:
                    if alert_notification['alert']:
                        alert = alert_notification['alert']
                        action = alert_notification['alert_action']
                        if alert['category'] not in alert_cats and \
                                alert['sub_category'] not in alert_subcats and \
                                alert_sev_lower <= int(alert['severity']) <= alert_sev_upper and \
                                action in alert_actions_to_ingest:
                            alert['type'] = 'alert'
                            notif = {
                                "name": str(alert_notification["alert_action"]) + " Alert Notification",
                                "details": "Received a {} Alert Notification at {}.".
                                format(alert_notification["alert_action"], str(datetime.now())),
                                "occurred": alert["updated"],
                                "rawJSON": json.dumps(alert)
                            }
                            res.append(notif)
            else:
                raise Exception('Fetch for AlertNotifications failed. Status code was ' + str(resp.status_code))

            self.logger.debug('{} Alert incident(s) fetched'.format(len(res)))
            return res

        def fetch_event_incidents(self, event_categories=None, event_subcategories=None, event_severity_lower=None,
                                  event_severity_upper=None, event_limit=200, event_actions=None):
            self.logger.debug('Fetching Event incidents...')
            res = []

            if event_categories is not None:
                event_cats = [str(cat).replace(" ", "_").upper() for cat in event_categories]
            else:
                event_cats = []

            if event_subcategories is not None:
                esc = event_subcategories.split(",")
                event_subcats = [str(subcat).replace(" ", "_").upper() for subcat in esc]
            else:
                event_subcats = []

            if event_actions is None or len(event_actions) == 0:
                event_actions_to_ingest = ['ENA_EVENT_CREATED']
            else:
                event_actions_to_ingest = ['ENA_' + str(event_action).replace(" ", "_").upper() for event_action in event_actions]

            event_sev_lower = int(event_severity_lower) if event_severity_lower is not None else 0
            event_sev_upper = int(event_severity_upper) if event_severity_upper is not None else 1000

            req_body = json.dumps({
                'limit': event_limit
            })

            resp = self._http_request('POST', '/GetEventNotifications', body=req_body)
            if resp.ok:
                # Filter notifications
                notifs = resp.json()
                self.logger.debug('json response is: ' + json.dumps(resp.json()))
                for event_notification in notifs['event_notifications']:
                    if event_notification['event']:
                        event = event_notification['event']
                        action = event_notification['event_action']
                        if event['category'] not in event_cats and \
                                event['sub_category'] not in event_subcats and \
                                event_sev_lower <= int(event['severity']) <= event_sev_upper and \
                                action in event_actions_to_ingest:
                            event['type'] = 'event'
                            notif = {
                                "name": str(event_notification["event_action"]) + " Event Notification",
                                "details": "Received a {} Event Notification at {}.".
                                format(event_notification["event_action"], str(datetime.now())),
                                "occurred": event["updated"],
                                "rawJSON": json.dumps(event)
                            }
                            res.append(notif)
            else:
                raise Exception('Fetch for EventNotifications failed. Status code was ' + str(resp.status_code))

            self.logger.debug('{} Event incident(s) fetched'.format(len(res)))
            return res

        def test_module(self):
            self.logger.debug('Testing module...')
            username = self.credentials.get('identifier')
            password = self.credentials.get('password')
            resp = self._http_request('POST', '/Login', auth=(username, password))
            if resp.status_code == 200:
                self.logger.debug('Success!')
                return 'ok'
            else:
                return 'Test failed ({}): {}'.format(str(resp.status_code), resp.json()['msg'])

        def update_analyst_ratings(self, alert_id, severity='SEVERITY_UNDECIDED', expectation='EXP_UNKNOWN', comments='',
                                   share_irondome=False):
            self.logger.debug('Submitting analyst rating: Alert ID={} Severity={} Expected={} Comments={} Share '
                              'w/IronDome={}'.format(alert_id, severity, expectation, comments, share_irondome))

            req_body = {
                'alert_id': alert_id,
                'analyst_severity': 'SEVERITY_' + severity.upper(),
                'analyst_expectation': 'EXP_' + expectation.upper(),
                'comment': comments,
                'share_comment_with_irondome': share_irondome
            }
            response = self._http_request('POST', '/RateAlert', body=json.dumps(req_body))
            if response.status_code != 200:
                err_msg = self._get_error_msg_from_response(response)
                self.logger.error('Failed to rate alert ({}). The response failed with status code {}. The response was: '
                                  '{}'.format(alert_id, response.status_code, response.text))
                raise HTTPException('Failed to rate alert {} ({}): {}'.format(alert_id, response.status_code, err_msg))
            else:
                self.logger.debug('Successfully submitted rating for alert ({})'.format(alert_id))
                return 'Submitted analyst rating to IronDefense!'

        def add_comment_to_alert(self, alert_id, comment='', share_irondome=False):
            self.logger.debug('Submitting comment: Alert ID={} Comment={} Share '
                              'w/IronDome={}'.format(alert_id, comment, share_irondome))

            req_body = {
                'alert_id': alert_id,
                'comment': comment,
                'share_comment_with_irondome': share_irondome
            }
            response = self._http_request('POST', '/CommentOnAlert', body=json.dumps(req_body))
            if response.status_code != 200:
                err_msg = self._get_error_msg_from_response(response)
                self.logger.error('Failed to add comment to alert ({}). The response failed with status code {}. The '
                                  'response was: {}'.format(alert_id, response.status_code, response.text))
                raise HTTPException('Failed to add comment to alert {} ({}): {}'.format(alert_id, response.status_code,
                                                                                        err_msg))
            else:
                self.logger.debug('Successfully added comment to alert ({})'.format(alert_id))
                return 'Submitted comment to IronDefense!'

        def set_alert_status(self, alert_id, status='STATUS_NONE', comments='', share_irondome=False):
            self.logger.debug('Submitting status: Alert ID={} Status={} Comments={} Share '
                              'w/IronDome={}'.format(alert_id, status, comments, share_irondome))

            req_body = {
                'alert_id': alert_id,
                'status': 'STATUS_' + status.upper().replace(" ", "_"),
                'comment': comments,
                'share_comment_with_irondome': share_irondome
            }
            response = self._http_request('POST', '/SetAlertStatus', body=json.dumps(req_body))
            if response.status_code != 200:
                err_msg = self._get_error_msg_from_response(response)
                self.logger.error('Failed to set status for alert ({}). The response failed with status code {}. The '
                                  'response was: {}'.format(alert_id, response.status_code, response.text))
                raise HTTPException('Failed to set status for alert {} ({}): {}'.format(alert_id, response.status_code,
                                                                                        err_msg))
            else:
                self.logger.debug('Successfully submitted status for alert ({})'.format(alert_id))
                return 'Submitted status to IronDefense!'

        def report_observed_bad_activity(self, name, description='', ip='', domain='',
                                         activity_start_time='1970-01-01T00:00:00Z',
                                         activity_end_time='1970-01-01T00:00:00Z'):
            self.logger.debug('Submitting observed bad activity: Name={} Description={} IP={} Domain={} '
                              'Activity Start Time={} Activity End Time={}'.format(name, description, ip, domain,
                                                                                   activity_start_time, activity_end_time))

            req_body = {
                'name': name,
                'description': description,
                'ip': ip,
                'domain': domain,
                'activity_start_time': activity_start_time,
                'activity_end_time': activity_end_time
            }
            response = self._http_request('POST', '/ReportObservedBadActivity', body=json.dumps(req_body))
            if response.ok:
                self.logger.debug('Successfully submitted observed bad activity for IP={} and Domain={}'.format(ip, domain))
                return 'Submitted observed bad activity to IronDefense!'
            else:
                err_msg = self._get_error_msg_from_response(response)
                self.logger.error('Failed to submit observed bad activity for IP={} and Domain={}. The response failed with'
                                  ' status code {}. The response was: {}'
                                  .format(ip, domain, response.status_code, response.text))
                raise HTTPException('Failed to submit observed bad activity for IP={} and Domain={} ({}): {}'
                                    .format(ip, domain, response.status_code, err_msg))

        def get_event(self, event_id):
            self.logger.debug('Retrieving Event: Event ID={}'.format(event_id))

            req_body = {
                'event_id': event_id,
            }
            response = self._http_request('POST', '/GetEvent', body=json.dumps(req_body))
            if response.status_code != 200:
                err_msg = self._get_error_msg_from_response(response)
                self.logger.error('Failed to retrieve event with ID ({}). The response failed with status code {}. The '
                                  'response was: {}'.format(event_id, response.status_code, response.text))
                raise HTTPException('Failed to retrieve event with ID {} ({}): {}'.format(event_id, response.status_code,
                                                                                          err_msg))
            else:
                self.logger.debug('Successfully retrieved event ({})'.format(event_id))
                return response.json()

        def get_events(self, alert_id, limit=None, offset=None):
            self.logger.debug('Retrieving Events: Alert ID={}, Limit={} Offset={}'.format(alert_id, limit, offset))

            req_body = {
                'alert_id': alert_id
            }

            constraint = {}
            if limit is not None and limit != "":
                constraint['limit'] = int(limit)
            if offset is not None and offset != "":
                constraint['offset'] = int(offset)
            req_body['constraint'] = constraint

            response = self._http_request('POST', '/GetEvents', body=json.dumps(req_body))
            if response.status_code != 200:
                err_msg = self._get_error_msg_from_response(response)
                self.logger.error('Failed to retrieve events with alert ID ({}). The response failed with status code {}. '
                                  'The response was: {}'.format(alert_id, response.status_code, response.text))
                raise HTTPException('Failed to retrieve event with ID {} ({}): {}'.format(alert_id, response.status_code,
                                                                                          err_msg))
            else:
                self.logger.debug('Successfully retrieved events for alert ({})'.format(alert_id))
                events = response.json()
                return events

        def get_alerts(self, alert_id=None, category=None, sub_category=None, status=None, analyst_severity=None,
                       analyst_expectation=None, min_severity=None, max_severity=None, min_created=None, max_created=None,
                       min_updated=None,
                       max_updated=None, min_first_event_created=None, max_first_event_created=None,
                       min_last_event_created=None, max_last_event_created=None, min_first_event_start_time=None,
                       max_first_event_start_time=None, min_last_event_end_time=None, max_last_event_end_time=None,
                       analytic_version=None,
                       limit=None, offset=None, sort=None):
            self.logger.debug('Getting alerts: AlertID={} Category={} SubCategory={} Status={} AnalystSeverity={} '
                              'AnalystExpectation={} MinSeverity={} MaxSeverity={} MinCreated={} MaxCreated= {} MinUpdated={}'
                              'MaxUpdated={} MinFirstEventCreated={} MaxFirstEventCreated={} MinLastEventCreated={}'
                              'MaxLastEventCreated={} MinFirstEventStartTime={} MaxFirstEventStartTime={} MinLastEventEndTime={}'
                              'MaxLastEventEndTime={} AnalyticVersion={} '
                              'Limit={} Offset={} sort={}'.format(alert_id, category, sub_category, status,
                                                                  analyst_severity,
                                                                  analyst_expectation, min_severity, max_severity,
                                                                  min_created,
                                                                  max_created, min_updated, max_updated,
                                                                  min_first_event_created, max_first_event_created,
                                                                  min_last_event_created, max_last_event_created,
                                                                  min_first_event_start_time, max_first_event_start_time,
                                                                  min_last_event_end_time, max_last_event_end_time,
                                                                  analytic_version,
                                                                  limit, offset, sort))

            req_body = {}
            if alert_id:
                req_body['alert_id'] = alert_id.split(",")
            if category:
                req_body['category'] = [str(cat).replace(" ", "_").upper() for cat in category.split(",")]
            if sub_category:
                req_body['sub_category'] = [str(sub_cat).replace(" ", "_").upper() for sub_cat in sub_category.split(",")]
            if status:
                req_body['status'] = ["STATUS_" + str(stat).replace(" ", "_").upper() for stat in status.split(",")]
            if analyst_severity:
                req_body['analyst_severity'] = ["SEVERITY_" + str(aseverity).replace(" ", "_").upper() for
                                                aseverity in analyst_severity.split(",")]
            if analyst_expectation:
                req_body['analyst_expectation'] = ["EXP_" + str(aexpectation).replace(" ", "_").upper() for
                                                   aexpectation in analyst_expectation.split(",")]
            if analytic_version:
                req_body['analytic_version'] = analytic_version.split(",")
            if sort:
                req_body['sort'] = sort
            if min_severity is not None and min_severity != "" and max_severity is not None and max_severity != "":
                req_body['severity'] = {
                    "lower_bound": int(min_severity),
                    "upper_bound": int(max_severity)
                }
            if min_created and max_created:
                req_body['created'] = {
                    "start": min_created,
                    "end": max_created
                }
            if min_updated and max_updated:
                req_body['updated'] = {
                    "start": min_updated,
                    "end": max_updated
                }
            if min_first_event_created and max_first_event_created:
                req_body['first_event_created'] = {
                    "start": min_first_event_created,
                    "end": max_first_event_created
                }
            if min_last_event_created and max_last_event_created:
                req_body['last_event_created'] = {
                    "start": min_last_event_created,
                    "end": max_last_event_created
                }
            if min_first_event_start_time and max_first_event_start_time:
                req_body['first_event_start_time'] = {
                    "start": min_first_event_start_time,
                    "end": max_first_event_start_time
                }
            if min_last_event_end_time and max_last_event_end_time:
                req_body['last_event_end_time'] = {
                    "start": min_last_event_end_time,
                    "end": max_last_event_end_time
                }
            constraint = {}
            if limit is not None and limit != "":
                constraint['limit'] = int(limit)
            if offset is not None and offset != "":
                constraint['offset'] = int(offset)
            req_body['constraint'] = constraint

            response = self._http_request('POST', '/GetAlerts', body=json.dumps(req_body))
            if response.ok:
                self.logger.debug('Successfully retrieved alerts')
                return response.json()
            else:
                err_msg = self._get_error_msg_from_response(response)
                self.logger.error('Failed to retrieve alerts. The response failed with status code {}. The response was: {}'
                                  .format(response.status_code, err_msg))
                raise HTTPException('Failed to retrieve alerts ({}): {}'
                                    .format(response.status_code, err_msg))

        def get_alert_irondome_information(self, alert_id):
            self.logger.debug('Retrieving Alert IronDome Information: Alert ID={}'.format(alert_id))

            req_body = {
                'alert_id': alert_id,
            }
            response = self._http_request('POST', '/GetAlertIronDomeInformation', body=json.dumps(req_body))
            if response.status_code != 200:
                err_msg = self._get_error_msg_from_response(response)
                self.logger.error('Failed to retrieve IronDome information for alert with ID ({}). The response failed '
                                  'with status code {}. The response was: {}'.format(alert_id, response.status_code,
                                                                                     response.text))
                raise HTTPException('Failed to retrieve IronDome information for alert with ID {} ({}): {}'
                                    .format(alert_id, response.status_code, err_msg))
            else:
                self.logger.debug('Successfully retrieved IronDome information for alert ({})'.format(alert_id))
                dome_alert_info = response.json()
                return dome_alert_info


    ''' COMMANDS MANAGER / SWITCH PANEL '''


    def fetch_incidents_command():
        # IronDome Notification related params
        dome_categories = PARAMS.get('domeCategories', None)  # pylint: disable=E0601
        dome_limit = int(PARAMS.get('domeLimit', 200))
        disable_dome_notifs = not PARAMS.get('enableDomeNotifications', False)
        # Alert Notification related params
        alert_categories = PARAMS.get('alertCategories', None)
        alert_subcategories = PARAMS.get('alertSubCategories', None)
        alert_severity_lower = PARAMS.get('alertSeverityLower', None)
        alert_severity_upper = PARAMS.get('alertSeverityUpper', None)
        alert_limit = int(PARAMS.get('alertLimit', 200))
        alert_actions = PARAMS.get('alertActions', None)
        disable_alert_notifs = not PARAMS.get('enableAlertNotifications', True)
        # Event Notification related params
        event_categories = PARAMS.get('eventCategories', None)
        event_subcategories = PARAMS.get('eventSubCategories', None)
        event_severity_lower = PARAMS.get('eventSeverityLower', None)
        event_severity_upper = PARAMS.get('eventSeverityUpper', None)
        event_limit = int(PARAMS.get('eventLimit', 200))
        event_actions = PARAMS.get('eventActions', None)
        disable_event_notifs = not PARAMS.get('enableEventNotifications', False)

        incidents: list = []
        if disable_dome_notifs and disable_alert_notifs and disable_event_notifs:
            LOGGER.debug("Ingestion of all notifications (Dome, Alert, Event) is disabled, not fetching")  # pylint: disable=E0601
        else:
            if disable_dome_notifs:
                LOGGER.debug('Ingestion of Dome Notifications is disabled')
            else:
                incs = IRON_DEFENSE.fetch_dome_incidents(dome_categories, dome_limit)  # pylint: disable=E0601
                incidents.extend(incs)
                # If the limit was reached, poll again
                poll_count = 1
                while len(incs) == dome_limit and poll_count < 10:
                    incs = IRON_DEFENSE.fetch_dome_incidents(dome_categories, dome_limit)
                    incidents.extend(incs)
                    poll_count += 1

            if disable_alert_notifs:
                LOGGER.debug('Ingestion of Alert Notifications is disabled')
            else:
                incs = IRON_DEFENSE.fetch_alert_incidents(alert_categories, alert_subcategories, alert_severity_lower,
                                                          alert_severity_upper, alert_limit, alert_actions)
                incidents.extend(incs)
                # If the limit was reached, poll again
                poll_count = 1
                while len(incs) == alert_limit and poll_count < 10:
                    incs = IRON_DEFENSE.fetch_alert_incidents(alert_categories, alert_subcategories, alert_severity_lower,
                                                              alert_severity_upper, alert_limit, alert_actions)
                    incidents.extend(incs)
                    poll_count += 1

            if disable_event_notifs:
                LOGGER.debug('Ingestion of Event Notifications is disabled')
            else:
                incs = IRON_DEFENSE.fetch_event_incidents(event_categories, event_subcategories, event_severity_lower,
                                                          event_severity_upper, event_limit, event_actions)
                incidents.extend(incs)
                # If the limit was reached, poll again
                poll_count = 1
                while len(incs) == event_limit and poll_count < 10:
                    incs = IRON_DEFENSE.fetch_event_incidents(event_categories, event_subcategories, event_severity_lower,
                                                              event_severity_upper, event_limit, event_actions)
                    incidents.extend(incs)
                    poll_count += 1

        demisto.incidents(incidents)


    def test_module_command():
        results = IRON_DEFENSE.test_module()
        demisto.results(results)


    def update_analyst_ratings_command():
        alert_id = demisto.getArg('alert_id')
        severity = demisto.getArg('severity')
        expectation = demisto.getArg('expectation')
        comments = demisto.getArg('comments')
        share_irondome_arg = demisto.getArg('share_comment_with_irondome')
        share_irondome = True if share_irondome_arg.lower() == 'true' else False
        results = IRON_DEFENSE.update_analyst_ratings(alert_id, severity=severity, expectation=expectation,
                                                      comments=comments,
                                                      share_irondome=share_irondome)
        demisto.results(results)


    def add_comment_to_alert_command():
        alert_id = demisto.getArg('alert_id')
        comment = demisto.getArg('comment')
        share_irondome_arg = demisto.getArg('share_comment_with_irondome')
        share_irondome = True if share_irondome_arg.lower() == 'true' else False
        results = IRON_DEFENSE.add_comment_to_alert(alert_id, comment=comment, share_irondome=share_irondome)
        demisto.results(results)


    def set_alert_status_command():
        alert_id = demisto.getArg('alert_id')
        status = demisto.getArg('status')
        comments = demisto.getArg('comments')
        share_irondome_arg = demisto.getArg('share_comment_with_irondome')
        share_irondome = True if share_irondome_arg.lower() == 'true' else False
        results = IRON_DEFENSE.set_alert_status(alert_id, status=status, comments=comments,
                                                share_irondome=share_irondome)
        demisto.results(results)


    def report_observed_bad_activity_command():
        name = demisto.getArg('name')
        description = demisto.getArg('description')
        ip = demisto.getArg('ip')
        domain = demisto.getArg('domain')
        activity_start_time = demisto.getArg('activity_start_time')
        activity_end_time = demisto.getArg('activity_end_time')
        results = IRON_DEFENSE.report_observed_bad_activity(name, description=description, ip=ip, domain=domain,
                                                            activity_start_time=activity_start_time,
                                                            activity_end_time=activity_end_time)
        demisto.results(results)


    def get_event_command():
        # get event data from IronAPI
        event_id = demisto.getArg('event_id')
        results = IRON_DEFENSE.get_event(event_id)

        # Output the event data
        event = results.get('event')
        vue_markdown_link = IRON_DEFENSE.create_markdown_link("Open in IronVue", event.get("vue_url"))
        event_readable_output = tableToMarkdown(f'IronDefense Event: {event.get("category")} -'
                                                f' {event.get("sub_category")}\n'
                                                f'{vue_markdown_link}', event)

        return_outputs(readable_output=event_readable_output,
                       outputs={
                           'IronDefense.Event(val.id == obj.id)': event,
                       },
                       raw_response=event)

        # Output each context table
        context_tables = results.get('context')
        for table in context_tables:
            if IRON_DEFENSE.event_context_table_contains_multi_columns(table):
                output_table = IRON_DEFENSE.event_context_table_to_dict_list(table)
                headers = [*output_table[0]]
            else:
                output_table = IRON_DEFENSE.event_context_table_to_dict(table)
                headers = []

            return_outputs(readable_output=tableToMarkdown(f'Event Context: {table.get("name")}', output_table,
                                                           headers=headers),
                           outputs={
                           'IronDefense.Event.Context(val.name == obj.name)': table,
                           },
                           raw_response=table)


    def get_events_command():
        alert_id = demisto.getArg('alert_id')
        limit = demisto.getArg('limit')
        offset = demisto.getArg('offset')

        results = IRON_DEFENSE.get_events(alert_id=alert_id, limit=limit, offset=offset)
        events = results.get('events')
        total_count = results.get('constraint').get('total')
        offset = results.get('constraint').get('offset')
        for i, event in enumerate(events):
            vue_markdown_link = IRON_DEFENSE.create_markdown_link("Open in IronVue", event.get("vue_url"))
            event_readable_output = tableToMarkdown(f'IronDefense Event {i + offset + 1}/{total_count}\n'
                                                    f'{vue_markdown_link}', event)
            # Send each event
            return_outputs(readable_output=event_readable_output,
                           outputs={
                               'IronDefense.Event(val.id == obj.id)': event,
                           },
                           raw_response=event)

        # Send constraints
        constraint = results.get('constraint')
        return_outputs(readable_output=tableToMarkdown('Query Constraints', constraint),
                       outputs={
                       'IronDefense.Query.GetEvents': constraint,
                       },
                       raw_response=constraint)


    def get_alerts_command():
        alert_id = demisto.getArg('alert_id')
        category = demisto.getArg('category')
        sub_category = demisto.getArg('sub_category')
        status = demisto.getArg('status')
        analyst_severity = demisto.getArg('analyst_severity')
        analyst_expectation = demisto.getArg('analyst_expectation')
        min_severity = demisto.getArg('min_severity')
        max_severity = demisto.getArg('max_severity')
        min_created = demisto.getArg('min_created')
        max_created = demisto.getArg('max_created')
        min_updated = demisto.getArg('min_updated')
        max_updated = demisto.getArg('max_updated')
        min_first_event_created = demisto.getArg('min_first_event_created')
        max_first_event_created = demisto.getArg('max_first_event_created')
        min_last_event_created = demisto.getArg('min_last_event_created')
        max_last_event_created = demisto.getArg('max_last_event_created')
        min_first_event_start_time = demisto.getArg('min_first_event_start_time')
        max_first_event_start_time = demisto.getArg('max_first_event_start_time')
        min_last_event_end_time = demisto.getArg('min_last_event_end_time')
        max_last_event_end_time = demisto.getArg('max_last_event_end_time')
        analytic_version = demisto.getArg('analytic_version')
        limit = demisto.getArg('limit')
        offset = demisto.getArg('offset')
        sort = demisto.getArg('sort')
        results = IRON_DEFENSE.get_alerts(alert_id=alert_id, category=category, sub_category=sub_category, status=status,
                                          analyst_severity=analyst_severity,
                                          analyst_expectation=analyst_expectation, min_severity=min_severity,
                                          max_severity=max_severity, min_created=min_created, max_created=max_created,
                                          min_updated=min_updated, max_updated=max_updated,
                                          min_first_event_created=min_first_event_created,
                                          max_first_event_created=max_first_event_created,
                                          min_last_event_created=min_last_event_created,
                                          max_last_event_created=max_last_event_created,
                                          min_first_event_start_time=min_first_event_start_time,
                                          max_first_event_start_time=max_first_event_start_time,
                                          min_last_event_end_time=min_last_event_end_time,
                                          max_last_event_end_time=max_last_event_end_time,
                                          analytic_version=analytic_version,
                                          limit=limit, offset=offset, sort=sort)
        alerts = results.get('alerts')
        total_count = results.get('constraint').get('total')
        offset = results.get('constraint').get('offset')
        for i, alert in enumerate(alerts):
            # Send each alert
            vue_markdown_link = IRON_DEFENSE.create_markdown_link("Open in IronVue", alert.get("vue_url"))
            alert_readable_output = tableToMarkdown(f'IronDefense Alert {i + offset + 1}/{total_count}: {alert.get("category")} -'
                                                    f' {alert.get("sub_category")}\n'
                                                    f'{vue_markdown_link}', alert)
            return_outputs(readable_output=alert_readable_output,
                           outputs={
                               'IronDefense.Alert(val.id == obj.id)': alert,
                           },
                           raw_response=alert)

        # Send constraints
        constraint = results.get('constraint')
        return_outputs(readable_output=tableToMarkdown('Query Constraints', constraint),
                       outputs={
                       'IronDefense.Query.GetAlerts': constraint,
                       },
                       raw_response=constraint)


    def get_alert_irondome_information_command():
        alert_id = demisto.getArg('alert_id')
        results = IRON_DEFENSE.get_alert_irondome_information(alert_id)

        if len(results.get('correlations')) == 0 and \
                len(results.get('correlation_participation')) == 0 and \
                len(results.get('community_comments')) == 0 and \
                len(results.get('dome_notifications')) == 0:
            demisto.results(f'No correlations found for alert ID: {alert_id}')
            return

        # Output correlations
        correlations = results.get('correlations')
        for correlation in correlations:
            dome_tag = correlation.get('dome_tag')
            correlation_data = correlation.get('correlations')
            output = {
                'alert_id': alert_id,
                'correlation': correlation
            }
            ip_correlations = list(filter(lambda corr: corr.get('ip') is not None, correlation_data))
            domain_correlations = list(filter(lambda corr: corr.get('domain') is not None, correlation_data))
            behavior_correlations = list(filter(lambda corr: corr.get('behavior') is not None, correlation_data))

            if len(ip_correlations) != 0:
                return_outputs(readable_output=tableToMarkdown(f'IronDome IP Correlations in "{dome_tag}"', ip_correlations,
                                                               headers=[*ip_correlations[0]]),
                               outputs={
                               'IronDome.Correlations(val.alert_id = obj.alert.id)': output
                               },
                               raw_response=correlation)

            if len(domain_correlations) != 0:
                return_outputs(readable_output=tableToMarkdown(f'IronDome Domain Correlations in "{dome_tag}"',
                                                               domain_correlations,
                                                               headers=[*domain_correlations[0]]),
                               outputs={
                               'IronDome.Correlations(val.alert_id = obj.alert.id)': output
                               },
                               raw_response=correlation)

            if len(behavior_correlations) != 0:
                return_outputs(readable_output=tableToMarkdown(f'IronDome Behavior Correlations in "{dome_tag}"',
                                                               behavior_correlations,
                                                               headers=[*behavior_correlations[0]]),
                               outputs={
                               'IronDome.Correlations(val.alert_id = obj.alert.id)': output
                               },
                               raw_response=correlation)

        # Output correlation participation
        correlation_participation = results.get('correlation_participation')
        for participant in correlation_participation:
            dome_tag = participant.get('dome_tag')
            output = {
                'alert_id': alert_id,
                'correlation_participation': participant
            }

            table_data = []

            # append each correlation context to display in the table, if it exists
            behavior = participant.get('behavior')
            if behavior is not None:
                table_data.append(behavior)
            domain = participant.get('behavior')
            if domain is not None:
                table_data.append(domain)
            ip = participant.get('ip')
            if ip is not None:
                table_data.append(ip)

            # Send the participant info
            return_outputs(readable_output=tableToMarkdown(f'IronDome Correlation Participation in "{dome_tag}"',
                                                           table_data,
                                                           headers=[*table_data[0]]),
                           outputs={
                           'IronDome.CorrelationParticipation(val.alert_id = obj.alert.id)': output
                           },
                           raw_response=participant)

        # Output comments
        community_comments = results.get('community_comments')
        community_comments_output = {
            'alert_id': alert_id,
            'community_comments': community_comments,
        }
        if len(community_comments) > 0:
            return_outputs(readable_output=tableToMarkdown('IronDome Community Comments', community_comments,
                                                           headers=[*community_comments[0]]),
                           outputs={
                           'IronDome.CommunityComments(val.alert_id = obj.alert.id)': community_comments_output
                           },
                           raw_response=community_comments)

        # Output cognitive system score
        cognitive_system_score = results.get('cognitive_system_score')
        cognitive_system_score_output = {
            'alert_id': alert_id,
            'cognitive_system_score': cognitive_system_score,
        }
        return_outputs(readable_output=f'### Cognitive System Score: {cognitive_system_score}',
                       outputs={
                           'IronDome.CognitiveSystemScore(val.alert_id = obj.alert.id)': cognitive_system_score_output
                       },
                       raw_response=cognitive_system_score)

        # Output dome notifications
        dome_notifications = results.get('dome_notifications')
        for notification in dome_notifications:
            category = notification.get('category')
            output = {
                'alert_id': alert_id,
                'dome_notification': notification
            }
            return_outputs(readable_output=tableToMarkdown(f'IronDome Notification: {category}', notification),
                           outputs={
                           'IronDome.Notification(val.alert_id = obj.alert.id)': output
                           },
                           raw_response=notification)

        return_outputs(readable_output=IRON_DEFENSE.create_dome_markdown_link('Open IronDome information in IronVue',
                                                                              alert_id),
                       outputs={})


    COMMANDS = {
        'test-module': test_module_command,
        'fetch-incidents': fetch_incidents_command,
        'irondefense-rate-alert': update_analyst_ratings_command,
        'irondefense-comment-alert': add_comment_to_alert_command,
        'irondefense-set-alert-status': set_alert_status_command,
        'irondefense-report-observed-bad-activity': report_observed_bad_activity_command,
        'irondefense-get-event': get_event_command,
        'irondefense-get-events-from-alert': get_events_command,
        'irondefense-get-alerts': get_alerts_command,
        'irondefense-get-alert-irondome-information': get_alert_irondome_information_command,
    }
    COOKIE_KEY = 'user_sid'
    LOG_PREFIX = 'IronDefense Integration: '

    '''EXECUTION'''

    if __name__ == 'builtins':
        try:
            # Globals
            PARAMS = demisto.params()
            CREDENTIALS = PARAMS.get('credentials')
            HOST = PARAMS.get('ironAPIHost', 'localhost')
            PORT = PARAMS.get('ironAPIPort', 443)
            REQUEST_TIMEOUT = float(PARAMS.get('requestTimeout', 60))
            LOGGER = XsoarLogger(demisto, LOG_PREFIX)

            # initialize the IronDefense object
            IRON_DEFENSE = IronDefense(demisto, requests.Session(), HOST, PORT, CREDENTIALS, LOGGER,
                                       request_timeout=REQUEST_TIMEOUT)

            LOGGER.debug('Invoking integration with Command: ' + demisto.command())
            if demisto.command() in COMMANDS.keys():
                COMMANDS[demisto.command()]()
            else:
                return_error('Command not found: ' + demisto.command())

        except Exception as e:
            demisto.error(traceback.format_exc())
            return_error(str(e))

    register_module_line('IronDefense', 'end', __line__())
  subtype: python3
  type: python
system: true
