category: Network Security
commonfields:
  id: PANW IoT 3rd Party Integration - BlueCat IPAM
  version: -1
configuration:
- defaultvalue: https://192.168.0.1
  display: Server URL (e.g., https://192.168.0.1)
  name: url
  required: true
  type: 0
- display: Username
  name: credentials
  required: true
  type: 9
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: BlueCat IPAM enables you to receive metadata about subnet networks and
  its network containers(blocks)
detaileddescription: "**This integration supports BlueCat Address Manager version
  9.1 and above, Other versions might fail to run.**\n\nWhen you configure an instance
  of the Bluecat IPAM integration in Cortex XSOAR, you need to provide an API user
  account.\n\n## Generate an API user account\n\n1. Using the Address Manager web
  interface, log in to Address Manager as an administrator.\n2. On the Administration
  page, click **Users and Groups**.\n3. In the **Users** section, click **New**.\n4.
  Enter a name in the **Username** field.\n5. In the **Authentication** section, type
  and confirm the API user password in the **Password and ConfirmPassword** fields.
  \n6. Under Extra Information, enter and email address (required) and a phone number
  (optional) for the API user.\n7. In the **User Access** section, define the access
  type, rest fields can have default values.\n    - Access Type: select the type of
  access as **API**\n    - (Optional) Or If you wish to access GUI using this User,
  then please select ** GUI and API **\n8. Click **Add**."
display: PANW IoT 3rd Party Integration - BlueCat IPAM
image: data:image/png;base64,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
name: PANW IoT 3rd Party Integration - BlueCat IPAM
script:
  commands:
  - arguments:
    - defaultValue: "100"
      description: The maximum number of objects to return.
      name: count
    - defaultValue: "0"
      description: Indicates where in the list of returned objects to start returning
        objects
      name: start
    name: bluecat-get-ipv4-object
  dockerimage: demisto/panw-iot:1.0.0.79918
  runonce: false
  script: |
    register_module_line('PANW IoT 3rd Party Integration - BlueCat IPAM', 'start', __line__())


    import re
    import ipaddress
    import requests
    import urllib3

    # Disable insecure warnings
    urllib3.disable_warnings()
    TOKEN_LIFE_TIME_MINUTES = 5


    class BlueCatIpamAPIParser:
        def __init__(self):
            self._base_url = self.remove_trailing_slash()
            self.username = demisto.params().get('credentials', {}).get('identifier')
            self.password = demisto.params().get('credentials', {}).get('password')
            self._use_ssl = not demisto.params().get('insecure', False)
            self._headers = {
                'Content-Type': 'application/json',
                'Accept': 'application/json'
            }

        def remove_trailing_slash(self):
            # Remove trailing slash to prevent wrong URL path to service
            url = demisto.params().get('url')
            server = url[:-1] if (url and url.endswith('/')) else url
            base_url = f'{server}/Services/REST/v1'
            return base_url

        def get_token_request(self):
            """
                 Retrieves the token from the server
            """
            url_args = {
                'username': self.username,
                'password': self.password
            }
            start_idx = 16
            end_delim = ' <-'
            url = f'{self._base_url}/login'
            res = requests.request('GET', url, verify=self._use_ssl, params=url_args)
            if res.status_code != 200:
                raise Exception('Error: Failed to create a new token, please check your credentials')
            res_json = res.json()
            end_idx = res_json.index(end_delim)
            return res_json[start_idx:end_idx]

        def get_token(self, new_token=False):
            """
                Retrieves the token from the server if it's expired and updates the global HEADERS to include it

                :param new_token: If set to True will generate a new token regardless of time passed

                :rtype: ``str``
                :return: Token
            """
            now = datetime.now()
            ctx = demisto.getIntegrationContext()
            auth_token = ''
            try:
                if ctx and not new_token:
                    passed_minutes = self.get_passed_minutes(now, datetime.fromtimestamp(ctx.get('time')))
                    if passed_minutes >= TOKEN_LIFE_TIME_MINUTES:
                        # token expired
                        auth_token = self.get_token_request()
                        demisto.setIntegrationContext({'auth_token': auth_token, 'time': date_to_timestamp(now) / 1000})
                    else:
                        # token hasn't expired
                        auth_token = ctx.get('auth_token')
                else:
                    # generating new token
                    auth_token = self.get_token_request()
                    demisto.setIntegrationContext({'auth_token': auth_token, 'time': date_to_timestamp(now) / 1000})
            except Exception as ex:
                demisto.error(f'Exception while getting token: {str(ex)}')
            return auth_token

        def http_request(self, method, url_suffix, params=None, data=None, safe=False):
            """
                A wrapper for requests lib to send our requests and handle requests and responses better.

                :type method: ``str``
                :param method: HTTP method for the request.

                :type url_suffix: ``str``
                :param url_suffix: The suffix of the URL (endpoint)

                :type params: ``dict``
                :param params: The URL params to be passed.

                :type data: ``str``
                :param data: The body data of the request.

                :type headers: ``dict``
                :param headers: Request headers

                :type safe: ``bool``
                :param safe: If set to true will return None in case of http error

                :return: Returns the http request response json
                :rtype: ``dict``
            """
            self._headers['Authorization'] = self.get_token()
            url = f'{self._base_url}{url_suffix}'
            try:
                res = requests.request(method, url, verify=self._use_ssl, params=params, data=data, headers=self._headers)
                # Try to create a new token
                if res.status_code == 401:
                    self._headers['Authorization'] = self.get_token(new_token=True)
                    res = requests.request(method, url, verify=self._use_ssl, params=params, data=data, headers=self._headers)
            except requests.exceptions.RequestException:
                raise Exception('Error in connection to the server. Please make sure you entered the URL correctly.')
            # Handle error responses gracefully
            if res.status_code not in {200, 201, 202}:
                result_msg = None
                try:
                    result_msg = res.json()
                except Exception as ex:
                    err_msg = f'Error in API call. code:{res.status_code}; reason: {reason}'
                    raise Exception(err_msg)
                finally:
                    reason = result_msg if result_msg else res.reason
            return res.json()

        def valid_cidr(self, cidr_string):
            try:
                if '/' in cidr_string and ipaddress.IPv4Network(cidr_string):
                    return True
            except:
                return False

        def valid_gateway(self, ip):
            try:
                ipaddress.IPv4Address(ip)
                return True
            except:
                return False

        def extract_gateway(self, properties_string):
            gateway_string = None
            gateway_match_regex = re.match("^.*gateway=(.*?)(\||$)", properties_string)
            if gateway_match_regex and self.valid_gateway(gateway_match_regex.group(1)):
                gateway_string = gateway_match_regex.group(1)
            return gateway_string

        def extract_cidr(self, properties_string):
            cidr_string = None
            cidr_match_regex = re.match("^.*CIDR=(.*?)(\||$)", properties_string)
            if cidr_match_regex and self.valid_cidr(cidr_match_regex.group(1)):
                cidr_string = cidr_match_regex.group(1)
            return cidr_string


        def get_IP4Block(self, data):
            block_data = {}
            try:
                properties = data.get('properties', '')
                if properties:
                    prefix  = self.extract_cidr(properties)
                    name = data.get('name', '')
                    if prefix:
                        if name:
                            block_data['name'] = name
                        else:
                            block_data['name'] = ''
                        block_data['type'] = 'block'
                        block_data['prefix'] = prefix
            except Exception as ex:
                demisto.error(f'Exception when getting IPv4 Block: {str(ex)}')
            return block_data

        def get_IP4Network(self, data):
            network_data = {}
            try:
                properties = data.get('properties', '')
                if properties:
                    prefix = self.extract_cidr(properties)
                    gateway = self.extract_gateway(properties)
                    name = data.get('name', '')
                    if prefix:
                        if name:
                            network_data['name'] = name
                        else:
                            network_data['name'] = ''
                        network_data['type'] = 'subnet'
                        network_data['prefix'] = prefix
                        if gateway:
                            network_data['gateway'] = gateway
            except Exception as ex:
                demisto.error(f'Exception when getting IPv4 Network: {str(ex)}')
            return network_data

        def get_IPv4Objects(self):
            """
            Get list of all the IPv4 Objects.

            """
            res = ''
            ipv4Object = []
            count = demisto.args()['count']
            start = demisto.args()['start']
            try:
                params = {
                    'count': count,
                    'start': start,
                    'keyword': '*',
                    'types': "IP4Block,IP4Network"
                }
                response = self.http_request('GET', '/searchByObjectTypes', params)
                for data in response:
                    object_type = data.get('type', '')
                    if len(object_type) != 0 and object_type == 'IP4Block':
                        _data = self.get_IP4Block(data)
                        if _data:
                            ipv4Object.append(_data)
                    elif len(object_type) != 0 and object_type == 'IP4Network':
                        _data = self.get_IP4Network(data)
                        if _data:
                            ipv4Object.append(_data)
                if not response:
                    raise Exception('No IPv4 Objects could be fetched from the system')
            except Exception as ex:
                demisto.error('Error while getting IPv4 Objects'+ str(ex))
            return ipv4Object

        def get_passed_minutes(self, start_time, end_time):
            """
                Returns the time passed in minutes
                :param start_time: Start time in datetime
                :param end_time: End time in datetime
                :return: The passed minutes in int
            """
            time_delta = start_time - end_time
            return time_delta.seconds / 60


    def main() -> None:
        """
            main function, parses params and runs command functions
        """
        demisto.debug(f'Command being called is {demisto.command()}')
        try:
            if demisto.command() == 'test-module':
                api_parser = BlueCatIpamAPIParser()
                res = api_parser.get_token()
                if res:
                    return_results('ok')
                else:
                    return_results('Could not login, please check the credentials provided')

            elif demisto.command() == 'bluecat-get-ipv4-object':
                res = BlueCatIpamAPIParser()
                return_results(CommandResults(
                    outputs_prefix = 'IPv4-objects',
                    outputs=res.get_IPv4Objects()))

            else:
                raise NotImplementedError(f'{command} is not an existing Bluecat Address Mannager command')

        # Log exceptions and return errors
        except Exception as ex:
            demisto.error(traceback.format_exc())  # print the traceback
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(ex)}')



    if __name__ in ['__main__', 'builtin', 'builtins']:
        main()

    register_module_line('PANW IoT 3rd Party Integration - BlueCat IPAM', 'end', __line__())
  subtype: python3
  type: python
sourcemoduleid: BluecatAddressManager
