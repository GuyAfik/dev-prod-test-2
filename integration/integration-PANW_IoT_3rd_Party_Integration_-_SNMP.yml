category: Network Security
commonfields:
  id: PANW IoT 3rd Party Integration - SNMP
  version: -1
configuration:
- display: ""
  name: Entry switch IP
  required: true
  type: 0
- defaultvalue: 2c
  display: ""
  name: SNMP Version
  options:
  - 2c
  - "3"
  required: true
  type: 15
- additionalinfo: Required if using SNMP version 2c
  display: ""
  name: Community String
  required: false
  type: 4
- additionalinfo: Required if using SNMP version 3
  display: ""
  name: Username
  required: false
  type: 0
- additionalinfo: Required if using SNMP version 3
  display: ""
  name: Security Level
  options:
  - noAuthNoPriv
  - authNoPriv
  - authPriv
  required: false
  type: 15
- additionalinfo: Required if using SNMP version 3
  display: ""
  name: Authentication Protocol
  options:
  - MD5
  - SHA
  required: false
  type: 15
- additionalinfo: Required if using SNMP version 3
  display: ""
  name: Authentication Password
  required: false
  type: 4
- additionalinfo: Required if using SNMP version 3
  display: ""
  name: Privacy Protocol
  options:
  - DES
  - AES
  required: false
  type: 15
- additionalinfo: Required if using SNMP version 3
  display: ""
  name: Privacy Password
  required: false
  type: 4
- additionalinfo: SNMP Query Timeout In Seconds
  defaultvalue: "0.5"
  display: SNMP Timeout
  name: snmp_timeout
  required: false
  type: 0
- additionalinfo: Number of SNMP Retries Per Query
  defaultvalue: "0"
  display: SNMP Retries
  name: snmp_retries
  required: false
  type: 0
- defaultvalue: CDP,LLDP
  display: Neighbor Discovery Protocol
  name: neighbor_discovery_protocol
  options:
  - CDP
  - LLDP
  required: false
  type: 16
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: SNMP Integration
display: PANW IoT 3rd Party Integration - SNMP
image: data:image/png;base64,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
name: PANW IoT 3rd Party Integration - SNMP
script:
  commands:
  - arguments: []
    name: test-command
  - arguments:
    - description: IP of the switch
      name: ip
      required: true
    - description: OID of the query
      name: oid
      required: true
    name: snmp-v2-walk-command
  - arguments:
    - name: ip
    description: Get the switch name with SNMP
    name: snmp-v2-get-switch-name-command
    outputs:
    - contextPath: switch_name
      type: string
  - arguments:
    - name: ip
    name: snmp-v2-get-mac-ip-command
  - arguments:
    - name: ip
    name: snmp-v2-get-phys-port-command
  - arguments:
    - name: ip
    description: 'get switches in the network. '
    name: snmp-v2-get-switches-command
  - arguments:
    - name: ip
      required: true
    - name: oid
      required: true
    name: snmp-v3-walk-command
  dockerimage: demisto/panw-iot:1.0.0.79918
  runonce: false
  script: |
    register_module_line('PANW IoT 3rd Party Integration - SNMP', 'start', __line__())


    import re
    import time
    from pysnmp.hlapi import *
    import socket

    hosts = ["10.6.72.104"]
    oids = ["1.3.6.1.4.1.9.9.23.1.2.1.1.4"]
    STD_TAGGED_AND_UNTAGGED_PORTS_OID = '1.3.6.1.2.1.17.7.1.4.2.1.4'
    STD_UNTAGGED_PORTS_PORTS_OID = '1.3.6.1.2.1.17.7.1.4.2.1.5'

    SYS_DESC_OID  = '1.3.6.1.2.1.1.1'
    VENDOR_CISCO = "cisco"
    VENDOR_ARUBAOS = "arubaos"
    VENDOR_ARISTA = "arista"
    VENDOR_CISCO_AIREOS_WLC = "controller"
    IF_INDEX = "intf_index"
    IF_NAME = "intf_name"
    IF_IP4_ADDR = "intf_ipv4_addr"
    IF_MAC_ADDR = "intf_mac_addr"
    IF_OPER_STATUS = "intf_operational_status"
    VLAN_ID = "vlan_id"

    SWITCH_NAME_OID = '1.3.6.1.2.1.1.5'
    MAC_IP_PAIR_OID = '1.3.6.1.2.1.4.22.1.2'
    PHYS_PORT_OID = '1.3.6.1.2.1.31.1.1.1.1'
    CDP_VLAN_LIST_OID = '1.3.6.1.4.1.9.9.46.1.3.1.1.2'
    LLDP_VLAN_LIST_OID = '1.3.6.1.2.1.17.7.1.4.2.1.3'
    MAC_BRIDGE_PORT_OID = '1.3.6.1.2.1.17.4.3.1.2'
    BRIDGE_PORT_IFNAME_OID = '1.3.6.1.2.1.17.1.4.1.2'
    IFNAME_ACTUAL_PORT_OID = '1.3.6.1.2.1.31.1.1.1.1'
    CDP_OID = '1.3.6.1.4.1.9.9.23.1.2.1.1.4'
    LLDP_OID = '1.0.8802.1.1.2.1.4.2.1'
    CISCO_TRUNK_STATUS_OID = '1.3.6.1.4.1.9.9.46.1.6.1.1.14'

    DOT = '.'
    INSTANCE_NAME = demisto.params().get('Name')
    ENTRY_IP = demisto.params().get('Entry switch IP')
    COMMUNITY = demisto.params().get('Community String')
    VERSION = demisto.params().get('SNMP Version')
    USERNAME = demisto.params().get('Username')
    SECURITY_LEVEL = demisto.params().get('Security Level')
    AUTH_PROTOCOL = demisto.params().get('Authentication Protocol')
    AUTH_PASSWORD = demisto.params().get('Authentication Password')
    PRIVACY_PROTOCOL = demisto.params().get('Privacy Protocol')
    PRIVACY_PASSWORD = demisto.params().get('Privacy Password')
    TIMEOUT = demisto.params().get("snmp_timeout")
    if TIMEOUT == None or TIMEOUT == "":
        TIMEOUT = 1.0
    else:
        TIMEOUT = float(TIMEOUT)

    RETRIES = demisto.params().get("snmp_retries")
    if RETRIES == None or RETRIES == "":
        RETRIES = 1
    else:
        RETRIES = float(RETRIES)

    DISCOVERY_PROTOCOLS = demisto.params().get("neighbor_discovery_protocol")
    if DISCOVERY_PROTOCOLS == None or DISCOVERY_PROTOCOLS == "":
        DISCOVERY_PROTOCOLS = []

    def is_valid_ipv4_address(address):
        try:
            socket.inet_pton(socket.AF_INET, address)
        except AttributeError:  # no inet_pton here, sorry
            try:
                socket.inet_aton(address)
            except socket.error:
                return False
            return address.count('.') == 3
        except socket.error:  # not a valid address
            return False

        return True

    def walk_v3(host, oid):
        user = "user1"
        auth_password = "password123"
        result = {}
        next_cmd = nextCmd(SnmpEngine(),
            UsmUserData(user, auth_password), UdpTransportTarget((host, 161)), ContextData(),
            ObjectType(ObjectIdentity(oid)),
            lexicographicMode=False)
        for (errorIndication,errorStatus,errorIndex,varBinds) in next_cmd:
            if errorIndication:
                # print(errorIndication)
                break
            elif errorStatus:
                # print('%s at %s' % (errorStatus.prettyPrint(),
                #                    errorIndex and varBinds[int(errorIndex) - 1][0] or '?'))
                break
            else:
                for varBind in varBinds:
                    result[varBind[0].prettyPrint()] = str(varBind[1].prettyPrint())
        return result

    def walk(host, oid, community=COMMUNITY):
        # start = time.time()
        result = {}
        ctx_data = ContextData()
        if VERSION == "2c":
            data = CommunityData(community)
        else: # snmp version 3
            if SECURITY_LEVEL == "noAuthNoPriv":
                data = UsmUserData(USERNAME)
            elif SECURITY_LEVEL == "authNoPriv":
                if AUTH_PROTOCOL == "SHA":
                    data = UsmUserData(USERNAME, AUTH_PASSWORD,
                                       authProtocol=usmHMACSHAAuthProtocol)
                if AUTH_PROTOCOL == "MD5":
                    data = UsmUserData(USERNAME, AUTH_PASSWORD,
                                       authProtocol=usmHMACMD5AuthProtocol)
            elif SECURITY_LEVEL == "authPriv":
                if AUTH_PROTOCOL == "SHA" and PRIVACY_PROTOCOL == "AES":
                    data = UsmUserData(USERNAME, AUTH_PASSWORD, PRIVACY_PASSWORD,
                                       authProtocol=usmHMACSHAAuthProtocol,
                                       privProtocol=usmAesCfb128Protocol)
                elif AUTH_PROTOCOL == "SHA" and PRIVACY_PROTOCOL == "DES":
                    data = UsmUserData(USERNAME, AUTH_PASSWORD, PRIVACY_PASSWORD,
                                       authProtocol=usmHMACSHAAuthProtocol,
                                       privProtocol=usmDESPrivProtocol)
                elif AUTH_PROTOCOL == "MD5" and PRIVACY_PROTOCOL == "AES":
                    data = UsmUserData(USERNAME, AUTH_PASSWORD, PRIVACY_PASSWORD,
                                       authProtocol=usmHMACMD5AuthProtocol,
                                       privProtocol=usmAesCfb128Protocol)
                elif AUTH_PROTOCOL == "MD5" and PRIVACY_PROTOCOL == "DES":
                    data = UsmUserData(USERNAME, AUTH_PASSWORD, PRIVACY_PASSWORD,
                                       authProtocol=usmHMACMD5AuthProtocol,
                                       privProtocol=usmDESPrivProtocol)
                if community != '':
                    # here the comminity string is vlan since it is snmpv3
                    ctx_data =  ContextData(contextName='vlan-' + str(community))
        for (errorIndication,errorStatus,errorIndex,varBinds) in nextCmd(SnmpEngine(),
                    data, UdpTransportTarget((host, 161),timeout=TIMEOUT, retries=RETRIES), ctx_data,
                    ObjectType(ObjectIdentity(oid)),
                    lexicographicMode=False):
            if errorIndication:
                # print(errorIndication)
                demisto.info('[%s] Walk timeout error indication: %s host: %s oid: %s' % (INSTANCE_NAME, str(errorIndication), host, oid))
                break
            elif errorStatus:
                # print('%s at %s' % (errorStatus.prettyPrint(),
                #                    errorIndex and varBinds[int(errorIndex) - 1][0] or '?'))
                demisto.info('[%s] Walk error status: %s at %s host: %s oid: %s' % (INSTANCE_NAME, errorStatus.prettyPrint(), errorIndex and varBinds[int(errorIndex) - 1][0] or '?', host, oid))

                break
            else:
                for varBind in varBinds:
                    result[varBind[0].prettyPrint()] = str(varBind[1].prettyPrint())
        # print (result)
        return result

        # end = time.time()
        # print("Took {} seconds".format(end - start))

    ''' HELPER FUNCTIONS '''

    def get_cdp_neighbors(host, oid):
        result = []
        raw_result = walk(host, oid)
        for k, v in raw_result.items():
            raw_ip = v[2:]
            ip = '.'.join(str(int(a+b,16)) for a,b in zip(raw_ip[::2], raw_ip[1::2]))
            result.append(ip)
        return result

    def get_lldp_neighbors(host, oid):
        result = []
        raw_result = walk(host, oid)
        #print(raw_result)
        for line, extra in raw_result.items():
            ip = '.'.join(line.split('=')[0].strip().split('.')[-4:])
            if is_valid_ipv4_address(ip):
                result.append(ip)
        return result

    def get_switches(host):
        """
        Do a BFS traversal level by level to find both CDP and LLDP neighbors.
        Only do 3 level traversal for now, tune as needed.
        """
        visited = set()
        queue = []
        result = []
        queue.append(host)
        level = 0
        while len(queue) > 0:
            qlen = len(queue)
            for i in range(qlen):
                ip = queue.pop(0)
                if ip in visited:
                    continue
                visited.add(ip)
                demisto.info('[%s] Found SNMP neighbor = %s' % (INSTANCE_NAME, str(ip)))
                result.append(ip)
                try:
                    if 'LLDP' in DISCOVERY_PROTOCOLS:
                        demisto.info('[%s] Finding LLDP neighbors = %s' % (INSTANCE_NAME, str(ip)))
                        lldp_neighbors = get_lldp_neighbors(ip, LLDP_OID)
                        for n in lldp_neighbors:
                            if n not in visited and is_valid_ipv4_address(n):
                                queue.append(n)
                    if 'CDP' in DISCOVERY_PROTOCOLS:
                        demisto.info('[%s] Finding CDP neighbors = %s' % (INSTANCE_NAME, str(ip)))
                        cdp_neighbors = get_cdp_neighbors(ip, CDP_OID)
                        for n in cdp_neighbors:
                            if n not in visited and is_valid_ipv4_address(n):
                                queue.append(n)
                except:
                    return result
            # Only do 3 levels for now.
            if level >= 3:
                break
            level += 1

        demisto.info('[%s] Neighbor discovery finished. Total SNMP neighbors found = %d' % (INSTANCE_NAME, len(result)))
        return result


    def get_switch_name(host, oid):
        switch_name = ""
        try:
            raw_result = walk(host, oid)
            for k, v in raw_result.items():
                return v
        except Exception as e:
            raise Exception("Failed to get Switch data: %s" % str(e))
            traceback.print_exc()
        return switch_name


    def get_mac_ip_map(host, oid):
        result = {}
        try:
            demisto.info('[%s] Endpoint discovery started for host: %s and oid: %s' % (INSTANCE_NAME, host, oid))
            raw_result = walk(host, oid)
            for k, v in raw_result.items():
                raw_ip = k.split(DOT)[-4:]
                ip = DOT.join(raw_ip)
                raw_mac = v[2:]
                mac = ':'.join(a+b for a,b in zip(raw_mac[::2], raw_mac[1::2]))
                demisto.info('[%s] Discovered IP: %s and mac: %s' % (INSTANCE_NAME, ip, mac))
                result[mac] = ip
            demisto.info('[%s] Endpoint discovery finished for host: %s and oid: %s' % (INSTANCE_NAME, host, oid))
        except:
            traceback.print_exc()
        return result


    def get_vlan_list(host, oid):
        vlan_list = []
        try:
            raw_result = walk(host, oid)
            for k, v in raw_result.items():
                vlan_list.append(k.split(DOT)[-1])
        except:
            traceback.print_exc()
        return vlan_list


    def get_indexed_community(vlan, community):
        if VERSION == "3":
            demisto.info("Since it is snmpv3 returning vlan instead of community: "+ str(vlan))
            return vlan
        return community + '@' + str(vlan)


    def get_mac_bridge_port_map(host, oid, community):
        """
        returns a map in which key is MAC address and value is bridge port number.
        """
        result = {}
        try:
            raw_result = walk(host, oid, community)
            for k, v in raw_result.items():
                raw_mac = k.split(DOT)[-6:]
                try:
                    mac = ':'.join('%02x'%int(i) for i in raw_mac)
                    result[mac] = v
                except:
                    result[raw_mac] = v
        except:
            pass
        return result


    def get_bridge_port_index_map(host, oid, community):
        """
        returns a map in which key is bridge port number and value is ifName index (actual port index).
        """
        result = {}
        raw_result = walk(host, oid, community)
        for k, v in raw_result.items():
            bridge_port = k.split(DOT)[-1]
            result[bridge_port] = v
        return result


    def get_ifname_port_map(host, oid, community):
        """
        returns a map in which key is ifname index and value is real port name
        """
        result = {}
        raw_result = walk(host, oid, community)
        for k, v in raw_result.items():
            index = k.split(DOT)[-1]
            result[index] = v
        return result

    def get_cisco_ifidx_trunk_status_map(host, community):
        """
        returns a map in which key is ifname index and value is trunk status.
        trunking(1)
        notTrunking(2)
        """
        result = {}
        raw_result = walk(host, CISCO_TRUNK_STATUS_OID, community)
        for k, v in raw_result.items():
            index = k.split(DOT)[-1]
            result[index] = v
        return result

    def get_std_ifidx_trunk_status_map(host, community):
        """
        returns a map in which key is ifname index and value is trunk status.
        """
        result={}
        tagged_and_untagged_ports={}
        untagged_ports_map={}
        tagged_and_untagged_ports = get_std_vlan_trunk_status(host, STD_TAGGED_AND_UNTAGGED_PORTS_OID)
        demisto.info('tagged_and_untagged_ports: '+str(tagged_and_untagged_ports))
        untagged_ports_map = get_std_vlan_trunk_status(host, STD_UNTAGGED_PORTS_PORTS_OID)
        demisto.info('untagged_ports_map: '+str(untagged_ports_map))
        for k,v in tagged_and_untagged_ports.items():
            if k not in untagged_ports_map:
                result[k] = 1
            elif v == untagged_ports_map[k]:
                result[k] = 2
            else:
                result[k] = 1
        return result

    def get_ifidx_trunk_status_map(host):
        vendor = get_vendor(host)
        demisto.info('vendor: '+str(vendor))
        if vendor == VENDOR_CISCO:
            # demisto.info('cisco')
            return get_cisco_ifidx_trunk_status_map(host, COMMUNITY)
        return get_std_ifidx_trunk_status_map(host, COMMUNITY)


    def get_std_vlan_trunk_status(host, oid):
        """
        returns a map in which key is ifname index and value is real port name
        """
        result = {}
        raw_result = walk(host, oid)
        # return_outputs(raw_result)
        for k, v in raw_result.items():
            get_std_vlan_portlist(k, v, result)
        return result

    def get_std_vlan_portlist(k, v, result_map):
        # GET VLAN ID
        vlan_idx = k.split('.')[-1]
        if vlan_idx != " " and len(vlan_idx) > 0:
            # Get port list/interfaces for this VLAN
            get_std_vlan_interfaces_from_portlist(v, vlan_idx, result_map)
            # return_outputs(result_map)

    def get_std_vlan_interfaces_from_portlist(val, vlan_idx, result_map):
        # demisto.info('val:'+str(val))
        # demisto.info('vlan_idx:'+str(vlan_idx))
        try:
            port_str = remove_prefix(val.lstrip(), '0x')
            temp_list = '.'.join(str(int(a+b,16)) for a,b in zip(port_str[::2], port_str[1::2]))
            # Parse through the DOT seperated list of Octets and convert them to Port list based on IF indexes
            base_idx = 0

            for v in temp_list.split("."):
                local_idx  = 1
                v_int = int(v)
                while local_idx <= 8:
                    if v_int & 128 == 128:
                        port_idx = base_idx + local_idx
                        port_name = str(port_idx)
                        # Add Port index and interface name to this VLAN
                        if port_name not in result_map:
                            result_map[port_name] = {}
                        result_map[port_name][IF_INDEX] = port_idx
                        result_map[port_name][IF_NAME] = port_name
                        result_map[port_name][VLAN_ID] = vlan_idx
                    v_int = v_int << 1
                    local_idx += 1
                base_idx += 8
        except Exception:
            pass

    def get_mac_port_mapping(result, host, community):
        demisto.info('Host:'+str(host))
        mac_bridge_port_map = get_mac_bridge_port_map(host, MAC_BRIDGE_PORT_OID, community)
        if len(mac_bridge_port_map) == 0:
            return result
        demisto.info('mac_bridge_port_map:'+str(mac_bridge_port_map))
        bridge_port_index_map = get_bridge_port_index_map(host, BRIDGE_PORT_IFNAME_OID, community)
        if len(bridge_port_index_map) == 0:
            return result
        demisto.info('bridge_port_index_map:'+str(bridge_port_index_map))
        ifname_port_map = get_ifname_port_map(host, IFNAME_ACTUAL_PORT_OID, community)
        demisto.info('ifname_port_map:'+str(ifname_port_map))
        if len(ifname_port_map) == 0:
            return result
        ifidx_trunk_map = get_ifidx_trunk_status_map(host)
        demisto.info('mapping ifidx_trunk_map:'+str(ifidx_trunk_map))
        for mac, bridge in mac_bridge_port_map.items():
            if bridge in bridge_port_index_map:
                index = bridge_port_index_map[bridge]
                if index in ifname_port_map:
                    port = ifname_port_map[index]
                    isAccess = False
                    if len(ifidx_trunk_map) != 0 and index in ifidx_trunk_map:
                        isAccess = (ifidx_trunk_map[index] == 2 or ifidx_trunk_map[index] == '2')
                    elif len(ifidx_trunk_map) != 0 and bridge in ifidx_trunk_map:
                        isAccess = (ifidx_trunk_map[bridge] == 2 or ifidx_trunk_map[bridge] == '2')
                    result[mac] = [port, isAccess]
        return result

    def get_mac_actual_port_map(host):
        """
        Correlation between mac address and physical port number.
        returns a map in which key device mac address and value is real port name.
        """
        result = {}
        vlan_list = []
        vlan_list = get_vlan_list(host, CDP_VLAN_LIST_OID)
        vlan_list.extend(get_vlan_list(host, LLDP_VLAN_LIST_OID))
        # for each vlan, there should be a list MAC addresses and the port
        # current switch learn them from
        if len(vlan_list) > 0:
            for vlan in vlan_list:
                demisto.info(f'mac address port mapping for vlan: {vlan}')
                indexed_community = get_indexed_community(vlan, COMMUNITY)
                result = get_mac_port_mapping(result, host, indexed_community)
        demisto.info(f'mac address port mapping for Non vlan list')
        result = get_mac_port_mapping(result, host, COMMUNITY)
        return result

    # System Description for Vendor discovery
    def get_str_from_hex(val):
        #Check if the string starts with 0x then convert it to utf-8
        if val.startswith('0x'):
            try:
                ver = bytes.fromhex(remove_prefix(val, '0x')).decode('utf-8')
            except:
                ver = val
        else:
            ver = val
        return ver

    def get_vendor(host):
        try:
            raw_result = walk(host, SYS_DESC_OID)
            for k, v in raw_result.items():
                sys_desc = get_str_from_hex(v)
                if re.search(VENDOR_CISCO, sys_desc, re.IGNORECASE):
                    if re.search(VENDOR_CISCO_AIREOS_WLC, sys_desc, re.IGNORECASE):
                        return VENDOR_CISCO_AIREOS_WLC
                    else:
                        return VENDOR_CISCO
                elif re.search(VENDOR_ARUBAOS, sys_desc, re.IGNORECASE):
                    return VENDOR_ARUBAOS
                elif re.search(VENDOR_ARISTA, sys_desc, re.IGNORECASE):
                    return VENDOR_ARISTA
                else:
                    return "NA"
        except Exception as ex:
            print(ex)

    def remove_prefix(text, oid_prefix):
        if text.startswith(oid_prefix):
            return text[len(oid_prefix):]
        return text

    def is_valid_ipv4_address(address):
        try:
            socket.inet_pton(socket.AF_INET, address)
        except AttributeError:  # no inet_pton here, sorry
            try:
                socket.inet_aton(address)
            except socket.error:
                return False
            return address.count('.') == 3
        except socket.error:  # not a valid address
            return False

        return True


    def get_device_info(host):
        switch_name = get_switch_name(host, SWITCH_NAME_OID)
        mac_ip_map = get_mac_ip_map(host, MAC_IP_PAIR_OID)
        mac_port_map = get_mac_actual_port_map(host)
        result_map = {}

        for mac, ip in mac_ip_map.items():
            if mac not in result_map:
                result_map[mac] = {}
            result_map[mac]["deviceid"] = mac
            result_map[mac]["connect_evtContent.ip"] = ip
            result_map[mac]["switchName"] = switch_name
            result_map[mac]["switchIP"] = host
        for mac, port in mac_port_map.items():
            if mac not in result_map:
                result_map[mac] = {}
            result_map[mac]["deviceid"] = mac
            result_map[mac]["switchPort"] = port
            result_map[mac]["switchName"] = switch_name
            result_map[mac]["switchIP"] = host
        return result_map.values()

    # The command demisto.command() holds the command sent from the user.
    if demisto.command() == 'test-module':
        try:
            #com = COMMUNITY + "_test"
            #print(com)
            result = get_switch_name(ENTRY_IP, SWITCH_NAME_OID)
            if result == "" or result == None:
                demisto.info('[%s] Test failed to connect to switch: %s oid: %s' % (INSTANCE_NAME, ENTRY_IP, SWITCH_NAME_OID))
                demisto.results("Failed to connect to switch %s. SNMP walk(OID - %s) command returned nothing. " % (ENTRY_IP, SWITCH_NAME_OID))
            else:
                demisto.info('[%s] Test success, switch: %s oid: %s' % (INSTANCE_NAME, ENTRY_IP, SWITCH_NAME_OID))
                demisto.results('ok')

        except Exception as e:
            demisto.info('[%s] Test failed with error: %s switch: %s oid: %s' % (INSTANCE_NAME, str(e), ENTRY_IP, SWITCH_NAME_OID))
            demisto.results('Failed to connect to switch %s - %s' % (ENTRY_IP, str(e)))
        # This is the call made when pressing the integration test button.


    ''' EXECUTION '''
    LOG('command is %s' % (demisto.command(), ))
    try:
        if demisto.command() == 'test-command':
            start = time.time()
            #result = get_ifname_port_map('10.6.72.104', IFNAME_ACTUAL_PORT_OID, get_indexed_community(10, COMMUNITY))
            #result = get_mac_actual_port_map('10.6.72.104')
            #result = get_switch_name('10.6.72.104', SWITCH_NAME_OID)
            result = get_switch_name(ENTRY_IP, SWITCH_NAME_OID)
            end = time.time()
            print("Took {} seconds".format(end - start))
            print(result)
        elif demisto.command() == 'snmp-v3-walk-command':
            ip = demisto.args().get('ip')
            oid = demisto.args().get('oid')
            result = walk_v3(ip, oid)
            demisto.results(result)
        elif demisto.command() == 'snmp-v2-walk-command':
            ip = demisto.args().get('ip')
            oid = demisto.args().get('oid')
            result = walk(ip, oid)
            demisto.results(result)
        elif demisto.command() == 'snmp-v2-get-switch-name-command':
            ip = demisto.args().get('ip')
            result = get_switch_name(ip, SWITCH_NAME_OID)
            demisto.results(result)

        elif demisto.command() == 'snmp-v2-get-mac-ip-command':
            ip = demisto.args().get('ip')
            result = get_mac_ip_map(ip, MAC_IP_PAIR_OID)
            demisto.results(result)

        elif demisto.command() == 'snmp-v2-get-phys-port-command':
            ip = demisto.args().get('ip')
            result = get_mac_actual_port_map(ip)
            demisto.results(result)

        elif demisto.command() == 'snmp-v2-get-switches-command':
            result = get_switches(ENTRY_IP)
            res = {}
            if type(result) == list:
                for r in result:
                    res[r] = r
            demisto.results(res)

    except Exception as e:
        LOG(str(e))
        LOG.print_log()
        return_error(str(e))

      # Should have here an endless loop

    register_module_line('PANW IoT 3rd Party Integration - SNMP', 'end', __line__())
  subtype: python3
  type: python
sourcemoduleid: 'test integration '
