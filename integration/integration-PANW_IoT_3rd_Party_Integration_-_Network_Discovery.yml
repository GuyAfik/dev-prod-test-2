category: Network Security
commonfields:
  id: PANW IoT 3rd Party Integration - Network Discovery
  version: -1
configuration:
- display: ""
  name: Entry switch IP
  required: true
  type: 0
- defaultvalue: 2c
  display: ""
  name: SNMP Version
  options:
  - 2c
  - "3"
  required: true
  type: 15
- additionalinfo: Required if using SNMP version 2c
  display: ""
  name: Community String
  required: false
  type: 4
- additionalinfo: Required if using SNMP version 3
  display: ""
  name: Username
  required: false
  type: 0
- additionalinfo: Required if using SNMP version 3
  display: ""
  name: Security Level
  options:
  - noAuthNoPriv
  - authNoPriv
  - authPriv
  required: false
  type: 15
- additionalinfo: Required if using SNMP version 3
  display: ""
  name: Authentication Protocol
  options:
  - MD5
  - SHA
  required: false
  type: 15
- additionalinfo: Required if using SNMP version 3
  display: ""
  name: Authentication Password
  required: false
  type: 4
- additionalinfo: Required if using SNMP version 3
  display: ""
  name: Privacy Protocol
  options:
  - AES
  - DES
  required: false
  type: 15
- additionalinfo: Required if using SNMP version 3
  display: ""
  name: Privacy Password
  required: false
  type: 4
- display: Site
  name: Site
  required: false
  type: 0
- additionalinfo: SNMP Query Timeout In Seconds
  defaultvalue: "0.5"
  display: SNMP Timeout
  name: snmp_timeout
  required: false
  type: 0
- additionalinfo: Number of SNMP Retries Per Query
  defaultvalue: "0"
  display: SNMP Retries
  name: snmp_retries
  required: false
  type: 0
- defaultvalue: CDP,LLDP
  display: Neighbor Discovery Protocol
  name: neighbor_discovery_protocol
  options:
  - LLDP
  - CDP
  required: false
  type: 16
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: Network Discovery Integration
display: PANW IoT 3rd Party Integration - Network Discovery
image: data:image/png;base64,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
name: PANW IoT 3rd Party Integration - Network Discovery
script:
  commands:
  - arguments:
    - description: IP of the switch
      name: ip
      required: true
    - description: OID of the query
      name: oid
      required: true
    name: nd-snmp-v2-walk-command
  - arguments:
    - description: IP of the switch
      name: ip
      required: true
    - description: OID of the query
      name: oid
      required: true
    name: nd-snmp-v3-walk-command
  - arguments: []
    description: Get sites configured
    name: get-network-discovery-site
    outputs:
    - contextPath: ND.Site
  - arguments: []
    description: Gets switch entry ip
    name: get-network-discovery-entry-ip
    outputs:
    - contextPath: ND.EntryIP
  - arguments: []
    description: Gets switch entry community string
    name: get-network-discovery-community
    outputs:
    - contextPath: ND.EntryCommunityString
  - arguments:
    - name: ip
    name: nd-snmp-get-phys-port-command
  - arguments: []
    name: get-nd-discovery-protocols
  dockerimage: demisto/panw-iot:1.0.0.79918
  runonce: false
  script: |
    register_module_line('PANW IoT 3rd Party Integration - Network Discovery', 'start', __line__())






    import time
    from pysnmp.hlapi import *

    DOT = '.'
    COMMUNITY=''
    # ***************** IP Interface Functions*************
    # Below two OIDs for VLAN Subnet discovery
    IF_IDX_TO_IF_NAME_OID               = '1.3.6.1.2.1.31.1.1.1.1'
    IF_IDX_TO_IF_DESC_OID               = '1.3.6.1.2.1.2.2.1.2'
    IF_IDX_TO_IP_ADDR_OID               = '1.3.6.1.2.1.4.20.1.2'
    IF_IDX_TO_MAC_ADDRESS_OID           = '1.3.6.1.2.1.2.2.1.6'
    CISCO_TRUNK_STATUS_OID = '1.3.6.1.4.1.9.9.46.1.6.1.1.14'
    STD_TAGGED_AND_UNTAGGED_PORTS_OID = '1.3.6.1.2.1.17.7.1.4.2.1.4'
    STD_UNTAGGED_PORTS_PORTS_OID = '1.3.6.1.2.1.17.7.1.4.2.1.5'

    SYS_DESC_OID  = '1.3.6.1.2.1.1.1'
    VENDOR_CISCO = "cisco"
    VENDOR_ARUBAOS = "arubaos"
    VENDOR_ARISTA = "arista"
    VENDOR_CISCO_AIREOS_WLC = "controller"
    IF_INDEX = "intf_index"
    IF_NAME = "intf_name"
    IF_IP4_ADDR = "intf_ipv4_addr"
    IF_MAC_ADDR = "intf_mac_addr"
    IF_OPER_STATUS = "intf_operational_status"
    VLAN_ID = "vlan_id"

    OID_VS_NAME = {
        "1.0.8802.1.1.2.1.4":"lldpRemoteSystemsData",
        "1.3.6.1.4.1.9.9.23.1.2.1.1":"CISCO-CDP-MIB"
    }

    # *************** Get Endpoints Information *********************


    LLDP_OID = '1.0.8802.1.1.2.1.4.2.1'
    CDP_VLAN_LIST_OID = '1.3.6.1.4.1.9.9.46.1.3.1.1.2'
    LLDP_VLAN_LIST_OID = '1.3.6.1.2.1.17.7.1.4.2.1.3'

    oids = ["1.3.6.1.4.1.9.9.23.1.2.1.1.4"]

    SWITCH_NAME_OID = '1.3.6.1.2.1.1.5'
    MAC_IP_PAIR_OID = '1.3.6.1.2.1.4.22.1.2'
    PHYS_PORT_OID = '1.3.6.1.2.1.31.1.1.1.1'
    VLAN_LIST_OID = '1.3.6.1.4.1.9.9.46.1.3.1.1.2'
    MAC_BRIDGE_PORT_OID = '1.3.6.1.2.1.17.4.3.1.2'
    BRIDGE_PORT_IFNAME_OID = '1.3.6.1.2.1.17.1.4.1.2'
    IFNAME_ACTUAL_PORT_OID = '1.3.6.1.2.1.31.1.1.1.1'
    CDP_OID = '1.3.6.1.4.1.9.9.23.1.2.1.1.4'

    DOT = '.'
    ENTRY_IP = demisto.params().get('Entry switch IP')
    COMMUNITY = demisto.params().get('Community String')
    VERSION = demisto.params().get('SNMP Version')
    USERNAME = demisto.params().get('Username')
    SECURITY_LEVEL = demisto.params().get('Security Level')
    AUTH_PROTOCOL = demisto.params().get('Authentication Protocol')
    AUTH_PASSWORD = demisto.params().get('Authentication Password')
    PRIVACY_PROTOCOL = demisto.params().get('Privacy Protocol')
    PRIVACY_PASSWORD = demisto.params().get('Privacy Password')
    SITE = demisto.params().get('Site')

    TIMEOUT = demisto.params().get("snmp_timeout")
    if TIMEOUT == None or TIMEOUT == "":
        TIMEOUT = 1.0
    else:
        TIMEOUT = float(TIMEOUT)
    RETRIES = demisto.params().get("snmp_retries")
    if RETRIES == None or RETRIES == "":
        RETRIES = 1
    else:
        RETRIES = float(RETRIES)

    DISCOVERY_PROTOCOLS = demisto.params().get("neighbor_discovery_protocol")
    if DISCOVERY_PROTOCOLS == None or DISCOVERY_PROTOCOLS == "":
        DISCOVERY_PROTOCOLS = []



    def walk_v3(host, oid):
        user = USERNAME
        auth_password = AUTH_PASSWORD
        result = {}
        next_cmd = nextCmd(SnmpEngine(),
            UsmUserData(user, auth_password), UdpTransportTarget((host, 161)), ContextData(),
            ObjectType(ObjectIdentity(oid)),
            lexicographicMode=False)
        for (errorIndication,errorStatus,errorIndex,varBinds) in next_cmd:
            if errorIndication:
                demisto.error(errorIndication)
                break
            elif errorStatus:
                # print('%s at %s' % (errorStatus.prettyPrint(),
                #                    errorIndex and varBinds[int(errorIndex) - 1][0] or '?'))
                break
            else:
                for varBind in varBinds:
                    result[str(varBind[0])] = varBind[1].prettyPrint()
        return result

    def walk(host, oid, community=COMMUNITY):
        # start = time.time()
        integration_context_to_set = {"errors":""}
        set_integration_context(integration_context_to_set)
        result = {}
        ctx_data = ContextData()
        if VERSION == "2c":
            data = CommunityData(community)
        else: # snmp version 3
            if SECURITY_LEVEL == "noAuthNoPriv":
                data = UsmUserData(USERNAME)
            elif SECURITY_LEVEL == "authNoPriv":
                if AUTH_PROTOCOL == "SHA":
                    data = UsmUserData(USERNAME, AUTH_PASSWORD,
                                       authProtocol=usmHMACSHAAuthProtocol)
                if AUTH_PROTOCOL == "MD5":
                    data = UsmUserData(USERNAME, AUTH_PASSWORD,
                                       authProtocol=usmHMACMD5AuthProtocol)
            elif SECURITY_LEVEL == "authPriv":
                if AUTH_PROTOCOL == "SHA" and PRIVACY_PROTOCOL == "AES":
                    data = UsmUserData(USERNAME, AUTH_PASSWORD, PRIVACY_PASSWORD,
                                       authProtocol=usmHMACSHAAuthProtocol,
                                       privProtocol=usmAesCfb128Protocol)
                elif AUTH_PROTOCOL == "SHA" and PRIVACY_PROTOCOL == "DES":
                    data = UsmUserData(USERNAME, AUTH_PASSWORD, PRIVACY_PASSWORD,
                                       authProtocol=usmHMACSHAAuthProtocol,
                                       privProtocol=usmDESPrivProtocol)
                elif AUTH_PROTOCOL == "MD5" and PRIVACY_PROTOCOL == "AES":
                    data = UsmUserData(USERNAME, AUTH_PASSWORD, PRIVACY_PASSWORD,
                                       authProtocol=usmHMACMD5AuthProtocol,
                                       privProtocol=usmAesCfb128Protocol)
                elif AUTH_PROTOCOL == "MD5" and PRIVACY_PROTOCOL == "DES":
                    data = UsmUserData(USERNAME, AUTH_PASSWORD, PRIVACY_PASSWORD,
                                       authProtocol=usmHMACMD5AuthProtocol,
                                       privProtocol=usmDESPrivProtocol)
                if community != '':
                    # here the comminity string is vlan since it is snmpv3
                    ctx_data =  ContextData(contextName='vlan-' + str(community))
        errors=[]
        for (errorIndication,errorStatus,errorIndex,varBinds) in nextCmd(SnmpEngine(),
                    data, UdpTransportTarget((host, 161),timeout=TIMEOUT, retries=RETRIES), ctx_data,
                    ObjectType(ObjectIdentity(oid)),
                    lexicographicMode=False,lookupMib=False):
            oid_name=oid
            if oid in OID_VS_NAME.keys():
                oid_name = OID_VS_NAME[oid]
            if errorIndication:
                #time out in the errors
                errors.append(f'Walk timeout error indication: {str(errorIndication)} host: {host} oid: {oid_name}')
                break
            elif errorStatus:
                errors.append(f'Walk error status: {errorStatus.prettyPrint()} at {errorIndex and varBinds[int(errorIndex) - 1][0] or "?"} host: {host} oid: {oid_name}')

                break
            else:
                for varBind in varBinds:
                    result[varBind[0].prettyPrint()] = str(varBind[1].prettyPrint())
        # print (result)
        integration_context_to_set = {"errors":errors}
        set_integration_context(integration_context_to_set)
        return result

    def remove_prefix(text, prefix):
        if text.startswith(prefix):
            return text[len(prefix):]
        return text

    def is_valid_ipv4_address(address):
        try:
            socket.inet_pton(socket.AF_INET, address)
        except AttributeError:  # no inet_pton here, sorry
            try:
                socket.inet_aton(address)
            except socket.error:
                return False
            return address.count('.') == 3
        except socket.error:  # not a valid address
            return False

        return True

    def get_bridge_port_index_map(host, oid, community):
        """
        returns a map in which key is bridge port number and value is ifName index (actual port index).
        """
        result = {}
        raw_result = walk(host, oid, community)
        if raw_result:
            for k, v in raw_result.items():
                bridge_port = k.split(DOT)[-1]
                result[bridge_port] = v
        return result

    def get_mac_bridge_port_map(host, oid, community):
        """
        returns a map in which key is MAC address and value is bridge port number.
        """
        result = {}
        try:
            raw_result = walk(host, oid, community)
            if raw_result:
                for k, v in raw_result.items():
                    raw_mac = k.split(DOT)[-6:]
                    mac = ':'.join('%02x'%int(i) for i in raw_mac)
                    result[mac] = v
        except:
            pass
        return result

    def get_indexed_community(vlan, community):
        if VERSION == "3":
            demisto.info("Since it is snmpv3 returning vlan instead of community: "+ str(vlan))
            return vlan
        return community + '@' + str(vlan)

    def get_vlan_list(host, oid):
        vlan_list = []
        try:
            raw_result = walk(host, oid)
            if raw_result:
                for k, v in raw_result.items():
                    vlan_list.append(k.split(DOT)[-1])
        except Exception as ex:
            raise Exception(ex)
        return vlan_list

    def get_mac_actual_port_map(host):
        """
        Correlation between mac address and physical port number.
        returns a map in which key device mac address and value is real port name.
        """
        result = {}
        vlan_list = []
        vlan_list = get_vlan_list(host, CDP_VLAN_LIST_OID)
        vlan_list.extend(get_vlan_list(host, LLDP_VLAN_LIST_OID))
        # for each vlan, there should be a list MAC addresses and the port
        # current switch learn them from
        if len(vlan_list) > 0:
            for vlan in vlan_list:
                demisto.info(f'mac address port mapping for vlan: {vlan}')
                indexed_community = get_indexed_community(vlan, COMMUNITY)
                result = get_mac_port_mapping(result, host, indexed_community)
        demisto.info(f'mac address port mapping for Non vlan list')
        result = get_mac_port_mapping(result, host, COMMUNITY)
        return result

    def get_mac_port_mapping(result, host, community):
        demisto.info('Host:'+str(host))
        mac_bridge_port_map = get_mac_bridge_port_map(host, MAC_BRIDGE_PORT_OID, community)
        if len(mac_bridge_port_map) == 0:
            return result
        demisto.info('mac_bridge_port_map:'+str(mac_bridge_port_map))
        bridge_port_index_map = get_bridge_port_index_map(host, BRIDGE_PORT_IFNAME_OID, community)
        if len(bridge_port_index_map) == 0:
            return result
        demisto.info('bridge_port_index_map:'+str(bridge_port_index_map))
        ifname_port_map = get_ifname_port_map(host, IFNAME_ACTUAL_PORT_OID, community)
        if len(ifname_port_map) == 0:
            return result
        demisto.info('ifname_port_map:'+str(ifname_port_map))
        ifidx_trunk_map = get_ifidx_trunk_status_map(host)
        demisto.info('mapping ifidx_trunk_map:'+str(ifidx_trunk_map))
        for mac, bridge in mac_bridge_port_map.items():
            if bridge in bridge_port_index_map:
                index = bridge_port_index_map[bridge]
                if index in ifname_port_map:
                    port = ifname_port_map[index]
                    isAccess = False
                    if len(ifidx_trunk_map) != 0 and index in ifidx_trunk_map:
                        isAccess = ifidx_trunk_map[index] == 2
                    elif len(ifidx_trunk_map) != 0 and bridge in ifidx_trunk_map:
                        isAccess = ifidx_trunk_map[bridge] == 2
                    result[mac] = [port, isAccess]
        return result

    def get_vendor(host):
        try:
            raw_result = walk(host, SYS_DESC_OID)
            for k, v in raw_result.items():
                sys_desc = get_str_from_hex(v)
                if re.search(VENDOR_CISCO, sys_desc, re.IGNORECASE):
                    if re.search(VENDOR_CISCO_AIREOS_WLC, sys_desc, re.IGNORECASE):
                        return VENDOR_CISCO_AIREOS_WLC
                    else:
                        return VENDOR_CISCO
                elif re.search(VENDOR_ARUBAOS, sys_desc, re.IGNORECASE):
                    return VENDOR_ARUBAOS
                elif re.search(VENDOR_ARISTA, sys_desc, re.IGNORECASE):
                    return VENDOR_ARISTA
                else:
                    return "NA"
        except Exception as ex:
            print(ex)

    def get_str_from_hex(val):
        #Check if the string starts with 0x then convert it to utf-8
        if val.startswith('0x'):
            try:
                ver = bytes.fromhex(remove_prefix(val, '0x')).decode('utf-8')
            except:
                ver = val
        else:
            ver = val
        return ver

    def remove_prefix(text, oid_prefix):
        if text.startswith(oid_prefix):
            return text[len(oid_prefix):]
        return text

    def get_ifidx_trunk_status_map(host):
        vendor = get_vendor(host)
        demisto.info('vendor: '+str(vendor))
        if vendor == VENDOR_CISCO:
            return get_cisco_ifidx_trunk_status_map(host, COMMUNITY)
        return get_std_ifidx_trunk_status_map(host, COMMUNITY)

    def get_cisco_ifidx_trunk_status_map(host, community):
        """
        returns a map in which key is ifname index and value is trunk status.
        trunking(1)
        notTrunking(2)
        """
        result = {}
        raw_result = walk(host, CISCO_TRUNK_STATUS_OID, community)
        for k, v in raw_result.items():
            index = k.split(DOT)[-1]
            result[index] = v
        return result

    def get_std_ifidx_trunk_status_map(host, community):
        """
        returns a map in which key is ifname index and value is trunk status.
        """
        result={}
        tagged_and_untagged_ports={}
        untagged_ports_map={}
        tagged_and_untagged_ports = get_std_vlan_trunk_status(host, STD_TAGGED_AND_UNTAGGED_PORTS_OID)
        demisto.info('tagged_and_untagged_ports: '+str(tagged_and_untagged_ports))
        untagged_ports_map = get_std_vlan_trunk_status(host, STD_UNTAGGED_PORTS_PORTS_OID)
        demisto.info('untagged_ports_map: '+str(untagged_ports_map))
        for k,v in tagged_and_untagged_ports.items():
            if k not in untagged_ports_map:
                result[k] = 1
            elif v == untagged_ports_map[k]:
                result[k] = 2
            else:
                result[k] = 1
        return result

    def get_std_vlan_trunk_status(host, oid):
        """
        returns a map in which key is ifname index and value is real port name
        """
        result = {}
        raw_result = walk(host, oid)
        # return_outputs(raw_result)
        for k, v in raw_result.items():
            get_std_vlan_portlist(k, v, result)
        return result

    def get_std_vlan_portlist(k, v, result_map):
        # GET VLAN ID
        vlan_idx = k.split('.')[-1]
        if vlan_idx != " " and len(vlan_idx) > 0:
            # Get port list/interfaces for this VLAN
            get_std_vlan_interfaces_from_portlist(v, vlan_idx, result_map)
            # return_outputs(result_map)

    def get_std_vlan_interfaces_from_portlist(val, vlan_idx, result_map):
        # demisto.info('val:'+str(val))
        # demisto.info('vlan_idx:'+str(vlan_idx))
        try:
            port_str = remove_prefix(val.lstrip(), '0x')
            temp_list = '.'.join(str(int(a+b,16)) for a,b in zip(port_str[::2], port_str[1::2]))
            # Parse through the DOT seperated list of Octets and convert them to Port list based on IF indexes
            base_idx = 0

            for v in temp_list.split("."):
                local_idx  = 1
                v_int = int(v)
                while local_idx <= 8:
                    if v_int & 128 == 128:
                        port_idx = base_idx + local_idx
                        port_name = str(port_idx)
                        # Add Port index and interface name to this VLAN
                        if port_name not in result_map:
                            result_map[port_name] = {}
                        result_map[port_name][IF_INDEX] = port_idx
                        result_map[port_name][IF_NAME] = port_name
                        result_map[port_name][VLAN_ID] = vlan_idx
                    v_int = v_int << 1
                    local_idx += 1
                base_idx += 8
        except Exception:
            pass

    def get_ifname_port_map(host, oid, community):
        """
        returns a map in which key is ifname index and value is real port name
        """
        result = {}
        raw_result = walk(host, oid, community)
        for k, v in raw_result.items():
            index = k.split(DOT)[-1]
            result[index] = v
        return result


    ''' HELPER FUNCTIONS '''


    def get_switch_name(host, oid):
        switch_name = ""
        try:
            raw_result = walk(host, oid)
            for k, v in raw_result.items():
                return v
        except:
            traceback.print_exc()
        return switch_name

    def get_site():
        # return CommandResults(
        #     readable_output=SITE,
        #     outputs_prefix="ND.Site",
        #     outputs=SITE
        # )
        return SITE


    def get_protocols():
        res = {"protocols": DISCOVERY_PROTOCOLS}
        return res

    def get_entry_ip():
        return ENTRY_IP

    def get_entry_community():
        return COMMUNITY

    ''' MAIN FUNCTION '''
    def main() -> None:
        """main function, parses params and runs command functions

        :return:
        :rtype:
        """

        demisto.debug('command called is {demisto.command()}')
        try:
            if demisto.command() == 'test-module':
                try:
                    result = get_switch_name(ENTRY_IP, SWITCH_NAME_OID)
                    if result == "":
                        demisto.results("Failed to connect to switch %s" % ENTRY_IP)
                    else:
                        demisto.results('ok')

                except Exception as e:
                    demisto.results('Failed to connect to switch %s - %s' % (ENTRY_IP, str(e)))

            if demisto.command() == 'nd-snmp-v3-walk-command':
                ip = demisto.args().get('ip')
                oid = demisto.args().get('oid')
                result = walk_v3(ip, oid)
                demisto.results(result)
            if demisto.command() == 'nd-snmp-v2-walk-command':
                ip = demisto.args().get('ip')
                oid = demisto.args().get('oid')
                result = walk(ip, oid)
                integration_context = get_integration_context()
                # integration_context['errors']
                return_outputs(readable_output=result,outputs={'errors':integration_context['errors']}, raw_response=result)

            if demisto.command() == 'get-network-discovery-site':
                site = get_site()
                demisto.results(site)
            if demisto.command() == 'get-network-discovery-entry-ip':
                entry_ip = get_entry_ip()
                demisto.results(entry_ip)
            if demisto.command() == 'get-network-discovery-community':
                comm_string = get_entry_community()
                demisto.results(comm_string)
            if demisto.command() == 'nd-snmp-get-phys-port-command':
                ip = demisto.args().get('ip')
                result = get_mac_actual_port_map(ip)
                demisto.results(result)
            if demisto.command() == 'get-nd-discovery-protocols':
                return_results(CommandResults(
                    readable_output=f'Discovery Protocols',
                    outputs_prefix='nd.discover_protocols',
                    outputs=get_protocols()))
        except Exception as e:
            demisto.error(str(e))
            return_error(str(e))
        finally:
            LOG.print_log()

    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()




    register_module_line('PANW IoT 3rd Party Integration - Network Discovery', 'end', __line__())
  subtype: python3
  type: python
sourcemoduleid: Network Discovery
