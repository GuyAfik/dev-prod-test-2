category: Network Security
commonfields:
  id: PANW IoT 3rd Party Integration - Cisco ISE pxGrid
  version: -1
configuration:
- additionalinfo: Needs to be resolvable
  defaultvalue: https://ise-server
  display: ISE server URL
  name: url
  required: true
  type: 0
- display: ""
  hiddenpassword: true
  hiddenusername: true
  name: authentication
  required: false
  type: 9
- defaultvalue: "true"
  display: Password Based Account
  name: passwordBasedAuth
  required: false
  type: 8
- defaultvalue: "true"
  display: Certificate Based Account
  name: isFetchCredentials
  required: false
  type: 8
- display: pxGrid Client Name
  name: account_name
  required: true
  type: 0
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: 'Cisco ISE pxGrid Integration. '
display: PANW IoT 3rd Party Integration - Cisco ISE pxGrid
image: data:image/png;base64,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
name: PANW IoT 3rd Party Integration - Cisco ISE pxGrid
script:
  commands:
  - arguments: []
    description: Gets pxGrid account status
    name: pxgrid-get-account-status
  - arguments:
    - description: A CSV list of mac addresses, for example, "macAddress=firstMac,secondMac".
      name: macAddress
    - description: A CSV list of attributes, for example, "attributeName=firstAttribute,secondAttribute".
      name: attributeName
    - description: A CSV list of attribute values, for example, "attributeValue=firstValue,secondValue".
      name: attributeValue
    - description: list of assetTopic objects with opType="Update"
      name: assetTopicList
    description: Updates endpoints with custom attributes. Creates endpoints if they
      do not exist
    name: pxgrid-update-endpoint-custom-attributes
  - arguments:
    - description: Mac address of device being quarantined
      name: mac_address
      required: true
    - auto: PREDEFINED
      description: Quarantine or Un-Quarantine action
      name: action
      predefined:
      - quarantine
      - unquarantine
      required: true
    description: Quarantines or Un-quarantine a device by mac
    name: pxgrid-quarantine-device-by-mac
  dockerimage: demisto/panw-iot:1.0.0.79918
  runonce: false
  script: |
    register_module_line('PANW IoT 3rd Party Integration - Cisco ISE pxGrid', 'start', __line__())


    import requests
    import time
    import websocket
    from websocket import create_connection
    from asyncio.tasks import FIRST_COMPLETED
    from requests.auth import HTTPBasicAuth
    from websockets import ConnectionClosed
    import asyncio
    import tempfile
    import base64
    import io
    import sys, stat
    from io import StringIO
    import argparse
    import ssl
    import json
    import signal
    import websockets
    import os
    import urllib3
    import urllib
    from urllib.parse import urlparse
    import threading
    from threading import Thread

    # Disable insecure warnings
    urllib3.disable_warnings()

    BASE_URL = demisto.params().get("url")
    PASSWORD_ACCOUNT = demisto.params().get("passwordBasedAuth")
    CERT_AUTH = demisto.params().get("authentication")
    #NODENAME = "panw-iot-pxgrid-account"
    NODENAME = demisto.params().get("account_name")
    PXGRID_PASSWORD = None
    ACCOUNT_STATUS = None
    PXGRID_CERT = None
    CERT_ACCOUNT= demisto.params().get("isFetchCredentials")



    DEFAULT_HEADERS = {
        'Accept-Language': 'application/json',
        'Content-Type': 'application/json',
    }


    class StompFrame:
        def __init__(self):
            self.headers = {}
            self.command = None
            self.content = None

        def get_command(self):
            return self.command

        def set_command(self, command):
            self.command = command

        def get_content(self):
            return self.content

        def set_content(self, content):
            self.content = content

        def get_header(self, key):
            return self.headers[key]

        def set_header(self, key, value):
            self.headers[key] = value

        def write(self, out):
            out.write(self.command)
            out.write('\n')
            for key in self.headers:
                out.write(key)
                out.write(':')
                out.write(self.headers[key])
                out.write('\n')
            out.write('\n')
            if self.content is not None:
                out.write(self.content)
            out.write('\0')

        @staticmethod
        def parse(input):
            frame = StompFrame()
            frame.command = input.readline().rstrip('\r\n')
            for line in input:
                line = line.rstrip('\r\n')
                if line == '':
                    break
                (name, value) = line.split(':')
                frame.headers[name] = value
            frame.content = input.read()[:-1]
            return frame

    class WebSocketStomp:
        def __init__(self, ws_url, user, password, ssl_ctx):
            self.ws_url = ws_url
            self.user = user
            self.password = password
            self.ssl_ctx = ssl_ctx
            self.ws = None

        async def connect(self):
            b64 = base64.b64encode(
                (self.user + ':' + self.password).encode()).decode()
            self.ws = await websockets.connect(uri=self.ws_url,
                                               extra_headers={
                                                   'Authorization': 'Basic ' + b64},
                                               ssl=self.ssl_ctx)

        async def stomp_connect(self, hostname):
            #print('STOMP CONNECT host=' + hostname)
            frame = StompFrame()
            frame.set_command("CONNECT")
            frame.set_header('accept-version', '1.2')
            frame.set_header('host', hostname)
            out = StringIO()
            frame.write(out)
            await self.ws.send(out.getvalue().encode('utf-8'))

        async def stomp_subscribe(self, topic):
            #print('STOMP SUBSCRIBE topic=' + topic)
            frame = StompFrame()
            frame.set_command("SUBSCRIBE")
            frame.set_header('destination', topic)
            frame.set_header('id', 'my-id')
            out = StringIO()
            frame.write(out)
            await self.ws.send(out.getvalue().encode('utf-8'))

        async def stomp_send(self, topic, message):
            #print('STOMP SEND topic=' + topic)
            frame = StompFrame()
            frame.set_command("SEND")
            frame.set_header('destination', topic)
            frame.set_header('content-length', str(len(message)))
            frame.set_content(message)
            out = StringIO()
            frame.write(out)
            await self.ws.send(out.getvalue().encode('utf-8'))

        # only returns for MESSAGE
        async def stomp_read_message(self):
            while True:
                message = await self.ws.recv()
                s_in = StringIO(message.decode('utf-8'))
                stomp = StompFrame.parse(s_in)
                if stomp.get_command() == 'MESSAGE':
                    return stomp.get_content()
                elif stomp.get_command() == 'CONNECTED':
                    version = stomp.get_header('version')
                    print('STOMP CONNECTED version=' + version)
                elif stomp.get_command() == 'RECEIPT':
                    receipt = stomp.get_header('receipt-id')
                    print('STOMP RECEIPT id=' + receipt)
                elif stomp.get_command() == 'ERROR':
                    print('STOMP ERROR content=' + stomp.get_content())

        async def stomp_disconnect(self, receipt=None):
            #print('STOMP DISCONNECT receipt=' + receipt)
            frame = StompFrame()
            frame.set_command("DISCONNECT")
            if receipt is not None:
                frame.set_header('receipt', receipt)
            out = StringIO()
            frame.write(out)
            await self.ws.send(out.getvalue().encode('utf-8'))

        async def disconnect(self):
            await self.ws.close()

        def is_open(self):
            return self.ws.open

    def http_request(url, method, params={}, data=None, secret=None, cert=None):

        proxies = {
            "http": None,
            "https": None
        }

        if secret:
            b64 = base64.b64encode((NODENAME + ':' + secret).encode()).decode()
            DEFAULT_HEADERS['Authorization'] = 'Basic %s' % b64
        try:
            response = requests.request(method, url, headers=DEFAULT_HEADERS, data=data,
                params=params, cert=cert, verify=False, proxies=proxies)#proxies=urllib.request.getproxies())
        except Exception as e:
            err_msg = f'Failed to connect to ISE Server - {e}'
            raise requests.exceptions.ConnectionError(err_msg)

        # item already exists or 401, no need to raise an exception.
        if response.status_code == 401 or response.status_code == 409 or 'Policy exists' in response.text:
            return None

        if response.status_code not in {200, 201, 202, 204}:
            err_msg = f'Error in API call to ISE pxGrid {url} {secret} [{response.status_code}] - {response.reason} - {response.text}'
            raise Exception(err_msg)

        try:
            response = response.json()
        except ValueError:
            err_msg = f'Failed to parse ouput for API call {url}'
            raise ValueError(err_msg)
        return response


    def register_service(name, properties):
        data = {
            "name": name,
            "properties": properties
        }
        data = json.dumps(data)
        url = BASE_URL + ":8910/pxgrid/control/ServiceRegister"
        response = http_request(url, 'POST', data=data, secret=PXGRID_PASSWORD, cert=PXGRID_CERT)
        return response

    def reregister_service(id):
        data = {
            "id": id,
        }
        data = json.dumps(data)
        url = BASE_URL + ":8910/pxgrid/control/ServiceReregister"
        http_request(url, 'POST', data=data, secret=PXGRID_PASSWORD, cert=PXGRID_CERT)

    def unregister_service(service_id):
        data = {
            "id": service_id
        }
        data = json.dumps(data)
        url = BASE_URL + ":8910/pxgrid/control/ServiceUnregister"
        http_request(url, 'POST', data=data, secret=PXGRID_PASSWORD, cert=PXGRID_CERT)

    def service_lookup(name):
        data = '{"name":"%s"}' % name
        url = BASE_URL + ":8910/pxgrid/control/ServiceLookup"
        response = http_request(url, 'POST', data=data, secret=PXGRID_PASSWORD, cert=PXGRID_CERT)
        return response['services'][0]

    def get_access_secret(peerNodeName):
        data = '{"peerNodeName":"%s"}' % peerNodeName
        url = BASE_URL + ":8910/pxgrid/control/AccessSecret"
        response = http_request(url, 'POST', data=data, secret=PXGRID_PASSWORD, cert=PXGRID_CERT)
        return response['secret']

    def account_create():
        global PXGRID_PASSWORD
        data = {
            "nodeName": NODENAME
        }
        data = json.dumps(data)
        url = BASE_URL + ":8910/pxgrid/control/AccountCreate"
        response = http_request(url, 'POST', data=data)
        if response is None:
            raise Exception("Account already exists, delete existing account and try again")
        demisto.setIntegrationContext(response)
        PXGRID_PASSWORD = response['password']

    def create_anc_policy(name, actions, secret):
        data = {
            "name": name,
            "actions": [actions]
        }
        data = json.dumps(data)
        url = BASE_URL + ":8910/pxgrid/ise/config/anc/createPolicy"
        http_request(url, 'POST', data=data, secret=secret)

    async def send_data_over_wss(node, ws_url, secret, pubsub_node, topic, asset_topic_list):
        context = ssl.SSLContext(ssl.PROTOCOL_TLSv1_2)
        ws = WebSocketStomp(ws_url, node, secret, context)
        await ws.connect()
        await ws.stomp_connect(pubsub_node)

        for asset_topic in asset_topic_list:
            # backup the custom attributes
            custom_attributes = asset_topic["asset"]['assetCustomAttributes']
            dummy_attributes = [{
                "value": "ZingboxUpdate",
                "key": "ZingboxProfile"
            }]

            asset_topic["asset"]["assetCustomAttributes"] = dummy_attributes
            await ws.stomp_send(topic, json.dumps(asset_topic))
            time.sleep(0.5)
            asset_topic["asset"]["assetCustomAttributes"] = custom_attributes
            await ws.stomp_send(topic, json.dumps(asset_topic))
            #time.sleep(1)

        await ws.stomp_disconnect('123')
        await asyncio.sleep(3)
        await ws.disconnect()

    def reRegister_task(service_id, delay):
        t = threading.currentThread()
        while getattr(t, "reregister_run", True):
            reregister_service(service_id)
            time.sleep(delay/1000)


    def update_endpoint_custom_attributes(args):
        account_activatication_status()
        if ACCOUNT_STATUS != 'ENABLED':
            raise Exception("pxGrid account not enabled. Please run pxGrid Account Status job and enable account")
        asset_topic_list = args.get('assetTopicList')
        asset_topic_list = json.loads(asset_topic_list)

        # Register to service com.cisco.endpoint.asset
        service_properties = {
            "wsPubsubService": "com.cisco.ise.pubsub",
            "assetTopic": "/topic/com.cisco.endpoint.asset"
        }
        service = register_service("com.cisco.endpoint.asset", service_properties)
        service_id = service['id']
        reregister_time_ms = service['reregisterTimeMillis']
        demisto.results(service_id)
        demisto.results(reregister_time_ms)

        # start thread to periodically
        t = threading.Thread(target=reRegister_task, args=(service_id, reregister_time_ms))
        t.start()

        # Look up pubsub service
        pubsub_service = service_lookup("com.cisco.ise.pubsub")

        pubsub_node_name = pubsub_service['nodeName']
        topic = service_properties['assetTopic']
        ws_url = pubsub_service['properties']['wsUrl']

        # Get access secret
        secret = get_access_secret(pubsub_node_name)

        # in case dns is not configured or ws_url can not be resolved:
        # This is safe even if BASE_URL is a fqdn
        ip = urlparse(BASE_URL).netloc
        host_and_port = urlparse(ws_url).netloc
        host = host_and_port.split(':')[0]
        resolved_ws_url = ws_url.replace(host, ip)

        #demisto.results(resolved_ws_url)
        demisto.results(NODENAME)
        demisto.results(secret)
        demisto.results(pubsub_node_name)

        loop = asyncio.get_event_loop()

        subscribe_task = asyncio.ensure_future(send_data_over_wss(NODENAME, resolved_ws_url, secret,
                                                                pubsub_node_name, topic, asset_topic_list))

        loop.add_signal_handler(signal.SIGINT, subscribe_task.cancel)
        loop.add_signal_handler(signal.SIGTERM, subscribe_task.cancel)

        # Event loop
        loop.run_until_complete(subscribe_task)

        # Un-register to service com.cisco.endpoint.asset
        unregister_service(service_id)

        t.reregister_run = False

        op_data = {}
        op_data["Status"] = "Successfully sent %d devices to Cisco ISE" % len(asset_topic_list)
        return CommandResults(
            readable_output=tableToMarkdown("Asset export summary:", op_data, removeNull=True),
        )

    def quarantine_device_by_mac(args):
        account_activatication_status()
        if ACCOUNT_STATUS != 'ENABLED':
            raise Exception("pxGrid account not enabled. Please run pxGrid Account Status job and enable account")

        mac = args.get('mac_address')
        action = args.get('action')
        policy_name = "panw_iot_quarantine_anc_policy"
        quarantine_action_map = {
            "quarantine" : "applyEndpointByMacAddress",
            "unquarantine" : "clearEndpointByMacAddress"
        }

        # Look up anc service
        anc_service = service_lookup("com.cisco.ise.config.anc")
        anc_node_name = anc_service['nodeName']

        # Get access Secret
        secret = get_access_secret(anc_node_name)

        # Create ANC policy
        create_anc_policy(policy_name, "QUARANTINE", secret)

        data = {
            "policyName": policy_name,
            "macAddress": mac
        }
        data = json.dumps(data)

        url = BASE_URL + ":8910/pxgrid/ise/config/anc/%s" % quarantine_action_map[action]
        http_request(url, 'POST', data=data, secret=secret)

        return CommandResults(
            readable_output= "Successfully performed %s action on %s" % (action, mac)
        )

    def account_activatication_status():
        global BASE_URL
        global ACCOUNT_STATUS
        global PXGRID_PASSWORD
        if BASE_URL[-1] == '/':
            BASE_URL = BASE_URL[:-1]

        # check integration cache for password based account
        if PASSWORD_ACCOUNT:
            cache = False
            if PXGRID_PASSWORD is None:
                account = demisto.getIntegrationContext()
                if account == None or account == {}:
                    account_create()
                else:
                    cache = True
                    PXGRID_PASSWORD = account['password']

            url = BASE_URL + ":8910/pxgrid/control/AccountActivate"
            response = http_request(url=url, method='POST', data='{}', secret=PXGRID_PASSWORD)
            if response is None and cache:
                time.sleep(2)
                demisto.setIntegrationContext({})
                account_create()
                response = http_request(url=url, method='POST', data='{}', secret=PXGRID_PASSWORD)
            ACCOUNT_STATUS = response['accountState']
        elif CERT_ACCOUNT:
            cert_activation_status()
        else:
            raise Exception("Please select password based account creation or add Cert credentials")

    def pxgrid_get_account_status():
        account_activatication_status()
        op_data = {}
        op_data['Account Name'] = NODENAME
        op_data['Account Status'] = ACCOUNT_STATUS
        #op_data['Password'] = PXGRID_PASSWORD

        return CommandResults(
            readable_output=tableToMarkdown("pxGrid Account Summary:", op_data, removeNull=True),
        )

    def cert_activation_status():
        #proxies = urllib.request.getproxies()
        #raise Exception(proxies)
        global BASE_URL
        global ACCOUNT_STATUS
        global PXGRID_CERT
        if BASE_URL[-1] == '/':
            BASE_URL = BASE_URL[:-1]

        #CERT_AUTH = demisto.params().get('cert', {})
        #USERNAME = CERT_AUTH.get('identifier')
        cert_str = CERT_AUTH['credentials']['sshkey']
        key_str = CERT_AUTH['credentials']['password']

        if "BEGIN RSA PRIVATE KEY" in key_str:
            start = "-----BEGIN RSA PRIVATE KEY-----"
            end = "-----END RSA PRIVATE KEY-----"
        elif "BEGIN PRIVATE KEY" in key_str:
            start = "-----BEGIN PRIVATE KEY-----"
            end = "-----END PRIVATE KEY-----"

        try:
            key = key_str.split(start)[1].split(end)[0]
            key = key.replace(' ', '\n')
            key_str = start + key + end
        except:
            pass

        # demisto.results(cert_str)
        # demisto.results(key_str)

        client_cert_file = tempfile.NamedTemporaryFile(delete=False, mode='w')
        client_cert_file.write(cert_str)
        client_cert_file.flush()
        os.chmod(client_cert_file.name, stat.S_IRWXU| stat.S_IRWXG| stat.S_IRWXO)

        client_key_file = tempfile.NamedTemporaryFile(delete=False, mode='w')
        client_key_file.write(key_str)
        client_key_file.flush()
        os.chmod(client_key_file.name, stat.S_IRWXU| stat.S_IRWXG| stat.S_IRWXO)

        cert = (client_cert_file.name, client_key_file.name)
        # demisto.results(client_cert_file.name)
        # demisto.results(client_key_file.name)

        cert = (client_cert_file.name, client_key_file.name)

        url = BASE_URL + ":8910/pxgrid/control/AccountActivate"
        response = http_request(url=url, method='POST', data='{}', secret="notNeeded", cert=cert)
        PXGRID_CERT = cert
        try:
            ACCOUNT_STATUS = response['accountState']
        except:
            raise Exception('Try deleting existing account (%s) first. Response from Cisco ISE : %s' % (NODENAME, response))


    def main():
        LOG('Command being called is %s' % (demisto.command()))
        args = demisto.args()
        try:
            if demisto.command() == 'fetch-credentials':
                fetch_credentials()
            if demisto.command() == 'test-module':
                if PASSWORD_ACCOUNT:
                    raise Exception('For password based account, please run "pxGrid Account Status" Job')
                elif CERT_ACCOUNT:
                    try:
                        cert_activation_status()
                    except Exception as e:
                        demisto.results('Failed to get cert based account status. %s' % e)

                    if ACCOUNT_STATUS == "ENABLED":
                        demisto.results('ok')
                    else:
                        raise Exception('pxGrid STATUS = %s' % ACCOUNT_STATUS)
                else:
                    raise Exception("Please select password based account creation or add Cert credentials")
            elif demisto.command() == 'pxgrid-get-account-status':
                #demisto.setIntegrationContext({})
                return_results(pxgrid_get_account_status())
            elif demisto.command() == 'pxgrid-update-endpoint-custom-attributes':
                #demisto.setIntegrationContext({})
                return_results(update_endpoint_custom_attributes(args))
            elif demisto.command() == 'pxgrid-quarantine-device-by-mac':
                #demisto.setIntegrationContext({})
                return_results(quarantine_device_by_mac(args))


        except Exception as e:
            return_error(str(e))


    # python2 uses __builtin__ python3 uses builtins
    if __name__ == "__builtin__" or __name__ == "builtins":
        main()

    register_module_line('PANW IoT 3rd Party Integration - Cisco ISE pxGrid', 'end', __line__())
  subtype: python3
  type: python
sourcemoduleid: Cisco ISE pxGrid
