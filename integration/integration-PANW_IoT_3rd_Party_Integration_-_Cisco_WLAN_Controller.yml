category: Network Security
commonfields:
  id: PANW IoT 3rd Party Integration - Cisco WLAN Controller
  version: -1
configuration:
- additionalinfo: Cisco WLC IP address or Hostname to access it from integration
  display: Cisco WLC IP or Hostname
  name: cisco_wlc_host
  required: true
  type: 0
- display: Username
  name: credentials
  required: false
  type: 9
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: Cisco WLAN Controller enables connection between Cisco WLC device and
  PANW IoT via XOAR integration
detaileddescription: |-
  ## Cisco WLC integration

  Please configure the instance by providing following details:

  - Name of the instance
  - Cisco WLC IP or Hostname
  - User name for log in
  - Password of the user entered above.

  ## Test Configuration

  After providing the mandatory details, please test the configuration using the Test button.
display: PANW IoT 3rd Party Integration - Cisco WLAN Controller
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEkAAAAyCAYAAAAQlvbeAAAGx0lEQVR42u1Za2xURRTeOzPbYikPeWgRWx7y8JXwQ/3HDw2JxldMBDXGBIhiFF+AihDFhJDwA8KjElhLd/c+lkIRQhtRjPKIKIokCshD9s7c3S0FSgVFnilQlPW77ez2lr3VLs0uNt6TnGxzz8ycc78558w3tz5PPPHEE0888cQTTzz5T4lini5jYb6IBPaPy4c/svz4WKYfWqys/mNYtwGJ1tRNZypPUt38nFRxJdf+WDCxnmlmkhqHZ3cbkFgoGmEaT0KPMNUsyKkvwyRMN0WrP3N99wFJM8MSpDhTo7kFSecEfn6R/tZ4IHU3kJSTF4uZJl6hmrgvG5AUPT6QRaJTybLfR2bVnCPx4SitqUr5uZJsQKJqbAyLiFd9FaJP/pvzuvgc9Bs7sDqqix6dBQnAaraNquL7rPxFxJbWwyBe3VmQaFXMz3TBW2xBMT//JRU2y2VgJxB8n86DxDdK28Gs/Kn8R9mcv+o0SCrviWdHbZtf4ytzWPOiyL3v8MUysEa8QO8sQKqVtn3u68aKO/C3S877otMgabwIz+olSAF3+mAWdY2kaYeegoMGqlobSDDuzzVIROfT7MwkRnRmzkHad4rSDXVrWMg8Tqri47uSRZp0ftFviJJcg0Q1sd22Uc36IdcgsUqzH1rGOTlP78JRzivlImcKInkASRWbZVPfnnOQNN4P+pucF+wC3Td1uUhTgSEGXWNbJm2nsCPZgLRJNuBoZibx1kwK8Z0uIO2xbSiPrVk0bhukxhaQVB5yAemsbUPFXH8m0W3HJiNLLlJd7FAisUKnjXzZ+BzAuUxXWZuU2nraWZBomM9kutlMVyYqM/yFjsxj4egVUlu/IMMWjn4Ef1fop/UfdhYkpcok1OA1eN5MDGtyO9ta4YdtK2yX6MfRKV3jQ4Y1mEbMm9zvaKKUVNcVuJDJVC9L4KUz7dW8jCw9QdyzN1rmSl6D+xVaaWbYALgN0iHpb23GYbDGAhhWqTtB5YXYtNt9+RbZgCta05gnsFsst5fpuMJUgUwy0csso/t8Tyo/PZyFogHyTeOj+fBHIsfHoa8ElKW7R/k88cST/7XQtYlCNOk7QBVGM8O6uf2lNKrYXAXaE3a/+5dFPhDz74IOw0lT9M+XXDGAaeJOrDWE6ryg43Exmx+NxPgRYO89bhg4RKvrhWa5iBnCZrR/Qq9CT0Ofd1CBUnkLP+nX+evtj/QDJZi/ATZ5NcB8jFUCP5W5nJYPws82x9hmALXbt1IUt4uppqE/C/EVsDdA/5JxHcXYxcRI9M7v6bWsaQBTrT0AwQ74Wp3hAGmYDDQJkGal56+wCA2LzY45l6EXoEkltHd0uxff1jCJhfnVDD8gub6KeN/0mocvDGZVsShT3WICPdCtvT7twoD8lZgki5LSJ1hEvI/fl1AKS/FsggOkoTajlSDNbCsxMVTudJIaYiPIXn/7mgBONUZZuCOdHUq4bjiuP02Ol11HVfNlAPQmSrgSmZQGiYVFbRogne/F70yMm50mmlDMieSnzEL8Njhskrt5hKjWIPeRHYMEBl8GptySYQDsAPrGw3RVLIPV09XxeekX1OILOy59MSoFOjZrD10dK3LY+lKNR+U6l4gaL805SHD0UDrwsFjig2QFkhQarF/NdEdp6LyRRsSsa75+bkyVI0Ac2pEfZNf4tmwTUzLt/N10zFXWI7kHaV18XNqhYS24XpCUJacLmWHOha3e0WeSxDj8hmNDPktlAPpShxlAdfOZdEy6mOTydWF62l6dyP0tgFYfHtLSaFUbpFiMVB/rkz1IzheI+QH2E/JkRPnxXY4MWJgCj0ZiczqMqfLg3ehHV5GNSYD5HQ1y0lZuvDD1mQXaTLTYsPw07gCvcZweaJJiMvQx/D0Lp8jj/wYSCe4rpmHzAezwLZhXzHTrXvSSRll236bHreT3sJB5JU0RjNhyNPonMW8C+th8X6h1g8iGOoWtsbY4Trav4fsFgD8R6+1s62uiJn8UYMeZUpxocTh2pwDtQWqWIL2Xeu7XrFFy7AXoqfRcvCSJ1L/Yrilv+nUGelPShQI0+SqsNgpQe34EaMkxaXfTuBL4uTS/TLs6VoLgNTg/4wjkCnSyA6Qh0n4RIM1oA0nY/On8NS/RQMOJd9x7jvU01tqbOsGkWuBJvdoBqteVoT99kuJcUs9CI0S3Snw3QgDSrfZ/cZnewnIrqc4/AIca4biW9EZfmQZ9G/b7HeD1sjMOWg4NQZeghJ4l4Xp/x9wsOhbj5kKDyKJyGrEm+gIxlkEHDA6gxFsYVwENUFW8hrgG+TzxxBNPPPHEE0888eRGyN8R98jGg6pa+wAAAABJRU5ErkJggg==
name: PANW IoT 3rd Party Integration - Cisco WLAN Controller
script:
  commands:
  - arguments: []
    description: Get Cisco WLC client details
    name: cisco-wlc-get-all-client-details
    outputs:
    - contextPath: cisco-wlc-IoT.devices
      description: Cisco WLAN Controller Devices
      type: string
  - arguments:
    - description: Name of ACL to apply
      name: aclName
      required: true
    - description: ACL content list
      isArray: true
      name: aclContentList
      required: true
    description: Apply ACLs to Cisco WLC devices
    name: cisco-wlc-apply-acl
  - arguments:
    - description: Name of the ACL to check
      name: aclName
      required: true
    description: Check with Cisco WLAN Controller if provided ACL name already exists
      or not
    name: cisco-wlc-is-acl-exists
    outputs:
    - contextPath: cisco-wlc-IoT.is_acl_exists
      description: True if ACL exists in Cisco WLC, False otherwise
      type: boolean
  - arguments:
    - description: Name of ACL to delete from Cisco WLC
      name: aclName
      required: true
    description: Delete existing ACL from Cisco WLAN Controller
    name: cisco-wlc-delete-existing-acl
  - arguments: []
    description: Get all active Bluetooth devices
    name: cisco-wlc-get-all-bluetooth-client-details
    outputs:
    - contextPath: cisco-wlc-IoT.bt-devices
      description: Cisco WLAN Controller Bluetooth Devices
      type: string
  - arguments:
    - description: MAC of the client to fetch the details
      name: macAddress
      required: true
    description: Get client details of provided MAC address
    name: cisco-wlc-get-client-details
    outputs:
    - contextPath: cisco-wlc-IoT.client_data
      description: Connected client data of provided MAC address
      type: string
  - arguments:
    - name: command
      required: true
    description: Executes the Cisco WLC Controller commands
    name: cisco-wlc-execute-command
  - arguments: []
    description: Get all active APs
    name: cisco-wlc-get-all-aps
  dockerimage: demisto/netmiko:1.0.0.23064
  runonce: false
  script: |
    register_module_line('PANW IoT 3rd Party Integration - Cisco WLAN Controller', 'start', __line__())


    import re
    import datetime
    import json
    import collections
    import os
    import sys
    from time import gmtime, strftime

    # Netmiko is the same as ConnectHandler
    from netmiko import ConnectHandler
    import time

    # We will support two versions of the OS on Cisco WLC, each with differing outputs.
    class CiscoCatalystParser:

        def __init__(self,net_connect):
            self.system_name, self.cisco_wlc_os = self.wlc_cisco_get_sysinfo(net_connect)

        def wlc_cisco_get_wlan_summary(self,net_connect, evt_content):
            """ Gets the information regarding WLAN.

            summary information about Wlans include total number of wlans.

            :param net_connect: ssh connection handler to device
            :param evt_content: event content dictionary holding the data format
            :return: void
            """

            try:
                cmd = "show wlan summary"
                output = net_connect.send_command_timing(cmd)
                lines = output.split("\n")
                for line in lines:
                    if not line:
                        continue
                    if 'Number of WLANs' in line:
                        parts = line.split('Number of WLANs')
                        for part in parts:
                            if not part:
                                continue
                            part = part.replace(':', '')
                            part = part.strip()
                            evt_content["totalWlans"] = int(part)
                            break
            except Exception as ex:
                demisto.error(f'Exception when getting WLAN summary: {str(ex)}')
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format when getting WLAN summary from WLC '+(self.cisco_wlc_os))

        def wlc_cisco_get_ap_summary(self,net_connect, evt_content, read_only, pagination_enabled,ap_pattern=""):
            """ Gets the access points summary information from the CLI

            :param net_connect: ssh connection handler to device
            :param evt_content: event content dictionary holding the data format
            :param read_only: boolean flag stating read/write permission for the user for that device
            :param pagination_enabled: boolean flag if the pagination is enabled or not.
            :param ap_pattern: pattern for names of ap to fetch summary. It can be just name of the AP or wildcard also.
            :return: void
            """

            try:
                ap_info = collections.defaultdict(dict)
                cmd = "show ap summary"
                output = net_connect.send_command_timing(cmd)

                lines = output.split("\n")
                for line in lines:
                    if not line:
                        continue

                    if 'Number of APs' in line:
                        parts = line.split('Number of APs')
                        for part in parts:
                            if not part:
                                continue
                            part = part.replace(':', '')
                            part = part.strip()
                            evt_content["totalAPs"] = int(part)
                            break

                if evt_content["totalAPs"] < 1:
                    demisto.info("wlc_info no APs found")
                    return

                access_points = int(part)
                if access_points <= 6 or not pagination_enabled:
                    pass
                else:
                    net_connect.send_command_timing('')
                    output = net_connect.send_command_timing(cmd)
                    while True:
                        output_append = net_connect.send_command_timing("y")
                        if 'Incorrect usage' in output_append or  'Invalid input' in output_append or 'Unknown command' in output_append:
                            break
                        if not output_append:
                            break
                        output += output_append

                ap_name = ''
                slots = 0
                ap_model = ''
                ethernet_mac = ''
                radio_mac = ''
                location = ''
                country = ''
                ip_address = ''
                state = ''
                number_of_clients = 0

                lines = output.split("\n")

                idx = 0
                for i in range(len(lines)):
                    if "Ethernet MAC" in lines[i]:
                        idx = i
                        break
                lines = lines[idx + 2:]

                for line in lines:
                    ip_idx = 0

                    #if more than 1000 APs --More-- gets appended to the AP list
                    if "--More--" in line:
                        line = line.replace("--More--","").lstrip()

                    parts = line.split(' ')
                    if len(ap_pattern) > 0 and ap_pattern not in line:
                        continue
                    cleaned_parts = []
                    for part in parts:
                        if not part:
                            continue
                        if '[' in part:
                            break
                        cleaned_parts.append(part)
                        if re.search('\d+\.\d+\.\d+\.\d+', part):
                            ip_idx = len(cleaned_parts) - 1

                    ps = re.search('\d+\.\d+\.\d+\.\d+', line)
                    if ps:
                        ap_name = cleaned_parts[0]
                        slots = cleaned_parts[1]
                        ap_model = cleaned_parts[2]
                        ethernet_mac = self.correct_mac_address(cleaned_parts[3])
                        radio_mac = self.correct_mac_address(cleaned_parts[4])
                        location = cleaned_parts[5:ip_idx-1]
                        country = cleaned_parts[ip_idx-1]
                        ip_address = cleaned_parts[ip_idx]
                        state = cleaned_parts[ip_idx+1]
                        # number_of_clients = int(cleaned_parts[i + 1])     # No clients in new server

                    ap_info[ap_name]["apName"] = ap_name
                    ap_info[ap_name]["slots"] = slots
                    ap_info[ap_name]["apModel"] = ap_model
                    ap_info[ap_name]["ethernetMAC"] = ethernet_mac
                    ap_info[ap_name]["radioMAC"] = radio_mac
                    ap_info[ap_name]["location"] = ' '.join(location)
                    ap_info[ap_name]["country"] = country
                    ap_info[ap_name]["apIPAddress"] = ip_address
                    ap_info[ap_name]["state"] = state
                    ap_info[ap_name]["numberOfClients"] = number_of_clients     # defaults to '0'
                    ap_info[ap_name]["client_list"] = []

                evt_content['ap_list'] = []
                for key in sorted(ap_info):
                    dic = {key: ap_info[key]}
                    evt_content['ap_list'].append(dic)
            except Exception as ex:
                demisto.error(f'Exception when getting AP summary: {str(ex)}')
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format when getting AP summary from WLC '+(self.cisco_wlc_os))

        def wlc_cisco_get_client_summary(self,net_connect, evt_content, read_only, pagination_enabled):
            """ Gets the information about all clients connected to access points.

            :param net_connect: ssh connection handler to device
            :param evt_content: event content dictionary holding the data format
            :param read_only: boolean flag stating read/write permission for the user for that device
            :param pagination_enabled: boolean flag if the pagination is enabled or not.
            :return: void
            """
            try:
                cmd = "show wireless client summary"
                output_old = net_connect.send_command_timing(cmd)
                lines = output_old.split("\n")
                for line in lines:
                    if 'Number of Clients' in line:
                        parts = line.split('Number of Clients')
                        for part in parts:
                            if not part or part.strip() == '':
                                continue
                            part = part.replace(':', '')
                            part = part.strip()
                            evt_content["totalClients"] = int(part)
                            break

                if evt_content["totalClients"] < 1:
                    demisto.info("no clients found")
                    return

                clients = int(part)
                if clients <= 6 or not pagination_enabled:
                    output = output_old
                else:
                    net_connect.send_command_timing('')
                    output = net_connect.send_command_timing(cmd)
                    while True:
                        output_append = net_connect.send_command_timing("y")
                        if 'Incorrect usage' in output_append or  'Invalid input' in output_append or 'Unknown command' in output_append:
                            break
                        if not output_append:
                            break
                        output += output_append

                lines = output.split("\n")

                # Filtering the output so that initial markup lines for 'show client summary'
                # are filtered
                filter_idx = 0
                for line_idx in range(len(lines)):
                    if "MAC Address" in lines[line_idx]:
                        filter_idx = line_idx
                        break

                lines = lines[filter_idx + 2:]
                for line in lines:
                    if 'Number of Excluded Clients' in line:
                        break
                    client_info = {}
                    mac_address = ''
                    ap_name = ''
                    ap_type = ''
                    wlan_id = ''
                    state = ''
                    protocol = ''
                    method = ''
                    role = ''

                    if not line:
                        continue

                    ps = re.search('(\w+\.\w+\.\w+)', line)
                    if ps:
                        sp_line = line.split(' ')
                        filter_idx = []
                        for val in sp_line:
                            if val not in (None, ''):
                                filter_idx.append(val)
                        mac_address = filter_idx[0]
                        ap_name = filter_idx[1]
                        ap_type = filter_idx[2]
                        wlan_id = filter_idx[3]
                        state = filter_idx[4]
                        protocol = filter_idx[5]
                        method = filter_idx[6]
                        role = filter_idx[7]
                    else:
                        continue

                    valid_mac_address = self.correct_mac_address(mac_address)
                    if not UtilityClass.is_valid_mac_address(valid_mac_address):
                        continue
                    client_info['macAddress'] = valid_mac_address
                    client_info["apType"] = ap_type
                    client_info["wlanId"] = wlan_id
                    client_info["state"] = state
                    client_info["radio"] = protocol
                    client_info["port"] = '0'
                    # if 'method' has value then authenticated = yes
                    client_info["authenticated"] = 'no' if method in [None,'None'] else 'yes'
                    client_info["role"] = role

                    client_info = self.wlc_cisco_get_client_details(net_connect, client_info, read_only, pagination_enabled)

                    ap_list = evt_content['ap_list']
                    del evt_content['ap_list']
                    for ap in ap_list:
                        if ap_name in ap:
                            ap[ap_name]['client_list'].append(client_info)

                    evt_content['ap_list'] = ap_list

                ap_list = evt_content['ap_list']
                del evt_content['ap_list']
                for ap in ap_list:
                    for ap_nm in ap:
                        ap[ap_nm]['numberOfClients'] = len( ap[ap_nm]['client_list'] )
                evt_content['ap_list'] = ap_list
            except Exception as ex:
                demisto.error(f'Exception when getting client summary: {str(ex)}')
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format when getting client summary from WLC '+(self.cisco_wlc_os))

        def wlc_cisco_get_bt_client_summary(self,net_connect, evt_content, read_only, pagination_enabled):
            '''
                Traverse through all the available access points and fetch bluetooth devices associated with it.
                :param net_connect: ssh connection handler to device
                :param evt_content: event content dictionary holding the data format
                :param read_only: boolean flag stating read/write permission for the user for that device
                :param pagination_enabled: boolean flag if the pagination is enabled or not.
                :return: void
            '''
            try:
                ap_list = evt_content["ap_list"]
                cmd = "show ap dot11 24ghz cleanair device type all"
                if pagination_enabled:
                    try:
                        net_connect.send_command_timing('\n')
                        detail_output = net_connect.send_command_w_enter(cmd)
                    except Exception as es:
                        demisto.error('wlc_info caught exception get_client_details' + str(es))
                        raise Exception('wlc_info caught exception get_client_details for %s. Error - %s' % (self.cisco_wlc_os, str(es)))

                    while True:
                        output_append = net_connect.send_command_timing("y")
                        if 'Incorrect usage' in output_append or  'Invalid input' in output_append or 'Unknown command' in output_append:
                            break
                        if not output_append:
                            break
                        detail_output += output_append
                else:
                    detail_output = net_connect.send_command_w_enter(cmd)

                # demisto.log("BT-clients:\n\t\tcommand: {}\n\t\t output: {}".format(cmd, detail_output))

                lines = detail_output.split("\n")
                # traversing through output and merging all the client's info
                line_index = 0
                version = None
                while line_index < len(lines):
                    line = lines[line_index]
                    if 'ClusterID' in line:
                        if 'AP Type' in line:
                            version = 1
                        else:
                            version = 2
                        line_index += 2
                        break
                    line_index += 1

                for access_point in ap_list:
                    for key in access_point:
                        access_point[key]['client_list'] = []
                        for l_index in range(line_index,len(lines)):
                            if key.lower() not in lines[l_index]:
                                continue
                            filter_data = []
                            sp_arr = lines[l_index].split(" ")
                            for idx in sp_arr:
                                if idx not in (None, ''):
                                    filter_data.append(idx)
                            if filter_data not in (None, []):
                                parsed_data = {}
                                valid_mac_address = self.correct_mac_address(str(filter_data[1]).strip())
                                if not UtilityClass.is_valid_mac_address(valid_mac_address):
                                    continue
                                parsed_data["macAddress"] = valid_mac_address
                                parsed_data["devID"] = str(filter_data[2]).strip()
                                parsed_data["bluetoothType"] = str(filter_data[3].strip()+" "+filter_data[4].strip())
                                parsed_data["connectionState"] = "Yes"
                                parsed_data["connectedDuration"] = "0s"
                                if version == 1:
                                    if len(filter_data) == 11:
                                        parsed_data["apType"] = str(filter_data[5]).strip()
                                        parsed_data["apName"] = str(filter_data[6]).strip()
                                        parsed_data["isi"] = str(filter_data[7]).strip()
                                        parsed_data["rssi"] = str(filter_data[8]).strip()
                                        parsed_data["dc"] = str(filter_data[9]).strip()
                                        parsed_data["channel"] = str(filter_data[10]).strip()
                                    else:
                                        parsed_data["bluetoothType"] = str(filter_data[3]).strip()
                                        parsed_data["apType"] = str(filter_data[4]).strip()
                                        parsed_data["apName"] = str(filter_data[5]).strip()
                                        parsed_data["isi"] = str(filter_data[6]).strip()
                                        parsed_data["rssi"] = str(filter_data[7]).strip()
                                        parsed_data["dc"] = str(filter_data[8]).strip()
                                        parsed_data["channel"] = ""
                                elif version == 2:
                                    parsed_data["apName"] = str(filter_data[5]).strip()
                                    parsed_data["isi"] = str(filter_data[6]).strip()
                                    parsed_data["rssi"] = str(filter_data[7]).strip()
                                    parsed_data["dc"] = str(filter_data[8]).strip()
                                    parsed_data["channel"] = str(filter_data[9]).strip()

                                # adding device data to the client list
                                access_point[key]['client_list'].append(parsed_data)

                        # updating number of client with the len of discovered devices
                        access_point[key]["numberOfClients"] = 0
                        access_point[key]["numberOfClients"] = len(access_point[key]['client_list'])
            except Exception as ex:
                demisto.error(f'Exception when getting bluetooth client summary: {str(ex)}')
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format when getting bluetooth client summary from WLC '+(self.cisco_wlc_os))

        def wlc_cisco_get_sysinfo(self,net_connect):
            system_name = ''
            cisco_wlc_os = "Cisco IOS XE"
            try:
                output = net_connect.send_command_timing('show version')
                if 'Incorrect usage' in output or  'Invalid input' in output or 'Unknown command' in output:
                    raise Exception("Exception while running show version command for %s. %s" % (cisco_wlc_os, str(output)))
                elif output not in [None, '']:
                    for line in output.split('\n'):
                        if 'uptime is' in line:
                            system_name = line.split('uptime is')[0].strip()
                        elif re.search(".*Cisco IOS XE.*Version.*", line):
                            cisco_wlc_os = line
                return system_name, cisco_wlc_os
            except Exception as ex:
                demisto.error(f'Exception when getting sysinfo: {str(ex)}')
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format when getting sysinfo from WLC version '+str(cisco_wlc_os))

        def wlc_cisco_get_client_summary_from_mac(self,net_connect, client_data, read_only, pagination_enabled, client_mac_address):
            """ Gets the information about all clients connected to access points.

            :param net_connect: ssh connection handler to device
            :param client_data: data of the client
            :param read_only: boolean flag stating read/write permission for the user for that device
            :param pagination_enabled: boolean flag if the pagination is enabled or not.
            :return: void
            """
            try:
                cmd = "show wireless client summary"
                if pagination_enabled:
                    net_connect.send_command_timing('')
                    output = net_connect.send_command_w_enter(cmd)
                    while True:
                        output_append = net_connect.send_command_timing("y")
                        if 'Incorrect usage' in output_append or  'Invalid input' in output_append or 'Unknown command' in output_append:
                            break
                        if not output_append:
                            break
                        output += output_append
                else:
                    output = net_connect.send_command_w_enter(cmd)

                lines = output.split("\n")
                client_mac_address = self.get_original_mac_address(client_mac_address)
                for line in lines:
                    if "lines matching the pattern" in line:
                        continue
                    if client_mac_address not in line:
                        continue
                    if not line:
                        continue

                    sp_line = line.split(' ')
                    filter_idx = []
                    for val in sp_line:
                        if val not in (None, ''):
                            filter_idx.append(val)

                    valid_mac_address = self.correct_mac_address(filter_idx[0])
                    if not UtilityClass.is_valid_mac_address(valid_mac_address):
                        continue
                    client_data["macAddress"] = valid_mac_address
                    client_data["apName"] = filter_idx[1]
                    client_data["apType"] = filter_idx[2]
                    client_data["wlanId"] = filter_idx[3]
                    client_data["state"] = filter_idx[4]
                    client_data["radio"] = filter_idx[5]
                    client_data["port"] = '0'
                    # if 'method' has value then authenticated = yes
                    client_data["authenticated"] = 'no' if filter_idx[6] in [None,'None'] else 'yes'
                    client_data["role"] = filter_idx[7]
                    client_data = self.wlc_cisco_get_client_details(net_connect, client_data, read_only, pagination_enabled)
                    break
            except Exception as ex:
                demisto.error(f'Exception when getting client summary from MAC: {str(ex)}')
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format when getting client summary from MAC for WLC '+(self.cisco_wlc_os))

        def wlc_cisco_get_client_details(self, net_connect, client_info, read_only, pagination_enabled):
            """ Gets the client detailed information.

            details of a client include SSID, authentication mechanism,
            RSSI (radio signal strength) and SNR (noise ratio).

            :param net_connect: ssh connection handler to device
            :param client_info: client summary dictionary retrieved from cli
            :param read_only: boolean flag stating read/write permission for the user for that device
            :param pagination_enabled: boolean flag if the pagination is enabled or not.
            :return: client_info filled up with the details.
            """
            cmd = "show wireless client mac-address {} detail ".format(self.get_original_mac_address(str(client_info["macAddress"])))
            if pagination_enabled:
                try:
                    net_connect.send_command_timing('\n')
                    detail_output = net_connect.send_command_timing(cmd, strip_prompt=False)
                except Exception as es:
                    demisto.error('wlc_info caught exception get_client_details' + str(es))
                    raise Exception("Exception while running %s command for %s. %s" % (str(cmd), self.cisco_wlc_os, str(es)))
                while True:
                    output_append = net_connect.send_command_timing("y")
                    if 'Incorrect usage' in output_append or  'Invalid input' in output_append or 'Unknown command' in output_append:
                        break
                    if not output_append:
                        break
                    detail_output += output_append
                    if 'Nearby AP Statistics' in output_append:
                        break
            else:
                detail_output = net_connect.send_command_timing(cmd)

            detail_lines = detail_output.split('\n')
            # client details fields
            ssid = ''
            connected_duration = '0'
            ip_address = ''
            authentication_algorithm = ''
            encryption_cipher = ''
            rssi = ''
            snr = ''
            policy = ''
            ap_protocol = ''
            client_state = ''

            for each_line in detail_lines:
                if not each_line:
                    continue

                ps_ssid = re.search('(Wireless LAN Network Name \(SSID\):)\s([\w-]+)', each_line)
                if ps_ssid:
                    ssid = str(ps_ssid.group(2))

                ps_connected_duration = re.search('(Connected For :)\s(\d+)\sseconds', each_line)
                if ps_connected_duration:
                    connected_duration = str(ps_connected_duration.group(2))

                ps_ip_address = re.search('(Client IPv4 Address :)\s(\d+\.\d+\.\d+\.\d+)', each_line)
                if ps_ip_address:
                    ip_address = str(ps_ip_address.group(2))

                if 'Authentication Key Management' in each_line:
                    parts = each_line.split('Authentication Key Management :')
                    for part in parts:
                        if not part:
                            continue
                        part = part.strip()
                        authentication_algorithm = part

                if 'Encryption Cipher' in each_line:
                    parts = each_line.split('Encryption Cipher :')
                    for part in parts:
                        if not part:
                            continue
                        part = part.strip()
                        encryption_cipher = part

                if 'Policy Type' in each_line:
                    parts = each_line.split('Policy Type :')
                    for part in parts:
                        if not part:
                            continue
                        part = part.strip()
                        policy = part
                if 'Protocol :' in each_line:
                    parts = each_line.split('Protocol :')
                    for part in parts:
                        if not part:
                            continue
                        part = part.strip()
                        ap_protocol = part

                if 'Radio Signal Strength Indicator' in each_line:
                    parts = each_line.split('Radio Signal Strength Indicator :')
                    for part in parts:
                        if not part:
                            continue
                        part = part.strip()
                        rssi = part

                if 'Signal to Noise Ratio' in each_line:
                    parts = each_line.split('Signal to Noise Ratio :')
                    for part in parts:
                        if not part:
                            continue
                        part = part.strip()
                        snr = part

                if 'Client State' in each_line:
                    parts = each_line.split('Client State :')
                    for part in parts:
                        if not part:
                            continue
                        part = part.strip()
                        client_state = part

            client_info['radio'] = ap_protocol
            client_info["SSID"] = ssid
            client_info["connectedDuration"] = connected_duration
            client_info['ipAddress'] = ip_address
            client_info['encryptionCipher'] = str(encryption_cipher)
            auth_method = str(policy) + ' ' + str(authentication_algorithm)
            client_info['authMethod'] = auth_method.strip()
            client_info['rssi'] = rssi
            client_info['snr'] = snr
            client_info['clientState'] = client_state
            return client_info

        def correct_mac_address(self, mac_address):
            if len(mac_address) > 0 and  mac_address.count(':') == 0:
                return mac_address[0:2] +':'+ mac_address[2:4] +':'+ mac_address[5:7] +':'+ mac_address[7:9] +':'+ mac_address[10:12] +':'+ mac_address[12:14]
            else:
                return mac_address

        def get_original_mac_address(self, mac_address):
            if len(mac_address) > 0 and  mac_address.count('.') == 0:
                return mac_address[0:2] + mac_address[3:5] +'.'+ mac_address[6:8] + mac_address[9:11] +'.'+ mac_address[12:14] + mac_address[15:17]
            else:
                return mac_address

        def cisco_wlc_apply_acl(self, net_connect, acl_name, acl_content_list=[]):
            '''
                Applies ACL by connecting to cisco wlc
            '''
            if not acl_name or len(acl_name) == 0:
                raise Exception("Missing aclName in command")
            if not acl_content_list or len(acl_content_list) == 0:
                raise Exception("No acl rule found while applying '{}' acl".format(str(acl_name)))

            cmd = 'config t'
            cmdNxt = 'ip access-list extended {}'.format(acl_name)
            net_connect.send_command_timing('')

            if len(acl_content_list) <= 64:
                try:
                    output = net_connect.send_command_w_enter(cmd)
                    if 'Incorrect usage' in output or  'Invalid input' in output :
                        raise Exception('Unsupported format for'+(self.cisco_wlc_os))
                    output = net_connect.send_command_w_enter(cmdNxt)
                    if 'Incorrect usage' in output or 'Invalid input' in output :
                        raise Exception('Unsupported format for'+(self.cisco_wlc_os))
                    for each in acl_content_list:
                        output = net_connect.send_command_w_enter(each.lower())
                        if 'Incorrect usage' in output or 'Invalid input' in output :
                            raise Exception('Unsupported format : %s for %s' % (each.lower(), self.cisco_wlc_os))
                    output = net_connect.send_command_w_enter('end')
                except Exception as ex:
                    demisto.error(f'Exception while applying  acl: {str(ex)}')
                    demisto.error(traceback.format_exc())
                    raise Exception('Unsupported format while applying %s for %s. %s' % (cmd, self.cisco_wlc_os, str(output)))
                finally:
                    # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
                    demisto.info('wlc_info closing connection')
                    wlc_cleanup(net_connect)
            else:
                wlc_cleanup(net_connect)
                raise Exception('acl list contains more than 64 entries cannot configure on '+str(self.cisco_wlc_os))

            return False


        def check_acl_exists(self, net_connect, acl_name):
            '''
                Check if ACL name already exist in cisco wlc device
            '''
            if len(acl_name) == 0:
                raise ValueError('ACL name is empty.')

            try:
                # 'show running-config | begin ip access' doesnot give first ACL name
                cmd = 'show running-config | begin ip dns server'
                # net_connect.send_command_timing('')
                output = net_connect.send_command_timing(cmd)
                while True:
                    output_append = net_connect.send_command_timing('')
                    if 'Incorrect usage' in output_append or 'Invalid input' in output_append:
                        break
                    if not output_append:
                        break
                    output += output_append

                # creating array from output
                all_lines = output.split("\n")
                # filtering out the lines with actual data
                lines = []
                for i in range(len(all_lines)):
                    if "ip access-list extended" in all_lines[i]:
                        lines.append(all_lines[i])

                for each_line in lines:
                    acl_name_data = re.search('(ip access-list extended)\s([\w-]+)', each_line, re.IGNORECASE)
                    if acl_name_data:
                        cur_acl_name = acl_name_data.group(2).strip()
                        if acl_name == cur_acl_name:
                            return True
            except Exception as ex:
                demisto.error(f'Exception when checking if ACL exists: {str(ex)}')
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format when checking of ACL exists on WLC '+(self.cisco_wlc_os))
            finally:
                # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
                demisto.info('wlc_info closing connection')
                wlc_cleanup(net_connect)

            return False


        def delete_existing_acl(self, device_dict, net_connect, acl_name):
            '''
                Remove the ACL existing on Cisco WLC
            '''
            if len(acl_name) == 0:
                raise ValueError('ACL name is empty.')
            if not self.check_acl_exists(net_connect, acl_name):
                raise Exception('The ACL name provided does not exist: %s for %s' % (str(acl_name), self.cisco_wlc_os))
            else:
                net_connect = wlc_init(device_dict)

            cmd = 'config t'
            cmdNxt = 'no ip access-list extended {}'.format(acl_name)
            net_connect.send_command_timing('')
            try:
                output = net_connect.send_command_w_enter(cmd)
                if 'Incorrect usage' in output or  'Invalid input' in output :
                    raise Exception('Unsupported format for command %s for %s' % (cmd, self.cisco_wlc_os))
                output = net_connect.send_command_w_enter(cmdNxt)
                net_connect.send_command_w_enter('end')
            except Exception as ex:
                demisto.error(f'Exception when deleting ACL : {str(ex)}')
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format when checking of ACL exists on WLC '+(self.cisco_wlc_os))
            finally:
                # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
                demisto.info('wlc_info closing connection')
                wlc_cleanup(net_connect)

            if 'Error' in output or 'Invalid input' in output or 'does not exist' in output:
                raise Exception("Error while deleting ACL on %s. %s" % (str(output), self.cisco_wlc_os))
            return 'Sucessfully deleted ACL name {} from Cisco WLC for {}'.format(acl_name, self.cisco_wlc_os)



        def execute_command(self, cmd, net_connect):
            '''
               Executes the WLC commands remotely and retuns RAW results
            '''

            if cmd == None or cmd == "":
                return "Invalid command passed. "+cmd

            output = ""
            try:
                net_connect.send_command_timing('\n')
                output = net_connect.send_command_w_enter(cmd)

                while True:
                    output_append = net_connect.send_command_timing("y")
                    if 'Incorrect usage' in output_append or  'Invalid input' in output_append or 'Unknown command' in output_append:
                        break
                    if not output_append:
                        break
                    output += output_append

            except Exception as es:
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format while running command on WLC '+(self.cisco_wlc_os))

            finally:
                # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
                demisto.info('wlc_info closing connection')
                wlc_cleanup(net_connect)

            if 'Error' in output or 'Invalid input' in output or 'does not exist' in output:
                raise Exception("Error while executing command on CiscoCatalyst %s. %s" % (str(output), self.cisco_wlc_os))

            return output


    class CiscoAironetParser:

        def __init__(self,net_connect):
            self.system_name, self.cisco_wlc_os = self.wlc_cisco_get_sysinfo(net_connect)

        def wlc_cisco_get_wlan_summary(self,net_connect, evt_content):
            """ Gets the information regarding WLAN.

            summary information about Wlans include total number of wlans.

            :param net_connect: ssh connection handler to device
            :param evt_content: event content dictionary holding the data format
            :return: void
            """

            try:
                cmd = "show wlan summary"
                output = net_connect.send_command_timing(cmd)
                lines = output.split("\n")
                for line in lines:
                    if not line:
                        continue
                    if 'Number of WLANs' in line:
                        parts = line.split('Number of WLANs')
                        for part in parts:
                            if not part:
                                continue
                            part = part.replace('.', '')
                            part = part.strip()
                            evt_content["totalWlans"] = int(part)
                            break
            except Exception as ex:
                demisto.error(f'Exception when getting WLAN summary: {str(ex)}')
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format when getting WLAN summary from WLC '+(self.cisco_wlc_os))

        def wlc_cisco_get_ap_summary(self,net_connect, evt_content, read_only, pagination_enabled, ap_pattern=""):
            """ Gets the access points summary information from the CLI

            :param net_connect: ssh connection handler to device
            :param evt_content: event content dictionary holding the data format
            :param read_only: boolean flag stating read/write permission for the user for that device
            :param pagination_enabled: boolean flag if the pagination is enabled or not.
            :param ap_pattern: pattern for names of ap to fetch summary. It can be just name of the AP or wildcard also.
            :return: void
            """

            try:
                ap_info = collections.defaultdict(dict)
                cmd = "show ap summary"
                if len(ap_pattern) > 0:
                    cmd += f" {ap_pattern}"
                output = net_connect.send_command_timing(cmd)

                lines = output.split("\n")
                for line in lines:
                    if not line:
                        continue

                    if 'Number of APs' in line:
                        parts = line.split('Number of APs')
                        for part in parts:
                            if not part:
                                continue
                            part = part.replace('.', '')
                            part = part.strip()
                            evt_content["totalAPs"] = int(part)
                            break

                if evt_content["totalAPs"] < 1:
                    demisto.info("wlc_info no APs found")
                    return

                access_points = int(part)
                if access_points <= 6 or not pagination_enabled:
                    pass
                else:
                    net_connect.send_command_timing('')
                    output_cmd = net_connect.send_command_timing(cmd)
                    if 'Number of APs' in output_cmd:
                        output = output_cmd
                    else:
                        output += output_cmd

                    while True:
                        output_append = net_connect.send_command_timing("y")
                        if 'Incorrect usage' in output_append or  'Invalid input' in output_append or 'Unknown command' in output_append:
                            break
                        if not output_append:
                            break
                        output += output_append

                ap_name = ''
                slots = 0
                ap_model = ''
                ethernet_mac = ''
                location = ''
                country = ''
                ip_address = ''
                number_of_clients = 0
                lines = output.split("\n")


                idx = 0
                for i in range(len(lines)):
                    if "Ethernet MAC" in lines[i]:
                        idx = i
                        break
                lines = lines[idx + 2:]

                for line in lines:

                    find_mac_pattern = re.compile(r'(?:[0-9a-fA-F]:?){12}')
                    if not line or line == "\n" or "--More-- or (q)uit" in line or not re.findall(find_mac_pattern, line):
                        continue

                    parts = line.split(' ')
                    cleaned_parts = []
                    for part in parts:
                        if not part:
                            continue
                        if '[' in part:
                            break
                        cleaned_parts.append(part)

                    for i in range(len(cleaned_parts)):
                        ap_name = cleaned_parts[0]
                        slots = cleaned_parts[1]
                        ap_model = cleaned_parts[2]
                        ethernet_mac = cleaned_parts[3]
                        ps = re.search('\d+\.\d+\.\d+\.\d+', cleaned_parts[i])
                        if ps:
                            location = cleaned_parts[4:i - 1]
                            country = cleaned_parts[i - 1]
                            ip_address = cleaned_parts[i]
                            number_of_clients = int(cleaned_parts[i + 1])

                    ap_info[ap_name]["apName"] = ap_name
                    ap_info[ap_name]["slots"] = slots
                    ap_info[ap_name]["apModel"] = ap_model
                    ap_info[ap_name]["ethernetMAC"] = ethernet_mac
                    ap_info[ap_name]["location"] = ' '.join(location)
                    ap_info[ap_name]["country"] = country
                    ap_info[ap_name]["apIPAddress"] = ip_address
                    ap_info[ap_name]["numberOfClients"] = number_of_clients
                    ap_info[ap_name]["client_list"] = []

                evt_content['ap_list'] = []
                for key in sorted(ap_info):
                    dic = {key: ap_info[key]}
                    evt_content['ap_list'].append(dic)
            except Exception as ex:
                demisto.error(f'Exception when getting AP summary: {str(ex)}')
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format when getting AP summary from WLC '+(self.cisco_wlc_os))

        def wlc_cisco_get_client_summary(self,net_connect, evt_content, read_only, pagination_enabled):
            """ Gets the information about all clients connected to access points.

            :param net_connect: ssh connection handler to device
            :param evt_content: event content dictionary holding the data format
            :param read_only: boolean flag stating read/write permission for the user for that device
            :param pagination_enabled: boolean flag if the pagination is enabled or not.
            :return: void
            """

            try:
                cmd = "show client summary"
                output_old = net_connect.send_command_timing(cmd)
                lines = output_old.split("\n")
                for line in lines:
                    if 'Number of Clients' in line:
                        parts = line.split('Number of Clients')
                        for part in parts:
                            if not part:
                                continue
                            part = part.replace('.', '')
                            part = part.strip()
                            evt_content["totalClients"] = int(part)
                        break

                if evt_content["totalClients"] < 1:
                    demisto.info("no clients found")
                    return

                clients = int(part)
                if clients <= 6 or not pagination_enabled:
                    output = output_old
                else:
                    net_connect.send_command_timing('')
                    output = net_connect.send_command_timing(cmd)
                    while True:
                        # normalize=False makes sure we send 'y' without 'Enter' since it only outputs with a 'y' and chars/inputs breaks its execution
                        output_append = net_connect.send_command_timing("y", normalize=False)
                        demisto.info(f"Show client summary command data while paginating: {output_append}")
                        if 'Incorrect usage' in output_append or 'Invalid input' in output_append or 'Unknown command' in output_append or 'Would you like to display more entries?' not in output_append:
                            break
                        if not output_append:
                            break
                        output += output_append

                lines = output.split("\n")

                # Filtering the output so that initial markup lines for 'show client summary'
                # are filtered
                filter_idx = 0
                for line_idx in range(len(lines)):
                    if "MAC Address" in lines[line_idx]:
                        filter_idx = line_idx
                        break

                lines = lines[filter_idx + 2:]

                for line in lines:
                    client_info = {}
                    mac_address = ''
                    slot = ''
                    status = ''
                    wlan_id = ''
                    authenticated = ''
                    radio = ''
                    port = 0
                    ap_name = ''

                    if not line:
                        continue

                    ps = re.search('(\w+:\w+:\w+:\w+:\w+:\w+)', line)

                    if ps:
                        mac_address, slot, status, wlan_id, authenticated, radio, port, ap_name = wlc_cisco_extract_client_summary(
                            line, ps.group(1), self.cisco_wlc_os)

                    client_info["macAddress"] = mac_address
                    if not UtilityClass.is_valid_mac_address(mac_address):
                        continue
                    client_info["slot"] = slot
                    client_info["status"] = status
                    client_info["wlanId"] = wlan_id
                    client_info["authenticated"] = authenticated
                    client_info["radio"] = radio
                    client_info["port"] = port

                    client_info = self.wlc_cisco_get_client_details(net_connect, client_info, read_only, pagination_enabled)

                    ap_list = evt_content['ap_list']
                    del evt_content['ap_list']

                    for ap in ap_list:
                        if ap_name in ap:
                            ap[ap_name]['client_list'].append(client_info)

                    evt_content['ap_list'] = ap_list
            except Exception as ex:
                demisto.error(f'Exception when getting client summary: {str(ex)}')
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format when getting client summary from WLC '+(self.cisco_wlc_os))

        def wlc_cisco_get_bt_client_summary(self,net_connect, evt_content, read_only, pagination_enabled):
            '''
                Traverse through all the available access points and fetch bluetooth devices associated with it.
                :param net_connect: ssh connection handler to device
                :param evt_content: event content dictionary holding the data format
                :param read_only: boolean flag stating read/write permission for the user for that device
                :param pagination_enabled: boolean flag if the pagination is enabled or not.
                :return: void
            '''

            try:
                ap_list = evt_content["ap_list"]

                for access_point in ap_list:
                    for key in access_point:
                        cmd = "test cleanair show idr ap {}".format(key)
                        if pagination_enabled:
                            try:
                                net_connect.send_command_timing('\n')
                                detail_output = net_connect.send_command_timing(cmd)

                            except Exception as es:
                                demisto.info('wlc_info caught exception get_client_details' + str(es))
                                raise Exception('Error while running %s for WLC %s' % (cmd, self.cisco_wlc_os))

                            while True:
                                output_append = net_connect.send_command_timing("y")
                                if 'Incorrect usage' in output_append or  'Invalid input' in output_append or 'Unknown command' in output_append:
                                    break
                                if not output_append:
                                    break
                                detail_output += output_append

                        else:
                            detail_output = net_connect.send_command_timing(cmd)

                        lines = detail_output.split("\n")
                        # traversing through output and mergin all the client's info
                        line_index = 0
                        slot_id = None
                        while line_index < len(lines):
                            line = lines[line_index]
                            if 'Identified devices on slot' in line:
                                slot_id = int(line.replace("Identified devices on slot ", ""))
                            elif 'ClusterID' in line:
                                device_data = []
                                device_data.append(line)
                                device_data_prefix = 'Device ID'
                                while line_index < len(lines) - 1:
                                    line_index += 1
                                    if device_data_prefix in lines[line_index]:
                                        device_data.append(lines[line_index])
                                        if device_data_prefix == 'addr':
                                            break
                                        device_data_prefix = 'addr'
                                single_device_data = ' '.join(device_data)
                                # fetching all the bt device data
                                ps = re.search(
                                    'ClusterID:\s*(\S*)\s*Device ID\s*(\w*)\s*((BLE|BT)\s*\w*)\s*(\S*GHz):\s*sev=(\w*),\s*DC=(\w*%),\s*RSSI\S*=(\S*)\s*ch\((\S*)\)[\s\S]*@\s*([\w\s:]*)\s*\S*RF sig\S*=(\w*):\s*addr=(\S*)', single_device_data)
                                parsed_data = None
                                if ps:
                                    parsed_data = {}
                                    valid_mac_address = str(ps.group(12)).strip()
                                    if not UtilityClass.is_valid_mac_address(valid_mac_address):
                                        continue
                                    parsed_data["macAddress"] = valid_mac_address
                                    parsed_data["bluetoothType"] = str(ps.group(4)).strip()
                                    parsed_data["bluetoothDeviceType"] = str(ps.group(3)).strip()
                                    parsed_data["frequency"] = str(ps.group(5)).strip()
                                    parsed_data["channel"] = str(ps.group(9)).strip()
                                    parsed_data["connectionState"] = "Yes"
                                    parsed_data["rssi"] = str(ps.group(8)).strip()
                                    parsed_data["slot"] = str(slot_id).strip()
                                    # calculating the connection duration in format dd:hh:mm:ss
                                    connect_time = datetime.datetime.strptime(str(ps.group(10)).strip(), "%b %d %H:%M:%S %Y")
                                    connection_duration = datetime.datetime.now() - connect_time
                                    connection_duration = connection_duration.total_seconds()
                                    dur_days, dur_hrs, dur_mins, dur_secs = convert_to_days_hrs_mins_secs(connection_duration)

                                    parsed_data["connectedDuration"] = "{:02d}d:{:02d}h:{:02d}m:{:02d}s".format(
                                        dur_days, dur_hrs, dur_mins, dur_secs)

                                    # adding device data to the client list
                                    access_point[key]['client_list'].append(parsed_data)

                            line_index += 1

                        # updating number of client with the len of discovered devices
                        access_point[key]["numberOfClients"] = len(access_point[key]['client_list'])
            except Exception as ex:
                demisto.error(f'Exception when getting bluetooth client summary: {str(ex)}')
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format when getting bluetooth client summary from WLC '+(self.cisco_wlc_os))

        def wlc_cisco_get_sysinfo(self, net_connect):
            system_name = ''
            cisco_wlc_os = "Cisco Aironet"
            try:
                net_connect.send_command_timing("\n")
                output = net_connect.send_command_timing("show sysinfo")
                lines = output.split('\n')
                for line in lines:
                    if 'System Name' in line:
                        parts = line.split('System Name')
                        for part in parts:
                            if not part:
                                continue
                            part = part.replace('.', '')
                            part = part.replace(':', '')
                            part = part.strip()
                            system_name = part

                    elif 'Product Version' in line:
                        version_pattern = r'\d+(=?\.(\d+(=?\.(\d+)*)*)*)*'
                        pattern_compile = re.compile(version_pattern)
                        cisco_wlc_os_version = pattern_compile.search(line)
                        if cisco_wlc_os_version:
                            cisco_wlc_os += " Version "+cisco_wlc_os_version.group(0)

            except Exception as ex:
                demisto.error(f'Exception when getting sysinfo: {str(ex)}')
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format when getting sysinfo from WLC version '+cisco_wlc_os)

            return system_name, cisco_wlc_os


        def wlc_cisco_get_client_summary_from_mac(self, net_connect, client_data, read_only, pagination_enabled, client_mac_address):
            """ Gets the information about all clients connected to access points.

            :param net_connect: ssh connection handler to device
            :param client_data: data of the client
            :param read_only: boolean flag stating read/write permission for the user for that device
            :param pagination_enabled: boolean flag if the pagination is enabled or not.
            :return: void
            """

            try:
                cmd = f"grep include {client_mac_address} 'show client summary'"
                if pagination_enabled:
                    net_connect.send_command_timing('')
                    output = net_connect.send_command_w_enter(cmd)
                    while True:
                        output_append = net_connect.send_command_timing("y")
                        if 'Incorrect usage' in output_append or  'Invalid input' in output_append or 'Unknown command' in output_append:
                            break
                        if not output_append:
                            break
                        output += output_append
                else:
                    output = net_connect.send_command_w_enter(cmd)

                lines = output.split("\n")

                for line in lines:
                    if "lines matching the pattern" in line:
                        continue
                    elif client_mac_address not in line:
                        continue

                    mac_address = ''
                    slot = ''
                    status = ''
                    wlan_id = ''
                    authenticated = ''
                    radio = ''
                    port = 0
                    ap_name = ''

                    if not line:
                        continue

                    mac_address, slot, status, wlan_id, authenticated, radio, port, ap_name = wlc_cisco_extract_client_summary(
                        line, client_mac_address, self.cisco_wlc_os)

                    if not UtilityClass.is_valid_mac_address(mac_address):
                        continue
                    client_data["macAddress"] = mac_address
                    client_data["slot"] = slot
                    client_data["status"] = status
                    client_data["wlanId"] = wlan_id
                    client_data["authenticated"] = authenticated
                    client_data["radio"] = radio
                    client_data["port"] = port
                    client_data["apName"] = ap_name

                    client_data = self.wlc_cisco_get_client_details(net_connect, client_data, read_only, pagination_enabled)
                    break
            except Exception as ex:
                demisto.error(f'Exception when getting client summary from MAC: {str(ex)}')
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format when getting client summary from MAC for WLC '+(self.cisco_wlc_os))

        def wlc_cisco_get_client_details(self, net_connect, client_info, read_only, pagination_enabled):
            """ Gets the client detailed information.

            details of a client include SSID, authentication mechanism,
            RSSI (radio signal strength) and SNR (noise ratio).

            :param net_connect: ssh connection handler to device
            :param client_info: client summary dictionary retrieved from cli
            :param read_only: boolean flag stating read/write permission for the user for that device
            :param pagination_enabled: boolean flag if the pagination is enabled or not.
            :return: client_info filled up with the details.
            """
            if pagination_enabled:
                cmd = "show client detail " + str(client_info["macAddress"])

                try:
                    net_connect.send_command_timing('\n')
                    detail_output = net_connect.send_command_timing(cmd, strip_prompt=False)

                except Exception as es:
                    demisto.info('wlc_info caught exception get_client_details' + str(es))
                    raise Exception('Error while running %s for WLC %s' % (cmd, self.cisco_wlc_os))

                while True:
                    output_append = net_connect.send_command_timing("y")
                    if 'Incorrect usage' in output_append or  'Invalid input' in output_append or 'Unknown command' in output_append:
                        break
                    if not output_append:
                        break
                    detail_output += output_append

            else:
                cmd = "show client detail " + str(client_info["macAddress"])
                detail_output = net_connect.send_command_timing(cmd)

            detail_lines = detail_output.split('\n')

            # client details fields
            ssid = ''
            connected_duration = ''
            ip_address = ''
            authentication_algorithm = ''
            encryption_cipher = ''
            rssi = ''
            snr = ''
            policy = ''
            client_state = ''

            for each_line in detail_lines:

                if not each_line:
                    continue

                ps_ssid = re.search(r'(Wireless LAN Network Name \(SSID\)\.+\s)(.+)', each_line)
                if ps_ssid:
                    ssid = str(ps_ssid.group(2))

                ps_connected_duration = re.search('(Connected For).*\s(\d+)\ssecs', each_line)
                if ps_connected_duration:
                    connected_duration = str(ps_connected_duration.group(2))

                ps_ip_address = re.search('(IP Address).*\s(\d+.\d+.\d+.\d+)', each_line)
                if ps_ip_address:
                    ip_address = str(ps_ip_address.group(2))

                if 'Authentication Key Management' in each_line:
                    parts = each_line.split('Authentication Key Management')
                    for part in parts:
                        if not part:
                            continue
                        part = part.replace('.', '')
                        part = part.strip()
                        authentication_algorithm = part

                if 'Encryption Cipher' in each_line:
                    parts = each_line.split('Encryption Cipher')
                    for part in parts:
                        if not part:
                            continue
                        part = part.replace('.', '')
                        part = part.strip()
                        encryption_cipher = part

                if 'Policy Type' in each_line:
                    parts = each_line.split('Policy Type')
                    for part in parts:
                        if not part:
                            continue
                        part = part.replace('.', '')
                        part = part.strip()
                        policy = part

                if 'Radio Signal Strength Indicator' in each_line:
                    parts = each_line.split('Radio Signal Strength Indicator')
                    for part in parts:
                        if not part:
                            continue
                        part = part.replace('.', '')
                        part = part.strip()
                        rssi = part

                if 'Signal to Noise Ratio' in each_line:
                    parts = each_line.split('Signal to Noise Ratio')
                    for part in parts:
                        if not part:
                            continue
                        part = part.replace('.', '')
                        part = part.strip()
                        snr = part

                if 'Client State' in each_line:
                    parts = each_line.split('Client State')
                    for part in parts:
                        if not part:
                            continue
                        part = part.replace('.', '')
                        part = part.strip()
                        client_state = part

            client_info["SSID"] = ssid
            client_info["connectedDuration"] = connected_duration
            client_info['ipAddress'] = ip_address
            client_info['encryptionCipher'] = str(encryption_cipher)
            auth_method = str(policy) + ' ' + str(authentication_algorithm)
            client_info['authMethod'] = auth_method.strip()
            client_info['rssi'] = rssi
            client_info['snr'] = snr
            client_info['clientState'] = client_state

            return client_info

        def cisco_wlc_apply_acl(self, net_connect, acl_name, acl_content_list=[]):
            '''
                Applies ACL by connecting to cisco wlc
            '''
            def push_acl(net_connect, acl_list, acl_name_cloud):
                '''
                    Pushes ACL rules to the net_connect connection
                '''
                def expand_neq_conditions(acl_list):
                    '''
                        expands neq conditions to form of range x-y in the provided rule list
                    '''
                    acl_list_to_ret = []
                    for acl_rule in acl_list:
                        ps = re.search('(neq\s*(\d+))', acl_rule)
                        if ps:
                            modified_acl_rules = []
                            port_to_ignore = int(ps.group(2))
                            # handling special conditions first
                            # if the specified port is 0 then add succeeding range only
                            if port_to_ignore == 0:
                                modified_acl_rules.append(acl_rule.replace(str(ps.group(1)), 'range 1-65535', 1))
                            # if specified port is 65535 then add preceeding range only
                            elif port_to_ignore == 65535:
                                modified_acl_rules.append(acl_rule.replace(str(ps.group(1)), 'range 0-65534', 1))
                            # other wise add 0-port_to_ignore-1 and port_to_ignore+1-65535
                            else:
                                modified_acl_rules.append(acl_rule.replace(str(ps.group(1)), 'range 0-{}'.format(port_to_ignore - 1), 1))
                                modified_acl_rules.append(acl_rule.replace(
                                    str(ps.group(1)), 'range {}-65535'.format(port_to_ignore + 1), 1))

                            # calling function recursively to ensure there is no other neq condition
                            modified_acl_rules = expand_neq_conditions(modified_acl_rules)
                            acl_list_to_ret.extend(modified_acl_rules)
                        else:
                            acl_list_to_ret.append(acl_rule)

                    return acl_list_to_ret

                proto_map = {"tcp": "6", "udp": "17", "icmp": "1", "ip": "4"}
                if not acl_list:
                    demisto.info("ERROR: cisco_wlc_apply_acl->push_acl acl_list not populated")
                    return

                acl_name = 'zingbox-acl'
                if acl_name_cloud:
                    acl_name = acl_name_cloud

                acl_create = 'config acl create "{}"'.format(str(acl_name))
                output = net_connect.send_command_timing(acl_create)
                # raising exception in case there is error in output
                if 'Error' in output:
                    raise Exception(output)

                acl_list = expand_neq_conditions(acl_list)

                acl_index = 1
                for each_acl in acl_list:
                    demisto.info("cisco_wlc_apply_acl->push_acl: current-acl %s" % (str(each_acl)))
                    # default values

                    direction = 'out'
                    action = 'permit'
                    source = 'any'
                    src_subnet_mask = '255.255.255.255'
                    src_start_port_num = 'any'
                    src_end_port_num = 'any'
                    dest = 'any'
                    dst_subnet_mask = '255.255.255.255'
                    proto = 'any'
                    dst_start_port_num = 'any'
                    dst_end_port_num = 'any'

                    ps = re.search('(permit|deny)\s*(\w+)\s*(any|host\s*(\d+\.\d+\.\d+\.\d+)|((\d+\.\d+\.\d+\.\d+)\s*(\d+\.\d+\.\d+\.\d+)))\s*(eq\s*(\d+)|range\s*((\d+)-(\d+)))?\s*(any|host\s*(\d+\.\d+\.\d+\.\d+)|((\d+\.\d+\.\d+\.\d+)\s*(\d+\.\d+\.\d+\.\d+)))\s*(eq\s*(\d+)|range\s*((\d+)-(\d+)))?', each_acl)
                    if ps:

                        action = str(ps.group(1))
                        proto = str(ps.group(2))
                        source_type = str(ps.group(3))
                        if source_type != 'any':
                            if ps.group(4):
                                source = str(ps.group(4))
                            else:
                                source = str(ps.group(6))
                                src_subnet_mask = str(ps.group(7))

                        if ps.group(8):
                            if ps.group(9):
                                src_start_port_num = src_end_port_num = str(ps.group(9))
                            if ps.group(10):
                                src_start_port_num = str(ps.group(11))
                                src_end_port_num = str(ps.group(12))

                        dst_type = str(ps.group(13))
                        if dst_type != 'any':
                            if ps.group(14):
                                dest = str(ps.group(14))
                            else:
                                dest = str(ps.group(16))
                                dst_subnet_mask = str(ps.group(17))

                        if ps.group(18):
                            if ps.group(19):
                                dst_start_port_num = dst_end_port_num = str(ps.group(19))
                            if ps.group(20):
                                dst_start_port_num = str(ps.group(21))
                                dst_end_port_num = str(ps.group(22))

                        proto = proto.lower()
                        if proto in proto_map:
                            proto = proto_map[proto]

                    acl_name_string = 'config acl rule add "{}" {}'.format(str(acl_name), str(acl_index))
                    acl_direction = 'config acl rule direction "{}" {} {}'.format(str(acl_name), str(acl_index), str(direction))
                    acl_src = 'config acl rule source address "{}" {} {} {}'.format(
                        str(acl_name), str(acl_index), str(source), str(src_subnet_mask))
                    acl_dest = 'config acl rule destination address "{}" {} {} {}'.format(
                        str(acl_name), str(acl_index), str(dest), str(dst_subnet_mask))
                    acl_action = 'config acl rule action "{}" {} {}'.format(str(acl_name), str(acl_index), str(action))
                    acl_proto = 'config acl rule protocol "{}" {} {}'.format(str(acl_name), str(acl_index), str(proto))
                    acl_src_port = 'config acl rule source port range "{}" {} {} {}'.format(
                        str(acl_name), str(acl_index), str(src_start_port_num), str(src_end_port_num))
                    acl_dst_port = 'config acl rule destination port range "{}" {} {} {}'.format(
                        str(acl_name), str(acl_index), str(dst_start_port_num), str(dst_end_port_num))

                    acl_commands = []
                    acl_commands.append(acl_name_string)
                    acl_commands.append(acl_direction)
                    acl_commands.append(acl_action)
                    acl_commands.append(acl_proto)

                    # checking if the port and address rules needs to be added or not
                    if src_start_port_num != 'any' and src_end_port_num != 'any':
                        acl_commands.append(acl_src_port)
                    if dst_start_port_num != 'any' and dst_end_port_num != 'any':
                        acl_commands.append(acl_dst_port)

                    if source != 'any':
                        acl_commands.append(acl_src)
                    if dest != 'any':
                        acl_commands.append(acl_dest)

                    if not acl_commands:
                        return

                    for acl_cmd in acl_commands:
                        # send device commands using list and displays output to screen
                        output = net_connect.send_command_timing(acl_cmd)
                        # raising exception in case there is error in output
                        if 'error' in output.lower() or 'invalid input' in output.lower() or 'incorrect' in output.lower():
                            if 'invalid input' in output.lower():
                                raise Exception("{}\n{}".format(acl_cmd,output))
                            raise Exception(output)

                    # incrementing rule index
                    acl_index += 1

                # applying ACL once everything is added
                acl_apply = 'config acl apply "{}"'.format(str(acl_name))
                output = net_connect.send_command_timing(acl_apply)
                # raising exception in case there is error in output
                if 'error' in output.lower() or 'invalid input' in output.lower() or 'incorrect' in output.lower():
                    if 'invalid input' in output.lower():
                        raise Exception("{}\n{}\nFor ".format(acl_apply ,output, self.cisco_wlc_os))
                    raise Exception(output)

            try:
                if not acl_name or len(acl_name) == 0:
                    raise Exception("Missing aclName in command")
                elif not acl_content_list or len(acl_content_list) == 0:
                    raise Exception("No acl rule found while applying '{}' acl".format(str(acl_name)))
                else:
                    acl_list = []

                    for each in acl_content_list:
                        acl_list.append(each.lower())
                    demisto.info("push_acl_wlc: populated acl_list %s" % (str(len(acl_list))))
                    if len(acl_list) <= 64:
                        if net_connect:
                                push_acl(net_connect, acl_list, acl_name)
                        else:
                            demisto.info("got wlc error in connection")
                            raise Exception("connection failed")
                    else:
                        raise Exception('acl list contains more than 64 entries cannot configure. OS '+(self.cisco_wlc_os))
            finally:
                # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
                wlc_cleanup(net_connect)


        def check_acl_exists(self, net_connect, acl_name):
            '''
                Check if ACL name already exist in cisco wlc device
            '''

            if len(acl_name) == 0:
                raise ValueError('ACL name is empty.')

            try:
                cmd = 'show acl summary'
                net_connect.send_command_timing('')
                output = net_connect.send_command_timing(cmd)
                while True:
                    output_append = net_connect.send_command_timing("y")
                    if 'Incorrect usage' in output_append or 'Invalid input' in output_append:
                        break
                    if not output_append:
                        break
                    output += output_append

                # creating array from output
                all_lines = output.split("\n")

                idx4 = 0
                for i in range(len(all_lines)):
                    if "IPv4 ACL Name" in all_lines[i]:
                        idx4 = i
                        break

                idx6 = idx4
                for i in range(len(all_lines)):
                    if "IPv6 ACL Name" in all_lines[i]:
                        idx6 = i
                        break

                # filtering out the lines with actual data
                lines = all_lines[idx4 + 2:idx6-1]

                # for now we will not check in the data of IPv6
                # lines.extend(all_lines[idx6 + 2:])

                for each_line in lines:
                    acl_name_data = re.search('([\s\S]+)\s+(yes|no)', each_line, re.IGNORECASE)
                    if acl_name_data:
                        cur_acl_name = acl_name_data.group(1).strip()
                        if acl_name == cur_acl_name:
                            return True
            except Exception as ex:
                demisto.error(f'Exception when checking if ACL exists: {str(ex)}')
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format when checking of ACL exists on WLC '+(self.cisco_wlc_os))
            finally:
                # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
                demisto.info('wlc_info closing connection')
                wlc_cleanup(net_connect)

            return False


        def delete_existing_acl(self, device_dict, net_connect, acl_name):
            '''
                Remove the ACL existing on Cisco WLC
            '''

            if len(acl_name) == 0:
                raise ValueError('ACL name is empty for '+str(self.cisco_wlc_os))

            try:
                # creating and sending command to cisco wlc
                cmd = 'config acl delete "{}"'.format(acl_name)
                output = net_connect.send_command_timing(cmd)

                # if there doesn't exist ipv4 acl then we will try to delete ipv6 one
                # for now we are keeping this code commented uptill discussion with PAN team
                # if 'IPv4' in output and 'does not exist' in output:
                #     cmd = 'config ipv6 acl delete "{}"'.format(acl_name)
                #     output = net_connect.send_command_timing(cmd)
            finally:
                # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
                demisto.info('wlc_info closing connection')
                wlc_cleanup(net_connect)

            if 'Error' in output or 'Invalid input' in output or 'does not exist' in output:
                raise Exception("Error while deleting ACL on %s. %s" % (str(output), self.cisco_wlc_os))

            return 'Sucessfully deleted ACL name {} from Cisco WLC for {}'.format(acl_name, self.cisco_wlc_os)



        def execute_command(self, cmd, net_connect):
            '''
               Executes the WLC commands remotely and retuns RAW results
            '''

            if cmd == None or cmd == "":
                return "Invalid command passed. "+cmd

            output = ""
            try:
                net_connect.send_command_timing('')
                output = net_connect.send_command_w_enter(cmd)
                while True:
                    output_append = net_connect.send_command_timing("y")
                    if 'Incorrect usage' in output_append or  'Invalid input' in output_append or 'Unknown command' in output_append:
                        break
                    if not output_append:
                        break
                    output += output_append

            except Exception as ex:
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format while running command on WLC '+(self.cisco_wlc_os))
            finally:
                # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
                demisto.info('wlc_info closing connection')
                wlc_cleanup(net_connect)

            if 'Error' in output or 'Invalid input' in output or 'does not exist' in output:
                raise Exception("Error while executing command on CiscoAironet %s. %s" % (str(output), self.cisco_wlc_os))

            return output


    class CiscoParserFactory:
        @staticmethod
        def create_parser(net_connect):
            """
            Creates a Cisco Parser based on the type of OS we have in the WLC we are connected to
            :param net_connect: ssh connection handler to device
            """
            output = net_connect.send_command_timing("show version")
            if re.search("Cisco IOS XE Software", output):
                # This is the Cisco Catalyst version
                return CiscoCatalystParser(net_connect)
            elif re.search("Cisco Aironet", output) or re.search("Incorrect usage.", output):
                return CiscoAironetParser(net_connect)
            else:
                demisto.error('Unable to detect Cisco WLC OS version: ' + output)
                raise Exception('Unable to detect Cisco WLC OS version: ' + output)

    class UtilityClass:
        @staticmethod
        def is_valid_mac_address(mac_address):
            """
            This is an utility function which checks where a mac_address string is a valid MAC Address
            Returns : True/False if the MAC is valid or invalid respectively
            """
            is_valid_mac = re.match(r'([0-9A-F]{2}[:]){5}[0-9A-F]{2}|'
                                r'([0-9A-F]{2}[-]){5}[0-9A-F]{2}',
                                string=mac_address,
                                flags=re.IGNORECASE)
            try:
                return bool(is_valid_mac.group())  # True if matched
            except AttributeError:
                return False


    # helper function
    def convert_to_days_hrs_mins_secs(time_in_seconds):
        dur_days = int(time_in_seconds/86400)
        dur_hrs = int(time_in_seconds/3600) - dur_days*24
        dur_mins = int(time_in_seconds/60) - dur_hrs*60 - dur_days*1440
        dur_secs = int(time_in_seconds) - dur_hrs*3600 - dur_mins*60 - dur_days*86400
        return dur_days, dur_hrs, dur_mins, dur_secs

    def wlc_cisco_extract_client_summary(client_summary_line, client_mac, cisco_wlc_os):
        '''
            Extract the client details from the client summary output

            :param client_summary_line: client summart details line returned by cisco wlc
            :param client_mac: mac address of the client for which details will be extracted

            :return client summary including mac_address, slot, status, wlan_id, authenticated, radio, port
        '''
        if client_mac not in client_summary_line:
            raise Exception(f'Invalid client summary for mac address \'{client_mac}\' for \'{cisco_wlc_os}\'')

        mac_address = str(client_mac)
        parts = client_summary_line.split(mac_address)
        parts = parts[1].split(' ')
        cleaned = []
        for clean in parts:
            if not clean:
                continue
            cleaned.append(clean)
        ap_name = cleaned[0]
        if 'GHz' in client_summary_line:
            parts = client_summary_line.split('GHz)')
            for part in parts:

                if '802.11' in part:
                    inter_part = part.split('802.11')
                    radio = str('802.11') + inter_part[1] + str('GHz)')
                    inter_parts = inter_part[0].split(" ")
                    value = []
                    for val in inter_parts:
                        if not val:
                            continue
                        value.append(val)

                    slot = value[2]
                    status = value[3]
                    wlan_id = value[4]
                    authenticated = value[5]

            parts = client_summary_line.split('GHz)')
            parts[1] = parts[1].strip()
            parts = parts[1].split(' ')
            port = parts[0]

        else:
            parts = client_summary_line.split(ap_name)
            parts = parts[1]
            inter_parts = parts.split('802.11')
            vals = []
            for part in inter_parts:
                val_list = part.split(' ')
                for val in val_list:
                    if not val:
                        continue
                    vals.append(val.strip())
            slot = vals[0]
            status = vals[1]
            wlan_id = vals[2]
            authenticated = vals[3]
            radio = '802.11' + str(vals[4])
            port = vals[5]

        return mac_address, slot, status, wlan_id, authenticated, radio, port, ap_name


    def wlc_cisco_flatten_ap_list(evt_content, cisco_wlc_os):

        try:
            ap_list_dict = evt_content["ap_list"]
            del evt_content["ap_list"]
            flatten_list = []

            for item in ap_list_dict:
                dic = item
                for val in dic.values():
                    flatten_list.append(val)

            evt_content["ap_list"] = flatten_list
        except Exception as ex:
            demisto.error(f'Exception when flattening AP list: {str(ex)}')
            demisto.error(traceback.format_exc())
            raise Exception('Unsupported format when flattening AP list from WLC '+cisco_wlc_os)


    def wlc_construct_source_fields_from_json(evt_content, system_name):

        json_obj = {}
        source = {}
        wlc_id = system_name

        source["eventLevel"] = "EV_EVENT"
        source["evtType"] = "evt_wlc_output"
        # source["tenantid"] = tenant_id
        source["evtContent"] = evt_content
        json_obj["evtSource"] = "wireless_controller"
        json_obj["wlcId"] = wlc_id
        json_obj["timestamp"] = int(time.time())
        json_obj["_source"] = source

        return json_obj


    def wlc_is_user_read_only(net_connect, cisco_wlc_os):
        """ Checks the user permissions

        :param net_connect: ssh connection handler to device
        :return: permission: returns read/write permission for the user for that device
        """
        try:
            read_permission = False
            output = net_connect.send_command_timing("config paging enable")
            if 'Incorrect usage' in output or  'Invalid input' in output or 'Unknown command' in output:
                demisto.info('wlc_info cannot configure command, user has read permissions')
                read_permission = True
            else:
                demisto.info('wlc_info user has write permissions')
        except Exception as ex:
            demisto.error(f'Exception when getting user read-only status: {str(ex)}')
            demisto.error(traceback.format_exc())
            raise Exception('Unsupported format when getting user read-only status from WLC '+cisco_wlc_os)

        return read_permission


    def wlc_cleanup(net_connect):
        """ Perform cleanup functions

        currently, disconnects the ssh connection that was opened to the device

        :param net_connect: ssh connection handler to device
        :return: void
        """
        net_connect.disconnect()

    def wlc_init(device_dict):

        # Getting ssh connection handler to device
        try:
            net_connect = ConnectHandler(**device_dict)
        except Exception as ex:
            demisto.info("wlc got exception: %s" % str(ex))
            raise ex
        return net_connect

    def wlc_get_devices_data(device_dict):
        """ main function for pulling the information from wireless controller from the inspector

        This function calls other subroutines responsible for individual chunk of work and is the
        only entry point in data path. It constructs a JSON object and write into the file
        which can be consumed by API team to display the wireless data onto dashboard.

        :return: dict object consist of all wireless devices
        """
        evt_content = {}
        json_obj = None

        # Getting ssh connection handler to device
        try:
            net_connect = ConnectHandler(**device_dict)
        except Exception as ex:
            demisto.info("wlc got exception: %s" % str(ex))
            raise ex

        try:
            parser = CiscoParserFactory.create_parser(net_connect)

            system_name = parser.system_name
            cisco_wlc_os = parser.cisco_wlc_os
            read_only = wlc_is_user_read_only(net_connect, cisco_wlc_os)
            pagination_enabled = True

            parser.wlc_cisco_get_wlan_summary(net_connect, evt_content)
            parser.wlc_cisco_get_ap_summary(net_connect, evt_content, read_only, pagination_enabled)
            if evt_content.get("totalAPs", 0) > 0:
                parser.wlc_cisco_get_client_summary(net_connect, evt_content, read_only, pagination_enabled)
                wlc_cisco_flatten_ap_list(evt_content, cisco_wlc_os)

                filename = ''

                if system_name or system_name == '':
                    timestamp = str(strftime('%Y-%m-%d_%H:%M:%S', gmtime()))
                    filename = str(system_name + '_') + timestamp
                    demisto.info('wlc_info filename '+filename)
                    evt_content['file-id'] = filename
                    json_obj = wlc_construct_source_fields_from_json(evt_content, system_name)
        finally:
            # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
            demisto.info('wlc_info closing connection')
            wlc_cleanup(net_connect)
        return json_obj

    def wlc_get_all_aps(device_dict):
        """ main function for pulling the information from wireless controller from the inspector

        This function calls other subroutines responsible for individual chunk of work and is the
        only entry point in data path. It constructs a JSON object and write into the file
        which can be consumed by API team to display the wireless data onto dashboard.

        :return: dict object consist of all wireless devices
        """
        evt_content = {}
        json_obj = None

        # Getting ssh connection handler to device
        try:
            net_connect = ConnectHandler(**device_dict)
        except Exception as ex:
            demisto.info("wlc got exception: %s" % str(ex))
            raise ex

        try:
            parser = CiscoParserFactory.create_parser(net_connect)

            system_name = parser.system_name
            cisco_wlc_os = parser.cisco_wlc_os
            read_only = wlc_is_user_read_only(net_connect, cisco_wlc_os)
            pagination_enabled = True

            parser.wlc_cisco_get_ap_summary(net_connect, evt_content, read_only, pagination_enabled)
            if evt_content.get("totalAPs", 0) > 0:
                wlc_cisco_flatten_ap_list(evt_content, cisco_wlc_os)

                filename = ''

                if system_name or system_name == '':
                    timestamp = str(strftime('%Y-%m-%d_%H:%M:%S', gmtime()))
                    filename = str(system_name + '_') + timestamp
                    demisto.info('wlc_info filename '+filename)
                    evt_content['file-id'] = filename
                    json_obj = wlc_construct_source_fields_from_json(evt_content, system_name)
        finally:
            # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
            demisto.info('wlc_info closing connection')
            wlc_cleanup(net_connect)
        return json_obj


    def wlc_get_device_data(device_dict, client_mac_address):
        """ main function for pulling the information from wireless controller from the inspector

        This function calls other subroutines responsible for individual chunk of work and is the
        only entry point in data path. It constructs a JSON object and write into the file
        which can be consumed by API team to display the wireless data onto dashboard.

        :return: dict object consist of all wireless devices
        """
        evt_content = {}

        # Getting ssh connection handler to device
        try:
            net_connect = ConnectHandler(**device_dict)
        except Exception as ex:
            demisto.info("wlc got exception: %s" % str(ex))
            raise ex

        try:
            parser = CiscoParserFactory.create_parser(net_connect)

            cisco_wlc_os = parser.cisco_wlc_os

            read_only = wlc_is_user_read_only(net_connect, cisco_wlc_os)
            pagination_enabled = True

            client_data = {}

            parser.wlc_cisco_get_client_summary_from_mac(net_connect, client_data, read_only, pagination_enabled, client_mac_address)

            if not client_data.get("macAddress"):
                return client_data

            ap_name = client_data.get("apName")

            client_data['connectionState'] = client_data.get('clientState', '')
            client_data['apRadioSlotId'] = client_data.get('slot', '')

            if client_data.get('clientState', '') != '':
                del client_data['clientState']
            if client_data.get('slot', '') != '':
                del client_data['slot']

            # formatting connection duration
            dur_days, dur_hrs, dur_mins, dur_secs = convert_to_days_hrs_mins_secs(int(client_data["connectedDuration"]))

            connection_duration = ""
            if dur_days > 0:
                connection_duration += "{:02d} day(s)".format(dur_days)

            if dur_hrs > 0 or len(connection_duration) > 0:
                connection_duration += " {:02d} hour(s)".format(dur_hrs)

            if dur_mins > 0 or len(connection_duration) > 0:
                connection_duration += " {:02d} minute(s)".format(dur_mins)

            if dur_secs > 0 or len(connection_duration) > 0:
                connection_duration += " {:02d} second(s)".format(dur_secs)

            client_data["connectedDuration"] = connection_duration


            parser.wlc_cisco_get_wlan_summary(net_connect, evt_content)
            parser.wlc_cisco_get_ap_summary(net_connect, evt_content, read_only, pagination_enabled, ap_name)

            ap_list = evt_content['ap_list']

            for ap_info in ap_list:
                if ap_name in ap_info:
                    client_data["apName"] = ap_info[ap_name]["apName"]
                    client_data["apModel"] = ap_info[ap_name]["apModel"]
                    client_data["apMacAddress"] = ap_info[ap_name]["ethernetMAC"]
                    client_data["location"] = ap_info[ap_name]["location"]
                    client_data["country"] = ap_info[ap_name]["country"]
                    client_data["apIPAddress"] = ap_info[ap_name]["apIPAddress"]
        finally:
            # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
            demisto.info('wlc_info closing connection')
            wlc_cleanup(net_connect)
        return client_data


    def wlc_get_bt_devices_data(device_dict):
        """ main function for pulling the bluetooth information from wireless controller from the inspector

        This function calls other subroutines responsible for individual chunk of work and is the
        only entry point in data path. It constructs a JSON object and write into the file
        which can be consumed by API team to display the wireless data onto dashboard.

        :return: json object consisting of all bluetooth devices
        """
        evt_content = {}
        json_obj = None

        # Getting ssh connection handler to device
        try:
            net_connect = ConnectHandler(**device_dict)
        except Exception as ex:
            demisto.info("wlc got exception: %s" % str(ex))
            raise ex

        try:
            parser = CiscoParserFactory.create_parser(net_connect)

            system_name = parser.system_name
            cisco_wlc_os = parser.cisco_wlc_os

            read_only = wlc_is_user_read_only(net_connect, cisco_wlc_os)
            pagination_enabled = True
            parser.wlc_cisco_get_wlan_summary(net_connect, evt_content)
            parser.wlc_cisco_get_ap_summary(net_connect, evt_content, read_only, pagination_enabled)
            if evt_content.get("totalAPs", 0) > 0:
                parser.wlc_cisco_get_bt_client_summary(net_connect, evt_content, read_only, pagination_enabled)
                wlc_cisco_flatten_ap_list(evt_content, cisco_wlc_os)

                filename = ''

                if system_name or system_name == '':
                    timestamp = str(strftime('%Y-%m-%d_%H:%M:%S', gmtime()))
                    filename = str(system_name + '_') + timestamp
                    demisto.info('wlc_info filename '+filename)
                    evt_content['file-id'] = filename
                    json_obj = wlc_construct_source_fields_from_json(evt_content, system_name)
        finally:
            # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
            demisto.info('wlc_info closing connection')
            wlc_cleanup(net_connect)
        return json_obj


    ''' MAIN FUNCTION '''


    def main() -> None:
        """main function, parses params and runs command functions

        :return:
        :rtype:
        """

        # fetching CISCO WLC login details
        cisco_wlc_host = demisto.params().get('cisco_wlc_host')
        username = demisto.params().get('credentials', {}).get('identifier')
        password = demisto.params().get('credentials', {}).get('password')

        device_dict = {
            'device_type': "cisco_wlc",
            'username': username,
            'password': password,
            'host': cisco_wlc_host
        }

        args = demisto.args()

        demisto.debug(f'Command being called is {demisto.command()}')
        try:

            # The command demisto.command() holds the command sent from the user.
            if demisto.command() == 'test-module':
                # This is the call made when pressing the integration test button.
                try:
                    net_connect = ConnectHandler(**device_dict)
                    wlc_cleanup(net_connect)
                    return_results('ok')
                except Exception as ex:
                    return_error("wlc got exception: %s" % str(ex))
            elif demisto.command() == 'cisco-wlc-get-all-client-details':
                # this command will just fetch all the data from WLC and print it on the Playground

                json_obj = wlc_get_devices_data(device_dict)
                rp_data = {}
                if json_obj:
                    rp_data["Total Clients"] = json_obj["_source"]["evtContent"]["totalClients"]
                else:
                    rp_data["Total Clients"] = 0

                return_results(CommandResults(
                    readable_output=tableToMarkdown("Asset Report Summary:", rp_data, removeNull=True),
                    outputs_prefix='cisco-wlc-IoT.devices',
                    outputs=json_obj
                ))
            elif demisto.command() == 'cisco-wlc-get-all-aps':
                #this command will fetch all the access points

                json_obj = wlc_get_all_aps(device_dict)
                rp_data = {}
                if json_obj:
                    rp_data["Total APs"] = json_obj["_source"]["evtContent"]["totalAPs"]
                else:
                    rp_data["Total APs"] = 0

                return_results(CommandResults(
                    readable_output=tableToMarkdown("Asset Report Summary:", rp_data, removeNull=True),
                    outputs_prefix='cisco-wlc-IoT.devices',
                    outputs=json_obj
                ))
            elif demisto.command() == 'cisco-wlc-get-client-details':
                # this command will just fetch all the data from WLC and print it on the Playground
                mac_address = args.get('macAddress')
                json_obj = wlc_get_device_data(device_dict, mac_address)

                if json_obj.get("macAddress",None) == None:
                    return_error(f"No client connected with the mac address: {mac_address}")
                else:
                    display_data = {}
                    display_data['Client MAC Address'] = json_obj.get('macAddress', '').lower()
                    display_data['Client IP Address'] = json_obj.get('ipAddress', '')
                    display_data['Radio'] = json_obj.get('radio', '')
                    display_data['SSID'] = json_obj.get('SSID', '')
                    display_data['Connection Duration'] = json_obj.get('connectedDuration', '')
                    display_data['Auth Method'] = json_obj.get('authMethod', '')
                    display_data['Encryption Cipher'] = json_obj.get('encryptionCipher', '')
                    display_data['RSSI'] = json_obj.get('rssi', '')
                    display_data['SNR'] = json_obj.get('snr', '')

                    display_data['Access Point Name'] = json_obj.get('apName', '')
                    display_data['Access Point IP Address'] = json_obj.get('apIPAddress', '')
                    display_data['Access Point Mac Address'] = json_obj.get('apMacAddress', '')
                    display_data['Access Point Model'] = json_obj.get('apModel', '')

                    return_results(CommandResults(
                        readable_output=tableToMarkdown("Client data Summary:", display_data, removeNull=True),
                        outputs_prefix='cisco-wlc-IoT.client_data',
                        outputs=json_obj
                    ))

            elif demisto.command() == 'cisco-wlc-get-all-bluetooth-client-details':
                # this command will just fetch all the data from WLC and print it on the Playground

                json_obj = wlc_get_bt_devices_data(device_dict)

                rp_data = {}
                total_clients = 0

                if json_obj:
                    for ap in json_obj["_source"]["evtContent"]["ap_list"]:
                        total_clients += ap["numberOfClients"]
                rp_data["Total Bluetooth Clients"] = total_clients
                return_results(CommandResults(
                    readable_output=tableToMarkdown("Asset Report Summary:", rp_data, removeNull=True),
                    outputs_prefix='cisco-wlc-IoT.bt-devices',
                    outputs=json_obj
                ))
            elif demisto.command() == "cisco-wlc-apply-acl":
                net_connect = wlc_init(device_dict)
                parser = CiscoParserFactory.create_parser(net_connect)
                acl_name = args.get('aclName')
                acl_content_list = argToList(args.get('aclContentList'))
                parser.cisco_wlc_apply_acl(net_connect, acl_name, acl_content_list)
                return_results("ACL applied successfully on {}".format(str(demisto.integrationInstance())))
            elif demisto.command() == "cisco-wlc-is-acl-exists":
                net_connect = wlc_init(device_dict)
                parser = CiscoParserFactory.create_parser(net_connect)
                acl_name = args.get('aclName', '')
                result = parser.check_acl_exists(net_connect, acl_name)

                return_results(CommandResults(
                    readable_output='ACL exists' if result else 'ACL doesn\'t exists',
                    outputs_prefix='cisco-wlc-IoT.is_acl_exists',
                    outputs=result
                ))
            elif demisto.command() == "cisco-wlc-delete-existing-acl":
                net_connect = wlc_init(device_dict)
                parser = CiscoParserFactory.create_parser(net_connect)
                acl_name = args.get('aclName', '')
                return_results(parser.delete_existing_acl(device_dict, net_connect, acl_name))

            # Execute Cisco WLC Commands - Get raw results
            elif demisto.command() == "cisco-wlc-execute-command":
                net_connect = wlc_init(device_dict)
                parser = CiscoParserFactory.create_parser(net_connect)
                command = demisto.args().get('command')
                return_results(parser.execute_command(command, net_connect))


        # Log exceptions and return errors
        except Exception as e:
            demisto.error(traceback.format_exc())  # print the traceback
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}')


    ''' ENTRY POINT '''


    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('PANW IoT 3rd Party Integration - Cisco WLAN Controller', 'end', __line__())
  subtype: python3
  type: python
sourcemoduleid: Cisco WLAN Controller
