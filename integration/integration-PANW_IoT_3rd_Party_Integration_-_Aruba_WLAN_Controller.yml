category: Network Security
commonfields:
  id: PANW IoT 3rd Party Integration - Aruba WLAN Controller
  version: -1
configuration:
- additionalinfo: Aruba WLC IP address or Hostname to access it from integration
  display: Aruba WLC IP or Hostname
  name: aruba_wlc_host
  required: true
  type: 0
- display: Username
  name: credentials
  required: false
  type: 9
- additionalinfo: Select an access method for integration.
  defaultvalue: API
  display: Access Method
  name: access_method
  options:
  - SSH
  - API
  required: true
  type: 15
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: Aruba WLAN Controller enables connection between Aruba WLC device and
  PANW IoT via XOAR integration
detaileddescription: |-
  ## Aruba WLC integration

  Please configure the instance by providing following details:

  - Name of the instance
  - Aruba WLC IP or Hostname
  - User name for log in
  - Password of the user entered above.

  ## Test Configuration

  After providing the mandatory details, please test the configuration using the Test button.

  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/aruba-wlan-controller)
display: PANW IoT 3rd Party Integration - Aruba WLAN Controller
image: data:image/png;base64,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
name: PANW IoT 3rd Party Integration - Aruba WLAN Controller
script:
  commands:
  - arguments: []
    description: Get Aruba WLC client details
    name: aruba-wlc-get-all-client-details
    outputs:
    - contextPath: aruba-wlc-IoT.devices
      description: Aruba WLAN Controller Devices
      type: string
  - arguments: []
    description: Get Aruba WLC active AP details
    name: aruba-wlc-get-active-ap
    outputs:
    - contextPath: aruba-wlc-IoT.active_ap
      description: Active APs in Aruba WLC
      type: string
  - arguments:
    - description: AP name to get active client list
      name: ap_name
      required: true
    description: Get active client list for the provided AP name
    name: aruba-wlc-get-active-client-list
    outputs:
    - contextPath: aruba-wlc-IoT.active_client_list
      description: Active Clients list for the provided AP name
      type: string
  - arguments:
    - description: Client MAC address
      name: mac_address
      required: true
    description: Get client details for the provided MAC address
    name: aruba-wlc-get-client-details-using-mac
    outputs:
    - contextPath: aruba-wlc-IoT.active_client_details
      description: Active Clients details for the provided MAC address
      type: string
  - arguments: []
    description: Get Aruba WLC bluetooth client details
    name: aruba-wlc-get-all-bluetooth-client-details
    outputs:
    - contextPath: aruba-wlc-IoT.bt_devices
      description: Aruba WLAN Controller Bluetooth Devices
      type: string
  - arguments:
    - description: 'Command name. Example: "show switchinfo "'
      name: command
      required: true
    name: aruba-wlc-execute-command
  - arguments: []
    description: Get details of all the switches along with crash information on the
      managed device
    name: aruba-wlc-get-all-switches
    outputs:
    - contextPath: aruba-wlc-IoT.switches
      description: Aruba WLAN Controller Network Devices
      type: string
  - arguments: []
    description: Get Aruba WLC Instant Access Point (IAP) details.
    name: aruba-wlc-get-all-iap
    outputs:
    - contextPath: aruba-wlc-IoT.iap_list
      description: Active IAPs in Aruba WLC
  dockerimage: demisto/netmiko:1.0.0.23064
  runonce: false
  script: |
    register_module_line('PANW IoT 3rd Party Integration - Aruba WLAN Controller', 'start', __line__())


    import re
    import json
    import collections
    import sys
    from time import gmtime, strftime
    import time
    import socket
    import requests
    # ssh_parser is the same as ConnectHandler
    from netmiko import ConnectHandler

    class ArubaControllerAPIParser:
        """
        Class is to fetch Aruba OS device data from API.
        """
        def __init__(self):
            self.aruba_wlc_host = self.check_aruba_wlc_host()
            self.username = demisto.params().get('credentials', {}).get('identifier')
            self.password = demisto.params().get('credentials', {}).get('password')
            self.aruba_uid, self.csrf_token = self.get_aruba_login_details()
            self.aruba_version_prior_8_9_flag = True
            # Checking Aruba OS version, If it is false then version is prior then 8.7 otherwise new version
            if self.csrf_token == '':
                self.aruba_new_version_flag = False
            else:
                self.aruba_new_version_flag = True

        def check_aruba_wlc_host(self):
            """
            Function will check whether hostname/ip-address is valid or not.
            """
            aruba_wlc_host = demisto.params().get('aruba_wlc_host')
            try:
                if not aruba_wlc_host.startswith('https://'):
                    aruba_wlc_host = 'https://'+aruba_wlc_host
                if aruba_wlc_host.startswith('http://'):
                    aruba_wlc_host = None
                    demisto.error("http:// is not valid for API access method, expected https")
            except Exception as ex:
                demisto.error('Error while validating Aruba WLC Hostname or IP Address' + str(ex))
            return aruba_wlc_host

        @staticmethod
        def is_valid_ipv4_address(address):
            """
            Function will check the given ip address is valid or not
            :param address: ip-address
            :return: boolean value
            """
            try:
                socket.inet_pton(socket.AF_INET, address)
            except AttributeError:  # no inet_pton here, sorry
                try:
                    socket.inet_aton(address)
                except socket.error:
                    return False
                return address.count('.') == 3
            except socket.error:  # not a valid address
                return False

            return True

        @staticmethod
        def is_valid_ap_radio(ap_radio_value):
            """
            Function will check the given ap_radio is valid or not.
            :param ap_radio_value: radio value.
            :return: boolean value.
            """
            regex_check = re.search(r"^AP:.*GHz-.*", ap_radio_value)
            if regex_check is not None:
                return True
            return False

        def get_aruba_login_details(self):
            """
            This function provides the csrf token for GET and POST calls
            """
            csrf_token = ""
            aruba_uid = ""
            try:
                url = f"{self.aruba_wlc_host}:4343/v1/api/login"

                payload = {
                    'username': self.username,
                    'password': self.password
                }
                files = []
                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded'
                }

                response = requests.request("POST", url, headers=headers, data=payload, files=files, verify=False)
                json_data = json.loads(response.text)
                if json_data:
                    _global_result = json_data.get('_global_result', '')
                    if _global_result:
                        csrf_token = _global_result.get('X-CSRF-Token', '')
                        aruba_uid = _global_result.get('UIDARUBA', '')

            except Exception as ex:
                demisto.error('Error while getting Login information from API Login' + str(ex))

            return aruba_uid, csrf_token

        def logout(self):
            """
            This function will terminate the session.
            """
            response = ''
            try:
                url = f"{self.aruba_wlc_host}:4343/v1/api/logout"
                response = requests.request("POST", url, verify=False)
            except Exception as ex:
                demisto.error('Error while logging out'+ str(ex))
            return response

        def run_wlc_command(self, command):
            """
            This function will run all the show commands.
            :return: json response
            """
            res = ''
            try:
                uid_dict = dict(SESSION=self.aruba_uid)
                command = str(command)
                url = f"{self.aruba_wlc_host}:4343/v1/configuration/showcommand?command={command}&UIDARUBA={self.aruba_uid}"
                payload = {}
                headers = {
                    'Content-Type': 'application/x-www-form-urlencoded'
                }
                if self.aruba_new_version_flag is True:
                    headers = {
                        "X-CSRF-Token": self.csrf_token,
                        "Content-Type": "application/x-www-form-urlencoded"
                    }
                response = requests.get(url, headers=headers, data=payload, cookies=uid_dict, verify=False)
                res = json.loads(response.text)
            except Exception as ex:
                demisto.error('Error while getting response from API'+ str(ex))
            return res

        def execute_command(self, command):
            """
            This function will run the execute command.
            :param: show command which user will enter manually.
            :return: json response
            """
            if command in (None, ''):
                raise Exception("Command can not be Null.")
            result = None

            try:
                result = self.run_wlc_command(command)
            except Exception as ex:
                msg = "Failed to run command %s, error %s" % (command, ex)
                raise msg
            finally:
                # Make sure we terminate the session of WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
                self.logout()

            return result

        def wlc_aruba_get_sysinfo(self):
            """
            Gives the system information
            :return: system_name, aruba_os
            """
            res = ""
            system_name = 'aruba_controller'
            aruba_os = 'unknown'
            try:
                cmd = 'show switchinfo'
                res = self.run_wlc_command(cmd)
                output = res.get('_data', '')
                if output:
                    for data in output:
                        lines = data.split("\n")
                        for line in lines:
                            if 'Hostname is' in line:
                                system_name = line.split('Hostname is')[1].strip()
                            elif 'ArubaOS' in line:
                                aruba_os = line
                                self.aruba_os_version = CommonUtility.extract_aruba_os_version(aruba_os)
                                self.aruba_version_prior_8_9_flag = CommonUtility.check_aruba_version_prior_8_9(self.aruba_os_version)
                            else:
                                continue
            except Exception as ex:
                demisto.error(f'Exception when getting sysinfo: {str(ex)}')
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format when getting sysinfo(Hostname and OS version) from WLC')

            return system_name, aruba_os

        def get_user_table_summary(self):
            """
            Function will get total clients in Aruba OS.
            """
            total_clients = 0
            try:
                cmd = 'show user-table summary'
                output = self.run_wlc_command(cmd)
                if isinstance(output, dict):
                    data = output.get('_data', '')
                    if data:
                        for _data in data:
                            if _data.find("Unique Users") > -1:
                                res = _data.split("Total Users: ")
                                total_clients = int(res[1])
            except Exception as ex:
                demisto.error(f'Exception when getting total clients: {str(ex)}')
            return total_clients

        def get_user_table(self):
            """
            From command - show user-table we will get ip-address and mac-address
            """
            mac_ip_dict = {}
            try:
                cmd = 'show user-table'
                output = self.run_wlc_command(cmd)
                if isinstance(output, dict):
                    data = output.get('Users', '')
                    if data:
                        # Creating a dictonary to make relation between mac address and ip address
                        for _data in data:
                            mac_address = _data.get('MAC', '')
                            ip_address = _data.get('IP', '')
                            if mac_address and ip_address:
                                mac_ip_dict[mac_address] = ip_address
            except Exception as ex:
                demisto.error(f'Exception when getting ip address and mac address: {str(ex)}')
            return mac_ip_dict

        def get_ap_details_ap_name(self, ap_name):
            """
            Function will show ap details.
            """
            ap_details = {}
            try:
                mac_cmd = "show ap details ap-name " + str(ap_name)
                output = self.run_wlc_command(mac_cmd)
                if isinstance(output, dict):
                    for value in output.values():
                        if value:
                            for data in value:
                                if isinstance(data, dict):
                                    if data['Item'] == 'Wired MAC Address':
                                        ap_details['ethernet_mac'] = data["Value"]
                                    if data['Item'] == 'Location Name':
                                        ap_details['location'] = data["Value"]
                                        if ap_details['location'] == 'N/A':
                                            ap_details['location'] = ''
                                    if data['Item'] == 'Port':
                                        ap_details['port'] = data["Value"]
                                        if ap_details['port'] == 'N/A':
                                            ap_details['port'] = ''
                                    if data['Item'] == 'AP Type':
                                        ap_details['ap_model'] = data["Value"]
                                        if ap_details['ap_model'] == 'N/A':
                                            ap_details['ap_model'] = ''
                                    # Including additional fields for APs
                                    if data['Item'] == 'Serial':
                                        ap_details['ap_serial'] = data["Value"]
                                        if ap_details['ap_serial'] == 'N/A':
                                            ap_details['ap_serial'] = ''
                                    if data['Item'] == 'Status':
                                        ap_details['ap_status'] = data["Value"]
                                        if ap_details['ap_status'] == 'N/A':
                                            ap_details['ap_status'] = ''
            except Exception as ex:
                demisto.error(f'Exception when getting active APs: {str(ex)}')
            return ap_details

        def get_ap_active(self, evt_content):
            """
            Function will get us all active APs.
            """
            ap_info = collections.defaultdict(dict)
            ap_radio_list = []
            try:
                cmd = "show ap active"
                output = self.run_wlc_command(cmd)
                if isinstance(output, dict):
                    data = output.get('Active AP Table', '')
                    if data:
                        # Getting total number of APs.
                        ap_count = len([count for count in data if count])
                        evt_content["totalAPs"] = ap_count
                total_ap = evt_content.get('totalAPs', 0)
                if total_ap > 0:
                    for _data in data:
                        ap_name = _data.get('Name', '')
                        ip_check = _data.get('IP Address', '')
                        if ip_check:
                            if self.is_valid_ipv4_address(ip_check):
                                ip_address = ip_check
                        for key, value in _data.items():
                            if 'Radio' in key and value is not None:
                                if self.is_valid_ap_radio(value):
                                    ap_radio_list.append(value)
                        ap_details = self.get_ap_details_ap_name(ap_name)
                        if ap_radio_list:
                            ap_radio_list = list(dict.fromkeys(ap_radio_list))
                        ap_info[ap_name]["ap_radio_list"] = ap_radio_list
                        ap_info[ap_name]["apName"] = ap_name
                        ap_info[ap_name]["apModel"] = ap_details.get('ap_model', '')
                        ap_info[ap_name]["apMacAddress"] = ap_details.get('ethernet_mac', '')
                        ap_info[ap_name]["apIPAddress"] = ip_address
                        ap_info[ap_name]["location"] = ap_details.get('location', '')
                        ap_info[ap_name]["client_list"] = []
                        ap_info[ap_name]["port"] = ap_details.get('port', '')
                        ap_info[ap_name]["ap_serial"] = ap_details.get('ap_serial', '')
                        ap_info[ap_name]["ap_status"] = ap_details.get('ap_status', '')
            except Exception as ex:
                demisto.error(f'Exception when getting active APs: {str(ex)}')
            return ap_info, ap_name

        def get_ap_details(self, evt_content):
            """ Gets the access points details from Aruba

            :param evt_content: event content dictionary holding the data format
            :return: ap_name(str), ap_info(dict)
            """
            ap_info = []
            ap_name = ''
            try:
                # Command to get total clients in Aruba OS
                evt_content["totalClients"] = self.get_user_table_summary()
                # from command - show user-table we will get ip-address and mac-address
                mac_ip_dict = self.get_user_table()
                # Get AP information.
                ap_info, ap_name = self.get_ap_active(evt_content)
            except Exception as ex:
                demisto.error(f'Exception when getting AP details: {str(ex)}')
            return ap_name, ap_info, mac_ip_dict

        def get_ap_association_client_mac(self, mac_address):
            """
            Function will give us channel.
            """
            channel = ''
            try:
                cmd = 'show ap association client-mac '+ mac_address
                output = self.run_wlc_command(cmd)
                if isinstance(output, dict):
                    for value in output.values():
                        for data in value:
                            if isinstance(data, dict):
                                parameter = data.get('Parameter', '')
                                if parameter == 'Channel':
                                    channel = data['Value']
            except Exception as ex:
                demisto.error(f'Exception when getting channel: {str(ex)}')
            return channel

        def get_ap_debug_client_stats(self, mac_address):
            """
            Function will give snr value.
            """
            snr = ''
            try:
                cmd = 'show ap debug client-stats client-mac ' + mac_address
                output = self.run_wlc_command(cmd)
                if isinstance(output, dict):
                    data = output.get('Station Stats', '')
                    if data:
                        for _data in data:
                            if _data['Parameter'] == 'Rx Last SNR':
                                if _data['Value'] is not None:
                                    snr = _data['Value']
            except Exception as ex:
                demisto.error(f'Exception when getting snr value: {str(ex)}')
            return snr

        def get_user_table_ip(self, ip_address):
            """
            Function will get client details through ip address.
            """
            client_data = {}
            try:
                cmd = 'show user-table ip '+ str(ip_address)
                output = self.run_wlc_command(cmd)
                if isinstance(output, dict):
                    data = output.get('_data', '')
                    if data:
                        res = {}
                        for _data in data:
                            _res = ''
                            # Here we will convert list of csv into dictonary.
                            try:
                                if len(_data.split(":")) == 2:
                                    _res = _data.split(":", 1)
                                    if _res[0] in res:
                                        continue
                                    res.update({_res[0]:_res[1]})
                                elif len(_data.split(":")) > 2:
                                    # Converting list string to dictionary
                                    _res = {sub.split(":", 1)[0]: sub.split(":", 1)[1] for sub in _data.split(", ")}
                                    for key, value in _res.items():
                                        if key in res:
                                            continue
                                        res.update({key:value})
                            except:
                                pass
                        if res:
                            client_data['connected_duration'] = res.get('Age', '').strip()
                            client_data['device_type'] = res.get('Device Type', '').strip()
                            client_data['auth_method'] = res.get('method', '').strip()
                            client_data['auth_status'] = res.get('Authentication', '').strip()
            except Exception as ex:
                demisto.error(f'Exception when running show user table ip command: {str(ex)}')
            return client_data

        def get_ap_debug_client_table(self, active_ap, mac_ip_dict):
            """
            Function will get client table.
            """
            client_info_list = []
            try:
                cmd = "show ap debug client-table ap-name " + str(active_ap)
                output = self.run_wlc_command(cmd)
                if isinstance(output, dict):
                    data = output.get('Client Table', '')
                    if data:
                        for _data in data:
                            client_info = {}
                            mac_address = _data.get('MAC', '')
                            ssid = _data.get('ESSID', '')
                            status = _data.get('Assoc_State', '')
                            if mac_address:
                                # Command to get channel.
                                channel = self.get_ap_association_client_mac(mac_address)
                                # Command to get snr
                                snr = self.get_ap_debug_client_stats(mac_address)

                                """
                                Replace the show user mac <mac-address> command with below mentioned series of commands in the order mentioned below
                                1. From command - show user-table we take ip_address and mac_address and create a dictonary 'mac_ip_dict[mac_address]: ip_address'.
                                2. Run show ap association client-mac <mac-address> above to get channel.
                                3. Run command - show user-table ip <ip-address> to get remaining fields.
                                """
                                if mac_ip_dict:
                                    ip_address = mac_ip_dict.get(mac_address, '')
                                    if ip_address:
                                        client_data = self.get_user_table_ip(ip_address)
                                client_info["macAddress"] = mac_address
                                client_info["channel"] = channel
                                client_info["ipAddress"] = ip_address
                                client_info["SSID"] = ssid
                                client_info["status"] = status
                                client_info["deviceType"] = client_data.get('device_type', '')
                                client_info["snr"] = snr
                                client_info["connectedDuration"] = client_data.get('connected_duration', '')
                                client_info["authMethod"] = client_data.get('auth_method', '')
                                client_info["authenticationStatus"] = client_data.get('auth_status', '')
                                client_info["isBluetooth"] = False
                                client_info_list.append(client_info)
            except Exception as ex:
                demisto.error(f'Exception when getting client table: {str(ex)}')
            return client_info_list

        def wlc_aruba_get_active_clients(self, active_ap, mac_ip_dict):
            """ Gets the information about all clients connected to access points.

            :param evt_content: event content dictionary holding the data format
            :param active_ap: active ap name
            :param mac_ip_dict: Dictonary in which mac address is key and ip address is its value.
            """
            if not active_ap:
                return None

            # converting active_ap to string if it is in bytes
            try:
                active_ap = active_ap.decode('utf-8')
            except (UnicodeDecodeError, AttributeError):
                pass
            try:
                client_info_list = self.get_ap_debug_client_table(active_ap, mac_ip_dict)
            except Exception as ex:
                demisto.error('Error while getting the information about all clients connected to access points.' + str(ex))
            return client_info_list

        def wlc_aruba_get_monitored_clients(self, active_ap, client_mac_id):
            """ Gets the information about all clients connected to access points.

            :param evt_content: event content dictionary holding the data format
            :param active_ap: active ap name
            :param client_mac_id: client mac id
            """
            if not active_ap:
                return None
            try:
                client_info_list = []
                cmd = "show ap monitor client-list ap-name " + str(active_ap)
                output = self.run_wlc_command(cmd)

                if isinstance(output, dict):
                    data = output.get('Monitored Client Table', '')
                    if data:
                        for _data in data:
                            client_info = {}
                            radio = ''
                            mac_address = _data.get('mac', '')
                            if mac_address == client_mac_id:
                                client_info["macAddress"] = mac_address
                                # Radio value is not available as phy-type is removed in versions above 8.9.0.0
                                if self.aruba_version_prior_8_9_flag:
                                    phy_type = _data.get('phy-type', '')
                                    if phy_type:
                                        if '80211a' in phy_type:
                                            radio = '802.11a'
                                        if '80211b/g' in phy_type:
                                            radio = '802.11b/g'
                                else:
                                    band = _data.get('band/chan/ch-width/ht-type', '')
                                    if band:
                                        frequency = band.split('/')[0]
                                        if frequency == '6GHz':
                                            radio = '802.11ax'
                                        if frequency == '5GHz':
                                            radio = '802.11a'
                                        if frequency == '2.4GHz':
                                            radio = '802.11b/g'
                                client_info["radio"] = radio
                                client_info['rssi'] = _data.get('rssi', '')
                                client_info['snr'] = _data.get('snr', '')
                                client_info['SSID'] = _data.get('essid', '')
                                client_info['BSSID'] = _data.get('bssid', '')
                                client_info_list.append(client_info)
            except Exception as ex:
                demisto.error('Error while getting information' + str(ex))
            return client_info_list

        def __wlc_get_monitored_client_details(self, evt_content, active_ap, client_mac_id):
            # Monitored client info
            client_bssid = ''
            monitored_client_dict = ''
            try:
                monitored_client_info_list = self.wlc_aruba_get_monitored_clients(
                    active_ap, client_mac_id)
                if monitored_client_info_list:
                    monitored_client_dict = monitored_client_info_list.pop()
                    client_bssid = monitored_client_dict.get('BSSID', '')
            except Exception as ex:
                demisto.error('Error while getting monitored client information' + str(ex))
            return client_bssid, monitored_client_dict

        @staticmethod
        def __populate_radio_details(client_dict, ap_radio_list):
            """
            Function is to populate radio details
            :param client_dict: client data dictonary.
            :param ap_radio_list: radio list.
            """
            try:
                channel = client_dict.get('channel', '')
                if channel:
                    for radio in ap_radio_list:
                        if ':{}'.format(channel) in radio:
                            frequency_str = radio.split(':')[1].strip()
                            frequency = frequency_str.split('-')[0].strip()
                            client_dict['radio'] = client_dict.get('radio', '') + ' [' + frequency + ']'
                            client_dict['slot_id'] = 'Radio ' + str(ap_radio_list.index(radio))
            except Exception as ex:
                demisto.error('Error while populating radio details' + str(ex))
            return client_dict

        def wlc_aruba_get_monitored_aps(self, active_ap, client_bssid):
            """ Gets the information about all clients connected to access points.

            :param active_ap: active ap name
            """
            if not active_ap:
                return None
            ap_info_list = []
            try:
                cmd = "show ap monitor ap-list ap-name " + str(active_ap)
                output = self.run_wlc_command(cmd)
                if isinstance(output, dict):
                    data = output.get('Monitored AP Table', '')
                    if data:
                        for _data in data:
                            bssid = CommonUtility.extract_valid_bssid(_data.get('bssid', ''))
                            if bssid == client_bssid:
                                ap_info = {}
                                radio = ''
                                auth_method = ''
                                encryption_cipher = ''
                                if _data['encr'] == 'open':
                                    auth_method = 'Open System'
                                    encryption_cipher = 'open'
                                if _data['encr'] == 'wpa2-8021x-aes':
                                    auth_method = 'WPA2 802.1x'
                                    encryption_cipher = 'CCMP-128 (AES)'
                                if _data['encr'] == 'wpa2-psk-aes':
                                    auth_method = 'WPA2 PSK'
                                    encryption_cipher = 'CCMP-128 (AES)'
                                if self.aruba_version_prior_8_9_flag:
                                    phy_type = _data.get('phy-type', '')
                                    if phy_type:
                                        if '80211a' in phy_type:
                                            radio = '802.11a'
                                        if '80211b/g' in phy_type:
                                            radio = '802.11b/g'
                                        if '802' not in phy_type:
                                            continue
                                else:
                                    band = _data.get('band/chan/ch-width/ht-type', '')
                                    if band:
                                        frequency = band.split('/')[0]
                                        if frequency == '6GHz':
                                            radio = '802.11ax'
                                        if frequency == '5GHz':
                                            radio = '802.11a'
                                        if frequency == '2.4GHz':
                                            radio = '802.11b/g'
                                ap_info["BSSID"] = bssid
                                ap_info["radio"] = radio
                                ap_info['rssi'] = _data.get('curr-rssi', '').strip()
                                ap_info['snr'] = _data.get('curr-snr', '').strip()
                                ap_info['SSID'] = _data.get('essid', '').strip()
                                ap_info['authMethod'] = auth_method.strip()
                                ap_info['encryptionCipher'] = encryption_cipher.strip()
                                ap_info_list.append(ap_info)
                                break
            except Exception as ex:
                demisto.error('Exception while getting information about all clients connected to access points' + str(ex))
            return ap_info_list

        def wlc_aruba_get_ap_summary(self, evt_content, aruba_os):
            """ Gets the access points summary information from the API

            :param evt_content: event content dictionary holding the data format
            """
            try:
                evt_content["uniqueClients"] = 0
                ap_name, ap_info, mac_ip_dict = self.get_ap_details(evt_content)
                for ap_name in ap_info:
                    active_ap = ap_name
                    client_mac_id = ''
                    client_bssid = ''
                    total_clients = evt_content["totalClients"]
                    if total_clients > 0:
                        client_info_list = self.wlc_aruba_get_active_clients(
                            active_ap, mac_ip_dict)
                        if client_info_list:
                            evt_content["uniqueClients"] += len(client_info_list)
                            for each_dict in client_info_list:
                                client_mac_id = each_dict.get('macAddress', '')
                                client_bssid, monitored_client_dict = self.__wlc_get_monitored_client_details(
                                    evt_content, active_ap, client_mac_id)
                                if monitored_client_dict:
                                    each_dict.update(monitored_client_dict)
                                if len(ap_info[ap_name]["ap_radio_list"]) > 0:
                                    each_dict = self.__populate_radio_details(
                                        each_dict, ap_info[ap_name]["ap_radio_list"])
                                ap_info[ap_name]["client_list"].append(each_dict)
                #                 # Monitored AP info
                                ap_info_list = self.wlc_aruba_get_monitored_aps(active_ap, client_bssid)
                                if ap_info_list:
                                    ap_info[ap_name]["monitor_ap_list"] = ap_info_list.pop()
                evt_content['ap_list'] = []
                for key in sorted(ap_info):
                    dic = {key: ap_info[key]}
                    evt_content['ap_list'].append(dic)
            except Exception as ex:
                demisto.error(f'Exception when getting AP summary: {str(ex)}')
                demisto.error(traceback.format_exc())
                t_back = sys.exc_info()[-1]
                stk = traceback.extract_tb(t_back, 1)
                fname = stk[0][2]
                raise Exception('Unsupported format from OS - %s when getting AP summary from WLC %s %s' % (aruba_os, str(ex), fname))

        @staticmethod
        def wlc_aruba_flatten_ap_list(evt_content, aruba_os):
            """
            Function will format the response
            """
            try:
                ap_list_dict = []
                if "ap_list" in evt_content:
                    ap_list_dict = evt_content["ap_list"]
                else:
                    evt_content["ap_list"] = []
                del evt_content["ap_list"]
                flatten_list = []
                for item in ap_list_dict:
                    dic = item
                    for val in dic.values():
                        flatten_list.append(val)
                evt_content["ap_list"] = flatten_list
            except Exception as ex:
                demisto.error(f'Exception when flattening AP list: {str(ex)}')
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format when flattening AP list from WLC OS: %s. Error: %s' % (aruba_os, str(ex)))

        @staticmethod
        def wlc_construct_source_fields_from_json(evt_content, system_name):
            """
            Function will construct source fields from json.
            """
            try:
                json_obj = {}
                source = {}
                wlc_id = system_name
                tenant_id = 's3fvtu3j'
                inspector_id = '44454C4C5800104D8037B1C04F315132'

                source["eventLevel"] = "EV_EVENT"
                source["evtType"] = "evt_wlc_output"
                source["tenantid"] = tenant_id
                source["evtContent"] = evt_content
                json_obj["evtSource"] = "wireless_controller"
                json_obj["wlcId-tenant-inspector"] = wlc_id + tenant_id + inspector_id
                json_obj["timestamp"] = int(time.time())
                json_obj["_source"] = source
            except Exception as ex:
                demisto.error('Error while constructing source fields from json' + str(ex))
            return json_obj

        def wlc_get_devices_data(self):
            """ main function for pulling the information from wireless controller from the inspector

            This function calls other subroutines responsible for individual chunk of work and is the
            only entry point in data path. It constructs a JSON object and write into the file
            which can be consumed by API team to display the wireless data onto dashboard.

            """
            evt_content = {}
            json_obj = {}
            try:
                system_name, aruba_os = self.wlc_aruba_get_sysinfo()
                self.wlc_aruba_get_ap_summary(evt_content, aruba_os)
                self.wlc_aruba_flatten_ap_list(evt_content, aruba_os)

                filename = ''
                if system_name:
                    timestamp = str(strftime('%Y-%m-%d_%H:%M:%S', gmtime()))
                    filename = str(system_name + '_') + timestamp
                    evt_content['file-id'] = filename
                    json_obj = self.wlc_construct_source_fields_from_json(evt_content, system_name)
            except Exception as ex:
                demisto.error('Error while getting device data' + str(ex))
                raise ex
            finally:
               # Make sure we terminate the session of WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
                self.logout()

            return json_obj

        @staticmethod
        def __format_duration_timestamp(duration):
            conn_duration = ''
            try:
                duration_dict = {
                    "h": '00',
                    "m": '00',
                    "s": '00'
                }
                duration_values = duration.split(':')
                for val in duration_values:
                    if 'h' in val:
                        duration_dict['h'] = val.split('h')[0]
                        if len(val.split('h')[0]) < 2:
                            duration_dict['h'] = '0' + duration_dict['h']
                    if 'm' in val:
                        duration_dict['m'] = val.split('m')[0]
                        if len(val.split('m')[0]) < 2:
                            duration_dict['m'] = '0' + duration_dict['m']
                    if 's' in val:
                        duration_dict['s'] = val.split('s')[0]
                        if len(val.split('s')[0]) < 2:
                            duration_dict['s'] = '0' + duration_dict['s']
                conn_duration = duration_dict['h'] + ':' + duration_dict['m'] + ':' + duration_dict['s']
            except Exception as ex:
                demisto.error('Exception while format duration timestamp' + str(ex))
            return conn_duration

        def get_ble_client_aruba_beacon(self, client_data):
            """
            Function will give all info about BLE Device Aruba Beacons.
            :param client_data: Client data.
            """
            client_info_list = []
            try:
                if client_data:
                    for _data in client_data:
                        client_info = {}
                        bt_device_type = ''
                        bt_sig_corp_id = ''
                        hwType = ''
                        fwVersion = ''
                        bluetoothAddressType = ''
                        connected_duration = ''
                        conn_state = 'No'
                        status = ''
                        # Defaulting BT type to BLE
                        bt_type = 'BLE'
                        if _data.get('Status', '').strip() != "--":
                            status = _data.get('Status', '').strip()
                        if _data.get('Uptime', '').strip() != "--":
                            connected_duration = _data.get('Uptime', '').strip()
                            if connected_duration:
                                connected_duration = self.__format_duration_timestamp(connected_duration)
                                conn_state = 'Yes'
                        else:
                            connected_duration = '00:00:00'
                            conn_state = 'No'
                        if 'L' in status:
                            bt_device_type += "AP\'s local beacon"
                        if 'I' in status:
                            bt_device_type += ":" + "iBeacon"
                        if 'A' in status:
                            bt_device_type += ":" + "Beacon management capable"
                        if 'H' in status:
                            bt_device_type += ":" + "High power beacon"
                        if 'T' in status:
                            bt_device_type += ":" + "Asset Tag Beacon"
                        if 'U' in status:
                            bt_device_type += ":" + "Upgrade of firmware pending"
                        if 'u' in status:
                            bt_device_type += ":" + "Beacon management update received"

                        if _data.get('BT-SIG Company IDs', '').strip() != "--":
                            bt_sig_corp_id = _data.get('BT-SIG Company IDs', '').strip()
                        if _data.get('HW_Type', '').strip() != "--":
                            hwType = _data.get('HW_Type', '').strip()
                        if _data.get('FW_Ver', '').strip() != "--":
                            fwVersion = _data.get('FW_Ver', '').strip()
                        if _data.get('Address Type', '').strip() != "--":
                            bluetoothAddressType = _data.get('Address Type', '').strip()

                        client_info["macAddress"] = _data.get('MAC', '')
                        client_info["bluetoothType"] = bt_type
                        client_info["bluetoothDeviceType"] = bt_device_type
                        client_info["connectionState"] = conn_state
                        client_info["connectedDuration"] = connected_duration
                        client_info["hwType"] = hwType
                        client_info["fwVersion"] = fwVersion
                        client_info["bluetoothAddressType"] = bluetoothAddressType
                        client_info["bluetoothCompanyId"] = bt_sig_corp_id
                        client_info["isBluetooth"] = True

                        client_info_list.append(client_info)
            except Exception as ex:
                demisto.error("Exception when getting BLE Device Aruba Beacons, error message- "+str(ex))
            return client_info_list

        def get_ble_client_apb(self, client_data):
            """
            Function will give all info about BLE Device APB's.
            :param client_data: Client data.
            """
            client_info_list = []
            try:
                if client_data:
                    for _data in client_data:
                        client_info = {}
                        bt_device_type = ''
                        bt_sig_corp_id = ''
                        hwType = ''
                        fwVersion = ''
                        bluetoothAddressType = ''
                        connected_duration = ''
                        conn_state = 'No'
                        status = ''
                        # Defaulting BT type to BLE
                        bt_type = 'BLE'
                        if _data.get('Status', '').strip() != "--":
                            status = _data.get('Status', '').strip()
                        if _data.get('Uptime', '').strip() != "--":
                            connected_duration = _data.get('Uptime', '').strip()
                            if connected_duration:
                                connected_duration = self.__format_duration_timestamp(connected_duration)
                                conn_state = 'Yes'
                        else:
                            connected_duration = '00:00:00'
                            conn_state = 'No'
                        if 'L' in status:
                            bt_device_type += "AP\'s local beacon"
                        if 'I' in status:
                            bt_device_type += ":" + "iBeacon"
                        if 'A' in status:
                            bt_device_type += ":" + "Beacon management capable"
                        if 'H' in status:
                            bt_device_type += ":" + "High power beacon"
                        if 'T' in status:
                            bt_device_type += ":" + "Asset Tag Beacon"
                        if 'U' in status:
                            bt_device_type += ":" + "Upgrade of firmware pending"
                        if 'u' in status:
                            bt_device_type += ":" + "Beacon management update received"

                        if _data.get('BT-SIG Company IDs', '').strip() != "--":
                            bt_sig_corp_id = _data.get('BT-SIG Company IDs', '').strip()
                        if _data.get('HW_Type', '').strip() != "--":
                            hwType = _data.get('HW_Type', '').strip()
                        if _data.get('FW_Ver', '').strip() != "--":
                            fwVersion = _data.get('FW_Ver', '').strip()
                        if _data.get('Address Type', '').strip() != "--":
                            bluetoothAddressType = _data.get('Address Type', '').strip()

                        client_info["macAddress"] = _data.get('MAC', '')
                        client_info["bluetoothType"] = bt_type
                        client_info["bluetoothDeviceType"] = bt_device_type
                        client_info["connectionState"] = conn_state
                        client_info["connectedDuration"] = connected_duration
                        client_info["hwType"] = hwType
                        client_info["fwVersion"] = fwVersion
                        client_info["bluetoothAddressType"] = bluetoothAddressType
                        client_info["bluetoothCompanyId"] = bt_sig_corp_id
                        client_info["isBluetooth"] = True

                        client_info_list.append(client_info)
            except Exception as ex:
                demisto.error("Exception when getting BLE Device APB's, error message- "+str(ex))
            return client_info_list

        def get_ble_client_asset_tag(self, client_data):
            """
            Function will give all info about BLE Device Asset Tags.
            :param client_data: Client data.
            """
            client_info_list = []
            try:
                if client_data:
                    for _data in client_data:
                        client_info = {}
                        bt_device_type = ''
                        bt_sig_corp_id = ''
                        hwType = ''
                        fwVersion = ''
                        bluetoothAddressType = ''
                        connected_duration = ''
                        conn_state = 'No'
                        status = ''
                        # Defaulting BT type to BLE
                        bt_type = 'BLE'
                        if _data.get('Status', '').strip() != "--":
                            status = _data.get('Status', '').strip()
                        if _data.get('Uptime', '').strip() != "--":
                            connected_duration = _data.get('Uptime', '').strip()
                            if connected_duration:
                                connected_duration = self.__format_duration_timestamp(connected_duration)
                                conn_state = 'Yes'
                        else:
                            connected_duration = '00:00:00'
                            conn_state = 'No'
                        if 'L' in status:
                            bt_device_type += "AP\'s local beacon"
                        if 'I' in status:
                            bt_device_type += ":" + "iBeacon"
                        if 'A' in status:
                            bt_device_type += ":" + "Beacon management capable"
                        if 'H' in status:
                            bt_device_type += ":" + "High power beacon"
                        if 'T' in status:
                            bt_device_type += ":" + "Asset Tag Beacon"
                        if 'U' in status:
                            bt_device_type += ":" + "Upgrade of firmware pending"
                        if 'u' in status:
                            bt_device_type += ":" + "Beacon management update received"

                        if _data.get('BT-SIG Company IDs', '').strip() != "--":
                            bt_sig_corp_id = _data.get('BT-SIG Company IDs', '').strip()
                        if _data.get('HW_Type', '').strip() != "--":
                            hwType = _data.get('HW_Type', '').strip()
                        if _data.get('FW_Ver', '').strip() != "--":
                            fwVersion = _data.get('FW_Ver', '').strip()
                        if _data.get('Address Type', '').strip() != "--":
                            bluetoothAddressType = _data.get('Address Type', '').strip()

                        client_info["macAddress"] = _data.get('MAC', '')
                        client_info["bluetoothType"] = bt_type
                        client_info["bluetoothDeviceType"] = bt_device_type
                        client_info["connectionState"] = conn_state
                        client_info["connectedDuration"] = connected_duration
                        client_info["hwType"] = hwType
                        client_info["fwVersion"] = fwVersion
                        client_info["bluetoothAddressType"] = bluetoothAddressType
                        client_info["bluetoothCompanyId"] = bt_sig_corp_id
                        client_info["isBluetooth"] = True

                        client_info_list.append(client_info)
            except Exception as ex:
                demisto.error("Exception when getting BLE Device Asset Tags, error message- "+str(ex))
            return client_info_list

        def get_ble_client_generic(self, client_data):
            """
            Function will give all info about BLE Device Generic.
            :param client_data: Client data.
            """
            client_info_list = []
            try:
                if client_data:
                    for _data in client_data:
                        client_info = {}
                        connected_duration = ''
                        conn_state = 'Yes'
                        bt_device_type = ''
                        bt_sig_corp_id = ''
                        hwType = ''
                        fwVersion = ''
                        bluetoothAddressType = ''
                        if _data.get('Address Type', '').strip() != "--":
                            bluetoothAddressType = _data.get('Address Type', '').strip()
                        if bluetoothAddressType == 'Public':
                            # Defaulting BT type to BLE
                            bt_type = 'BLE'
                            # Get BLE device type
                            if _data.get('Device Class', '').strip() != "--":
                                bt_device_type = _data.get('Device Class', '').strip()
                            # Get BLE Sig company id
                            if _data.get('BT-SIG Company IDs', '').strip() != "--":
                                bt_sig_corp_id = _data.get('BT-SIG Company IDs', '').strip()
                            if _data.get('HW_Type', '').strip() != "--":
                                hwType = _data.get('HW_Type', '').strip()
                            if _data.get('FW_Ver', '').strip() != "--":
                                fwVersion = _data.get('FW_Ver', '').strip()

                            client_info["macAddress"] = _data.get('MAC', '')
                            client_info["bluetoothType"] = bt_type
                            client_info["bluetoothDeviceType"] = bt_device_type
                            client_info["connectionState"] = conn_state
                            client_info["connectedDuration"] = connected_duration
                            client_info["hwType"] = hwType
                            client_info["fwVersion"] = fwVersion
                            client_info["bluetoothAddressType"] = bluetoothAddressType
                            client_info["bluetoothCompanyId"] = bt_sig_corp_id
                            client_info["isBluetooth"] = True
                            client_info_list.append(client_info)
            except Exception as ex:
                demisto.error("Exception when getting BLE Device Generic, error message- "+str(ex))
            return client_info_list

        def wlc_aruba_get_active_bt_clients(self, active_ap):
            """ Gets the information about all bluetooth clients connected to access points.

            :param evt_content: event content dictionary holding the data format
            :param active_ap: active ap name
            """
            client_info_list = []
            if not active_ap:
                return None
            # converting active_ap to string if it is in bytes
            try:
                active_ap = active_ap.decode('utf-8')
            except (UnicodeDecodeError, AttributeError):
                pass
            cmd = "show ap debug ble-table ap-name " + str(active_ap) + ' all'
            try:
                output = self.run_wlc_command(cmd)
                if isinstance(output, dict):
                    if output:
                        aruba_beacon_data = output.get('BLE Device Table [Aruba Beacons]', '')
                        aruba_beacon_client_info = self.get_ble_client_aruba_beacon(aruba_beacon_data)
                        if aruba_beacon_client_info:
                            client_info_list.extend(aruba_beacon_client_info)
                        generic_data = output.get(' BLE Device Table [Generic]', '')
                        generic_client_info = self.get_ble_client_generic(generic_data)
                        if generic_client_info:
                            client_info_list.extend(generic_client_info)
                        apb_data = output.get('BLE Device Table [APBs]', '')
                        apb_client_info = self.get_ble_client_apb(apb_data)
                        if apb_client_info:
                            client_info_list.extend(apb_client_info)
                        asset_tags_data = output.get(' BLE Device Table [Asset Tags]', '')
                        asset_tags_client_info = self.get_ble_client_asset_tag(asset_tags_data)
                        if asset_tags_client_info:
                            client_info_list.extend(asset_tags_client_info)
            except Exception as ex:
                raise Exception("Exception when getting AP summary, error message- "+str(ex))
            return client_info_list

        def wlc_aruba_get_bt_ap_summary(self, evt_content, aruba_os):
            """ Gets the access points summary information from the API

            :param evt_content: event content dictionary holding the data format
            """
            try:
                ap_name, ap_info, mac_ip_dict = self.get_ap_details(evt_content)
                evt_content["uniqueClients"] = 0
                for ap_name in ap_info:
                    active_ap = ap_name
                    total_clients = evt_content["totalClients"]
                    if total_clients > 0:
                        client_info_list = self.wlc_aruba_get_active_bt_clients(active_ap)
                        if client_info_list:
                            evt_content["uniqueClients"] += len(client_info_list)
                            for each_dict in client_info_list:
                                ap_info[ap_name]["client_list"].append(each_dict)
                    evt_content['ap_list'] = []
                    for key in sorted(ap_info):
                        dic = {key: ap_info[key]}
                        evt_content['ap_list'].append(dic)
            except Exception as ex:
                demisto.error(f'Exception when getting bluetooth AP summary: {str(ex)}')
                raise Exception('Unsupported format when getting bluetooth AP summary from WLC OS: %s. Error: %s' % (aruba_os, str(ex)))

        def wlc_get_bluetooth_devices_data(self):
            """ main function for pulling the information from wireless controller from the inspector

            This function calls other subroutines responsible for individual chunk of work and is the
            only entry point in data path. It constructs a JSON object and write into the file
            which can be consumed by API team to display the wireless data onto dashboard.

            """
            evt_content = {}
            json_obj = None

            try:
                system_name, aruba_os = self.wlc_aruba_get_sysinfo()
                self.wlc_aruba_get_bt_ap_summary(evt_content, aruba_os)
                self.wlc_aruba_flatten_ap_list(evt_content, aruba_os)

                filename = ''
                if system_name:
                    timestamp = str(strftime('%Y-%m-%d_%H:%M:%S', gmtime()))
                    filename = str(system_name + '_') + timestamp
                    evt_content['file-id'] = filename
                    json_obj = self.wlc_construct_source_fields_from_json(evt_content, system_name)
            finally:
                # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
                demisto.info('WLC info closing connection')
                self.logout()
            return json_obj



        def wlc_get_all_iap(self):
            """ function for pulling the Instant APs information from wireless controller.
            :return: list of all the iap devices.
            """
            iap_list = []
            try:
                cmd = "show iap detailed-table long"
                output = self.run_wlc_command(cmd)
                if isinstance(output, dict):
                    data = output.get('All Switches', '')
                    if data:
                        for _data in data:
                            iap_data = {}
                            iap_data['vc_mac_address'] = _data.get('VC MAC Address', '')
                            ip_check = _data.get('Inner IP', '')
                            if ip_check:
                                if self.is_valid_ipv4_address(ip_check):
                                    iap_data['vc_inner_ip_address'] = ip_check
                            iap_data = CommonUtility.iap_mapping(_data)
                            iap_list.append(iap_data)
            finally:
                self.logout()
            return iap_list


        def wlc_get_switch_details(self):
            """ function for pulling the Switch information from wireless controller.
            :return: list of switches
            """
            switch_list = []
            try:
                cmd = "show switches debug"
                output = self.run_wlc_command(cmd)
                if isinstance(output, dict):
                    data = output.get('All Switches', '')
                    if data:
                        for _data in data:
                            switch_data = {}
                            switch_data['switch_macaddress'] = _data.get('MAC', '')
                            ip_check = _data.get('IP Address', '')
                            if ip_check:
                                if self.is_valid_ipv4_address(ip_check):
                                    switch_data['switch_ip_address'] = ip_check
                            # Using swtich mapping methods to map fields.
                            switch_data = CommonUtility.switch_mapping(_data)
                            switch_list.append(switch_data)
            finally:
                self.logout()
            return switch_list

        def wlc_get_active_ap(self):
            """ function for pulling the AP information from wireless controller from the inspector
            :return: list of active APs
            """
            active_ap_list = []
            ap_radio_list = []
            ap_name = ''
            try:
                cmd = "show ap active"
                output = self.run_wlc_command(cmd)
                if isinstance(output, dict):
                    data = output.get('Active AP Table', '')
                    if data:
                        for _data in data:
                            active_ap = {}
                            for key, value in _data.items():
                                if 'Radio' in key and value is not None:
                                    if self.is_valid_ap_radio(value):
                                        ap_radio_list.append(value)
                            ap_name = _data.get('Name', '')
                            ap_details = self.get_ap_details_ap_name(ap_name)
                            active_ap['apMacAddress'] = _data.get('Name', '')
                            ip_check = _data.get('IP Address', '')
                            if ip_check:
                                if self.is_valid_ipv4_address(ip_check):
                                    active_ap['apIPAddress'] = ip_check
                            active_ap['apModel'] = _data.get('AP Type', '')
                            active_ap['apName'] = ap_name
                            active_ap['ap_serial'] = ap_details.get('ap_serial', '')
                            active_ap["ap_radio_list"] = ap_radio_list
                            active_ap["location"] = ap_details.get('location', '')
                            active_ap["port"] = ap_details.get('port', '')
                            active_ap["ap_status"] = ap_details.get('ap_status', '')
                            active_ap_list.append(active_ap)
            finally:
                self.logout()
            return active_ap_list

        def wlc_get_active_client_list(self, args):

            """ function for pulling the clients information from wireless controller from the inspector
            :return: list of active clients
            """
            client_list = []
            try:
                ap_name = args.get('ap_name')
                cmd = "show ap debug client-table ap-name {}".format(ap_name)
                output = self.run_wlc_command(cmd)
                if isinstance(output, dict):
                    data = output.get('Client Table', '')
                    if data:
                        for _data in data:
                            mac_address = _data.get('MAC', '')
                            if mac_address:
                                client_list.append(mac_address)
            finally:
                # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
                self.logout()
            return client_list

        @staticmethod
        def __extract_aruba_wlc_device_data(mac_address, client_data):
            """
            Function will extract Aruba WLC device data.
            :param mac_address: mac-address.
            :param client_data: client data.
            """
            data = {}
            try:
                ap_list = client_data.get('_source', {}).get('evtContent', {}).get('ap_list', [])
                for access_point in ap_list:
                    clients_list = access_point.get('client_list', [])
                    for client in clients_list:
                        data = {}
                        client_mac = client.get('macAddress', '').lower()
                        if mac_address == client_mac:
                            data['MAC Address'] = client_mac
                            data['IP Address'] = client.get('ipAddress', '')
                            data['Radio'] = client.get('radio', '')
                            data['Connection State'] = client.get('status', '')
                            data['SSID'] = client.get('SSID', '')
                            data['Connected Duration'] = client.get('connectedDuration', '')
                            data['Auth Method'] = client.get('authMethod', '').strip()
                            data['Encryption Cipher'] = access_point.get('monitor_ap_list').get('encryptionCipher', '')
                            data['RSSI'] = client.get('rssi', '')
                            data['SNR'] = client.get('snr', '')
                            data['Authentication Status'] = client.get('authenticationStatus', '')
                            data['BSSID'] = client.get('BSSID', '')
                            data['Device Type'] = client.get('deviceType', '')
                            data['AP Name'] = access_point.get('apName', '')
                            data['AP IP Address'] = access_point.get('apIPAddress', '')
                            data['AP MAC Address'] = access_point.get('apMacAddress', '')
                            data['AP Model'] = access_point.get('apModel', '')
                            data['AP Encryption Cipher'] = access_point.get('monitor_ap_list').get('encryptionCipher', '')
                            data['AP Radio Slot ID'] = client.get('slot_id', '')
                            data['Location'] = access_point.get('location', '')
                            break
            except Exception as ex:
                demisto.error("Exception while extracting device data: %s" % str(ex))
            return data

        def wlc_get_client_details_using_mac(self, args):
            """ function for pulling the client information from wireless controller from the inspector
            :return: client details
            """
            active_client_details = ''
            try:
                mac_address = args.get('mac_address')
                client_data = self.wlc_get_devices_data()
                active_client_details = self.__extract_aruba_wlc_device_data(mac_address, client_data)
                if not active_client_details:
                    active_client_details = {}
            except Exception as ex:
                demisto.error("Exception when getting client details using mac address: %s" % str(ex))
                raise ex
            return active_client_details


    class ArubaControllerSSHParser:
        """
        Class is to fetch Aruba OS device data from SSH.
        """
        def __init__(self):
            self.aruba_wlc_host = self.check_aruba_wlc_host()
            self.username = demisto.params().get('credentials', {}).get('identifier')
            self.password = demisto.params().get('credentials', {}).get('password')
            self.aruba_version_prior_8_9_flag = True
            self.net_connect = self.connection_handler()

        def check_aruba_wlc_host(self):
            """
            Function will check whether hostname/ip-address is valid or not.
            """
            aruba_wlc_host = demisto.params().get('aruba_wlc_host')
            try:
                if aruba_wlc_host.startswith('https://'):
                    aruba_wlc_host = aruba_wlc_host.split('//')[1]
                elif 'http://' in aruba_wlc_host:
                    demisto.error("For SSH access method no need to provide http or https")
            except Exception as ex:
                demisto.error('Error while validating Aruba WLC Hostname or IP Address' + str(ex))
            return aruba_wlc_host

        def connection_handler(self):
            """
            Getting ssh connection handler to device
            """
            net_connect = ''
            try:
                device_dict = {
                    'device_type': "aruba_os",
                    'username': self.username,
                    'password': self.password,
                    'host': self.aruba_wlc_host
                }
                net_connect = ConnectHandler(**device_dict)
            except Exception as ex:
                demisto.error("Exception while making connection: %s" % str(ex))
                raise ex
            return net_connect

        def wlc_cleanup(self):
            """ Perform cleanup functions

            currently, disconnects the ssh connection that was opened to the device

            :param net_connect: ssh connection handler to device
            """
            self.net_connect.disconnect()

        @staticmethod
        def is_valid_ipv4_address(address):
            """
            Function will check the given ip address is valid or not
            :param address: ip-address
            :return: boolean value
            """
            try:
                socket.inet_pton(socket.AF_INET, address)
            except AttributeError:  # no inet_pton here, sorry
                try:
                    socket.inet_aton(address)
                except socket.error:
                    return False
                return address.count('.') == 3
            except socket.error:  # not a valid address
                return False

            return True

        @staticmethod
        def is_valid_ap_radio(ap_radio_value):
            """
            Function will check the given ap_radio is valid or not.
            :param ap_radio_value: radio value.
            :return: boolean value.
            """
            regex_check = re.search(r"^AP:.*GHz-.*", ap_radio_value)
            if regex_check is not None:
                return True
            return False

        def wlc_get_all_iap(self):
            """ function for pulling the Instant APs information from wireless controller.
            :return: list of all the iap devices.
            """
            iap_list = []
            try:
                net_connect = self.net_connect
                cmd = "show iap detailed-table long"
                output = net_connect.send_command(cmd)
                lines = output.split("\n")
                for line in lines:
                    iap_data = {}
                    _data = {}
                    if not line:
                        continue
                    txt = re.findall(r'(\w+:\w+:\w+:\w+:\w+:\w+)', line)
                    if not txt:
                        continue
                    parts = line.split(' ')
                    cleaned_parts = []
                    for part in parts:
                        if not part:
                            continue
                        cleaned_parts.append(part)
                    iap_data['vc_mac_address'] = str(cleaned_parts[1])
                    ip_check = str(cleaned_parts[3])
                    if ip_check:
                        if self.is_valid_ipv4_address(ip_check):
                            iap_data['vc_inner_ip_address'] = ip_check
                    _data['VC Name'] = str(cleaned_parts[0])
                    _data['Status'] = str(cleaned_parts[2])
                    _data['Flags'] = str(cleaned_parts[4])
                    _data['Branch (Subnet / Vlan)'] = str(cleaned_parts[5])
                    _data['VC Branch Name'] = str(cleaned_parts[6])
                    _data['Bid'] = str(cleaned_parts[7])
                    _data['Subnet Range'] = str(cleaned_parts[8])
                    _data['Client count'] = str(cleaned_parts[9])
                    iap_data = CommonUtility.iap_mapping(_data)
                    iap_list.append(iap_data)
            finally:
                # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
                demisto.info('WLC info closing connection')
                self.wlc_cleanup()
            return iap_list

        def wlc_get_switch_details(self):
            """ function for pulling the Switch information from wireless controller.
            :return: list of all the switches along with crash information on the managed device
            """
            switch_list = []
            try:
                net_connect = self.net_connect
                cmd = "show switches debug"
                output = net_connect.send_command(cmd)
                lines = output.split("\n")
                for line in lines:
                    switch_data = {}
                    _data = {}
                    if not line:
                        continue
                    txt = re.findall(r'(\w+:\w+:\w+:\w+:\w+:\w+)', line)
                    if not txt:
                        continue
                    parts = line.split(' ')
                    cleaned_parts = []
                    for part in parts:
                        if not part:
                            continue
                        cleaned_parts.append(part)
                    switch_data['switch_macaddress'] = str(cleaned_parts[1])
                    ip_check = str(cleaned_parts[0])
                    if ip_check:
                        if self.is_valid_ipv4_address(ip_check):
                            switch_data['switch_ip_address'] = ip_check
                    _data['Name'] = str(cleaned_parts[2])
                    _data['Type'] = str(cleaned_parts[4])
                    _data['Model'] = str(cleaned_parts[5])
                    _data['Version'] = str(cleaned_parts[6])
                    _data['Nodepath'] = str(cleaned_parts[3])
                    _data['Status'] = str(cleaned_parts[7])
                    _data['CrashInfo'] = str(cleaned_parts[11])
                    _data['License'] = str(cleaned_parts[13])
                    _data['Release Type'] = str(cleaned_parts[14])
                    # Using swtich mapping methods to map fields.
                    switch_data = CommonUtility.switch_mapping(_data)
                    switch_list.append(switch_data)
            finally:
                # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
                demisto.info('WLC info closing connection')
                self.wlc_cleanup()
            return switch_list

        def get_access_point_detailed_info(self, ap_name):
            ap_details = {}
            ethernet_mac = ''
            location = ''
            port = ''
            ap_model = ''
            ap_status = ''
            ap_serial = ''
            mac_cmd = "show ap details ap-name " + str(ap_name)
            output = net_connect.send_command(mac_cmd)
            if output and isinstance(output, str):
                for line in output.split("\n"):
                    if 'Wired MAC Address' in line:
                        txt = re.search(r'(\w+:\w+:\w+:\w+:\w+:\w+)', line)
                        if txt:
                            ethernet_mac = txt.group(1)
                    if 'Location Name' in line:
                        txt = re.search(r"Location Name\s*(\w+)", line)
                        if txt:
                            location = txt.group(1)
                            if location == 'N':
                                location = ''
                    if 'Port' in line:
                        txt = re.search(r"Port\s*(\w+)", line)
                        if txt:
                            port = txt.group(1)
                            if port == 'N':
                                port = ''
                    if 'AP Type' in line:
                        txt = re.search(r"AP Type\s*(\w+)", line)
                        if txt:
                            ap_model = txt.group(1)
                            if ap_model == 'N':
                                ap_model = 'N/A'
                    # including additional fields for AP
                    if 'Status' in line:
                        txt = re.search(r"Status\s*(\w+)", line)
                    if txt:
                        ap_status = txt.group(1)
                        if ap_status == 'N':
                            ap_status = ''
                    if 'Serial' in line:
                        txt = re.search(r"Serial\s*(\w+)", line)
                        if txt:
                            ap_serial= txt.group(1)
                            if ap_serial == 'N':
                                ap_serial = ''
                    ap_details['ethernet_mac'] = ethernet_mac
                    ap_details['location'] = location
                    ap_details['port'] = port
                    ap_details['ap_status'] = ap_status
                    ap_details['ap_serial'] = ap_serial
                    ap_details['ap_model'] = ap_model
            return ap_details


        def wlc_get_active_ap(self):
            """ function for pulling the AP information from wireless controller from the inspector
            :return: list of active APs
            """
            active_ap_list = []
            ap_name = ''
            ap_radio_list = []
            try:
                net_connect = self.net_connect
                cmd = "show ap active"
                output = net_connect.send_command(cmd)
                lines = output.split("\n")
                for line in lines:
                    active_ap = {}
                    if not line:
                        continue
                    txt = re.findall(r'(\w+:\w+:\w+:\w+:\w+:\w+)', line)
                    if not txt:
                        continue
                    parts = line.split(' ')
                    cleaned_parts = []
                    for part in parts:
                        if not part:
                            continue
                        cleaned_parts.append(part)
                    for part in cleaned_parts:
                        if self.is_valid_ap_radio(part):
                            ap_radio_list.append(part)
                    active_ap['apMacAddress'] = str(cleaned_parts[0])
                    ip_check = str(cleaned_parts[2])
                    if ip_check:
                        if self.is_valid_ipv4_address(ip_check):
                            active_ap['apIPAddress'] = ip_check
                    ap_name = str(cleaned_parts[0])
                    if ap_name:
                        ap_details = self.get_access_point_detailed_info(ap_name)
                        active_ap['apModel'] = ap_details['ap_model']
                        active_ap['location'] = ap_details['location']
                        active_ap['port'] = ap_details['port']
                        active_ap['ap_status'] = ap_details['ap_status']
                        active_ap['ap_serial'] = ap_details['ap_serial']
                        active_ap['apName'] = ap_name
                    if ap_radio_list:
                        ap_radio_list = list(dict.fromkeys(ap_radio_list))
                    active_ap["ap_radio_list"] = ap_radio_list
                    active_ap_list.append(active_ap)
            finally:
                # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
                demisto.info('WLC info closing connection')
                self.wlc_cleanup()
            return active_ap_list


        def wlc_get_active_client_list(self, args):
            """ function for pulling the clients information from wireless controller from the inspector
            :return: list of active clients
            """
            active_client_list = []
            try:
                net_connect = self.net_connect
                ap_name = args.get('ap_name')
                cmd = "show ap debug client-table ap-name {}".format(ap_name)
                output = net_connect.send_command(cmd)
                lines = output.split("\n")
                for line in lines:
                    if not line:
                        continue
                    txt = re.findall(r'(\w+:\w+:\w+:\w+:\w+:\w+)', line)
                    if not txt:
                        continue
                    parts = line.split(' ')
                    cleaned_parts = []
                    for part in parts:
                        if not part:
                            continue
                        cleaned_parts.append(part)
                    mac_address = str(cleaned_parts[0])

                    active_client_list.append(mac_address)
            finally:
                # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
                demisto.info('WLC info closing connection')
                self.wlc_cleanup()
            return active_client_list


        def wlc_aruba_get_monitored_aps(self, net_connect, active_ap, client_bssid):
            """ Gets the information about all clients connected to access points.

            :param net_connect: ssh connection handler to device
            :param evt_content: event content dictionary holding the data format
            :param active_ap: active ap name
            :param client_bssid: client bssid
            """
            if not active_ap:
                return None
            ap_info_list = []

            position_of_bssid = 0
            position_of_ssid = 1
            position_of_radio = 4
            position_of_snr = 11
            position_of_rssi = 13
            position_of_encryption_cipher_auth = 8
            # If the Aruba version is >= 8.9.0.0
            if not self.aruba_version_prior_8_9_flag:
                position_of_bssid = 0
                position_of_ssid = 1
                position_of_snr = 10
                position_of_rssi = 12
                position_of_encryption_cipher_auth = 7
                position_of_radio = 2

            try:
                cmd = "show ap monitor ap-list ap-name " + str(active_ap)
                output = net_connect.send_command(cmd)
                lines = output.split("\n")

                for line in lines:
                    ap_info = {}
                    bssid = ''
                    radio = ''
                    snr = ''
                    rssi = ''
                    ssid = ''
                    auth_method = ''
                    encryption_cipher = ''
                    if not line:
                        continue
                    txt = re.search(r'(\w+:\w+:\w+:\w+:\w+:\w+)', line)
                    if not txt:
                        continue

                    parts = line.split(' ')
                    cleaned_parts = []
                    for part in parts:
                        if not part:
                            continue
                        cleaned_parts.append(part)
                    bssid = CommonUtility.extract_valid_bssid(str(cleaned_parts[position_of_bssid]))
                    if bssid == client_bssid:
                        ssid = str(cleaned_parts[position_of_ssid])
                        snr = str(cleaned_parts[position_of_snr])
                        rssi = str(cleaned_parts[position_of_rssi])

                        if self.aruba_version_prior_8_9_flag:
                            if '80211a' in str(cleaned_parts[position_of_radio]):
                                radio = '802.11a'
                            if '80211b/g' in str(cleaned_parts[position_of_radio]):
                                radio = '802.11b/g'
                            if '802' not in str(cleaned_parts[position_of_radio]):
                                continue
                        else:
                            if '6GHz' in str(cleaned_parts[position_of_radio]):
                                radio = '802.11ax'
                            if '5GHz' in str(cleaned_parts[position_of_radio]):
                                radio = '802.11a'
                            if '2.4GHz' in str(cleaned_parts[position_of_radio]):
                                radio = '802.11b/g'

                        if str(cleaned_parts[position_of_encryption_cipher_auth]) == 'open':
                            auth_method = 'Open System'
                            encryption_cipher = 'open'
                        if str(cleaned_parts[position_of_encryption_cipher_auth]) == 'wpa2-8021x-aes':
                            auth_method = 'WPA2 802.1x'
                            encryption_cipher = 'CCMP-128 (AES)'
                        if str(cleaned_parts[position_of_encryption_cipher_auth]) == 'wpa2-psk-aes':
                            auth_method = 'WPA2 PSK'
                            encryption_cipher = 'CCMP-128 (AES)'

                        ap_info["BSSID"] = bssid
                        ap_info["radio"] = radio
                        ap_info['rssi'] = rssi
                        ap_info['snr'] = snr
                        ap_info['SSID'] = ssid
                        ap_info['authMethod'] = auth_method
                        ap_info['encryptionCipher'] = encryption_cipher

                        if '/' in str(snr) or '/' in str(rssi):
                            continue

                        ap_info_list.append(ap_info)
                        break

            except Exception as ex:
                demisto.error('Exception while getting information about all clients connected to access points' + str(ex))
            return ap_info_list

        @staticmethod
        def __populate_radio_details(client_dict, ap_radio_list):
            """
            Function is to populate radio details
            :param client_dict: client data dictonary.
            :param ap_radio_list: radio list.
            """
            channel = client_dict.get('channel', '')
            if channel:
                for radio in ap_radio_list:
                    if ':{}'.format(channel) in radio:
                        frequency_str = radio.split(':')[1].strip()
                        frequency = frequency_str.split('-')[0].strip()
                        client_dict['radio'] = client_dict.get('radio', '') + ' [' + frequency + ']'
                        client_dict['slot_id'] = 'Radio ' + str(ap_radio_list.index(radio))
            return client_dict

        def wlc_aruba_get_monitored_clients(self, net_connect, active_ap, client_mac_id):
            """ Gets the information about all clients connected to access points.

            :param net_connect: ssh connection handler to device
            :param evt_content: event content dictionary holding the data format
            :param active_ap: active ap name
            :param client_mac_id: client mac id
            """
            if not active_ap:
                return None
            client_info_list = []

            position_of_mac_address = 0
            position_of_radio = 6
            position_of_snr = 9
            position_of_rssi = 10
            position_of_ssid = 2
            position_of_bssid = 1
            # If the Aruba version is >= 8.9.0.0
            if not self.aruba_version_prior_8_9_flag:
                position_of_mac_address = 0
                position_of_bssid = 1
                position_of_snr = 8
                position_of_rssi = 9
                position_of_ssid = 3
                position_of_radio = 2

            try:
                cmd = "show ap monitor client-list ap-name " + str(active_ap)
                output = net_connect.send_command(cmd)

                lines = output.split("\n")

                for line in lines:

                    client_info = {}
                    mac_address = ''
                    radio = ''
                    snr = ''
                    rssi = ''
                    ssid = ''
                    bssid = ''
                    if not line:
                        continue
                    txt = re.search(r'(\w+:\w+:\w+:\w+:\w+:\w+)', line)
                    if not txt:
                        continue

                    parts = line.split(' ')
                    cleaned_parts = []
                    for part in parts:
                        if not part:
                            continue
                        cleaned_parts.append(part)
                    mac_address = str(cleaned_parts[position_of_mac_address])
                    if mac_address == client_mac_id:
                        snr = str(cleaned_parts[position_of_snr])
                        rssi = str(cleaned_parts[position_of_rssi])
                        bssid = str(cleaned_parts[position_of_bssid])
                        ssid = str(cleaned_parts[position_of_ssid])
                        # Radio field is changed for the versions above v8.9
                        if self.aruba_version_prior_8_9_flag:
                            if '80211a' in str(cleaned_parts[position_of_radio]):
                                radio = '802.11a'
                            if '80211b/g' in str(cleaned_parts[position_of_radio]):
                                radio = '802.11b/g'
                        else:
                            if '6GHz' in str(cleaned_parts[position_of_radio]):
                                radio = '802.11ax'
                            if '5GHz' in str(cleaned_parts[position_of_radio]):
                                radio = '802.11a'
                            if '2.4GHz' in str(cleaned_parts[position_of_radio]):
                                radio = '802.11b/g'
                        client_info["macAddress"] = mac_address
                        client_info["radio"] = radio
                        client_info['rssi'] = rssi
                        client_info['snr'] = snr
                        client_info['SSID'] = ssid
                        client_info['BSSID'] = bssid
                        if ('/' in str(snr) or '/' in str(rssi) or str(rssi) == '-' or '-' in str(snr)) and self.aruba_version_prior_8_9_flag:
                            continue
                        client_info_list.append(client_info)
            except Exception as ex:
                demisto.error('Exception while getting information about all clients' + str(ex))
            return client_info_list


        def __wlc_get_monitored_client_details(self, net_connect, evt_content, active_ap, client_mac_id):
            # Monitored client info
            client_bssid = ''
            monitored_client_dict = ''
            monitored_client_info_list = self.wlc_aruba_get_monitored_clients(
                net_connect, active_ap, client_mac_id)
            if monitored_client_info_list:
                monitored_client_dict = monitored_client_info_list.pop()
                client_bssid = monitored_client_dict.get('BSSID', '')
            return client_bssid, monitored_client_dict

        @staticmethod
        def wlc_aruba_get_active_clients(net_connect, active_ap):
            """ Gets the information about all clients connected to access points.

            :param net_connect: ssh connection handler to device
            :param evt_content: event content dictionary holding the data format
            :param active_ap: active ap name
            """
            client_info_list = []
            if not active_ap:
                return None

            # converting active_ap to string if it is in bytes
            try:
                active_ap = active_ap.decode('utf-8')
            except (UnicodeDecodeError, AttributeError):
                pass

            cmd = "show ap debug client-table ap-name " + str(active_ap)
            output = net_connect.send_command(cmd)
            lines = output.split("\n")

            for line in lines:
                if not line:
                    continue
                client_info = {}
                mac_address = ''
                ssid = ''
                status = ''
                snr = ''
                ip_address = ''
                device_type = ''
                auth_method = ''
                connected_duration = ''
                auth_status = ''
                channel = ''
                if not line:
                    continue
                txt = re.findall(r'(\w+:\w+:\w+:\w+:\w+:\w+)', line)
                if not txt:
                    continue
                mac_address = str(txt[0])
                bssid = str(txt[1])
                ssid = line.split('  ')[1].strip()
                status = line.split('  ')[3].strip()
                cmd = 'show ap debug client-stats client-mac ' + mac_address
                output = net_connect.send_command(cmd)
                client_lines = output.split('\n')
                for client_line in client_lines:
                    if 'Rx Last SNR' in client_line:
                        txt = re.search(r"Rx Last SNR\s*(\d+)", client_line)
                        if txt:
                            snr = str(txt.group(1))
                client_lines = ''
                if mac_address:
                    cmd = 'show user mac ' + mac_address
                    output = net_connect.send_command(cmd)
                    txt = re.search(r'IP:\s*(\d+\.\d+\.\d+\.\d+)', output)
                    if txt:
                        ip_address = str(txt.group(1))
                    if not txt:
                        txt = re.search(r'(\d+\.\d+\.\d+\.\d+)\s*\w+:\w+:\w+:\w+:\w+:\w+', output, re.MULTILINE)
                        if txt:
                            ip_address = str(txt.group(1))
                    txt = re.search(r'Channel\s*(\w+)', output)
                    if txt:
                        channel = str(txt.group(1))
                    client_lines = output.split('\n')
                    for client_line in client_lines:
                        if not client_line:
                            continue
                        client_line = str(client_line)
                        if 'Name:' in client_line:
                            txt = re.search(r"Age:\s*(\d+:\d+:\d+)", client_line)
                            if txt:
                                connected_duration = str(txt.group(1))
                        if 'Authentication:' in client_line:
                            txt = re.search(r"Authentication:\s([\w\s]+),", client_line)
                            if txt:
                                auth_status = str(txt.group(1))
                            txt = re.search(r"method:\s([\w\s]+),", client_line)
                            if txt:
                                auth_method = str(txt.group(1)).strip()
                        if 'Device Type:' in client_line:
                            if 'Android' in client_line:
                                device_type = 'Android'
                            elif 'Linux' in client_line:
                                device_type = 'Linux'
                            elif 'Win 8' in client_line:
                                device_type = 'Win 8'
                            elif 'Win 10' in client_line:
                                device_type = 'Win 10'
                            elif 'OS X' in client_line:
                                device_type = 'OS X'
                            elif 'iPhone' in client_line:
                                device_type = 'iPhone'
                            elif 'iPad' in client_line:
                                device_type = 'iPad'
                client_info["macAddress"] = mac_address
                client_info["channel"] = channel
                client_info["ipAddress"] = ip_address
                client_info["SSID"] = ssid
                client_info["status"] = status
                client_info["deviceType"] = device_type
                client_info["snr"] = snr
                client_info["connectedDuration"] = connected_duration
                client_info["authMethod"] = auth_method
                client_info["authenticationStatus"] = auth_status
                client_info["isBluetooth"] = False
                client_info_list.append(client_info)
            return client_info_list

        def get_ap_details(self, net_connect, evt_content):
            """ Gets the access points details from Aruba

            :param net_connect: ssh connection handler to device
            :param evt_content: event content dictionary holding the data format
            :return: ap_name(str), ap_info(dict)
            """
            try:
                net_connect.send_command("no paging")
                ap_info = collections.defaultdict(dict)

                ap_name = ''
                ip_address = ''
                ap_radio_list = []

                total_clients = 0
                cmd = "show user-table summary | inc 'Unique Users'"
                output = net_connect.send_command(cmd)
                if isinstance(output, str):
                    lines = output.split("\n")
                    for line in lines:
                        txt = re.search(r"Total Users:\s*(\d+)", line)
                        if txt:
                            total_clients = int(txt.group(1))
                        txt = re.search(r"Unique Users:\s*(\d+)", line)
                    evt_content["totalClients"] = total_clients

                client_auth_dict = {}
                cmd = 'show user-table'
                output = net_connect.send_command(cmd)
                if isinstance(output, str):
                    lines = output.split("\n")
                    for line in lines:
                        if not line:
                            continue
                        txt = re.findall(r'(\w+:\w+:\w+:\w+:\w+:\w+)', line)
                        if not txt:
                            continue
                        mac_address = str(txt[0])
                        txt = re.search(r'\d+:\d+:\d+\s*MAC', line)
                        if txt:
                            client_auth_dict[mac_address] = 'MAC'
                        txt = re.search(r'\d+:\d+:\d+\s*802\.1x', line)
                        if txt:
                            client_auth_dict[mac_address] = '802.1x'

                cmd = "show ap active"
                output = net_connect.send_command(cmd)
                if isinstance(output, str):
                    lines = output.split("\n")
                    for line in lines:
                        if not line:
                            continue
                        if 'Num APs:' in line:
                            parts = line.split('Num APs:')
                            for part in parts:
                                if not part:
                                    continue
                                part = part.replace('.', '')
                                part = part.strip()
                                evt_content["totalAPs"] = int(part)
                                break

                    if evt_content["totalAPs"] < 1:
                        self.wlc_cleanup()
                        sys.exit()

                    idx = 0
                    for i in range(len(lines)):
                        if "Name" in lines[i]:
                            idx = i
                            break
                    lines = lines[idx + 2:]
                    for line in lines:
                        txt = re.search(r'\d+\.\d+\.\d+\.\d+', line)
                        if not txt:
                            continue

                        parts = line.split(' ')
                        cleaned_parts = []
                        for part in parts:
                            if not part:
                                continue

                            cleaned_parts.append(part)
                        if not cleaned_parts:
                            continue

                        ap_name = cleaned_parts[0]

                        for i in range(len(cleaned_parts)):
                            ip_address = None

                            for part in cleaned_parts:
                                if self.is_valid_ipv4_address(part):
                                    ip_address = part
                                if self.is_valid_ap_radio(part):
                                    ap_radio_list.append(part)


                            #if len(cleaned_parts) >= 8 and 'AP' in cleaned_parts[7]:
                            #    ap_radio_list.append(cleaned_parts[7])
                            #if len(cleaned_parts) >= 9 and 'AP' in cleaned_parts[8]:
                            #    ap_radio_list.append(cleaned_parts[8])
                            #if len(cleaned_parts) > 9 and 'AP' in cleaned_parts[9]:
                            #    ap_radio_list.append(cleaned_parts[9])

                        if ap_name:
                            ap_details = self.get_access_point_detailed_info(ap_name)
                            ap_info[ap_name]["apMacAddress"] = ap_details['ethernet_mac']
                            ap_info[ap_name]['apModel'] = ap_details['ap_model']
                            ap_info[ap_name]['location'] = ap_details['location']
                            ap_info[ap_name]['port'] = ap_details['port']
                            ap_info[ap_name]['ap_status'] = ap_details['ap_status']
                            ap_info[ap_name]['ap_serial'] = ap_details['ap_serial']
                        if ap_radio_list:
                            ap_radio_list = list(dict.fromkeys(ap_radio_list))
                        ap_info[ap_name]["ap_radio_list"] = ap_radio_list
                        ap_info[ap_name]["apName"] = ap_name
                        ap_info[ap_name]["apIPAddress"] = ip_address
                        ap_info[ap_name]["client_list"] = []
            except Exception as ex:
                demisto.error('Exception while getting access points details from Aruba' + str(ex))
            return ap_name, ap_info


        def wlc_aruba_get_ap_summary(self, net_connect, evt_content, aruba_os):
            """ Gets the access points summary information from the CLI

            :param net_connect: ssh connection handler to device
            :param evt_content: event content dictionary holding the data format
            """
            try:
                evt_content["uniqueClients"] = 0
                ap_name, ap_info = self.get_ap_details(net_connect, evt_content)
                for ap_name in ap_info:
                    active_ap = ap_name
                    client_mac_id = ''
                    client_bssid = ''
                    total_clients = evt_content["totalClients"]
                    if total_clients > 0:
                        client_info_list = self.wlc_aruba_get_active_clients(net_connect, active_ap)
                        if client_info_list:
                            evt_content["uniqueClients"] += len(client_info_list)
                            for each_dict in client_info_list:
                                client_mac_id = each_dict.get('macAddress', '')
                                client_bssid, monitored_client_dict = self.__wlc_get_monitored_client_details(
                                    net_connect, evt_content, active_ap, client_mac_id)
                                if monitored_client_dict:
                                    each_dict.update(monitored_client_dict)
                                if len(ap_info[ap_name]["ap_radio_list"]) > 0:
                                    each_dict = self.__populate_radio_details(
                                        each_dict, ap_info[ap_name]["ap_radio_list"])
                                ap_info[ap_name]["client_list"].append(each_dict)
                                # Monitored AP info
                                ap_info_list = self.wlc_aruba_get_monitored_aps(net_connect, active_ap, client_bssid)
                                if ap_info_list:
                                    ap_info[ap_name]["monitor_ap_list"] = ap_info_list.pop()
                evt_content['ap_list'] = []
                for key in sorted(ap_info):
                    dic = {key: ap_info[key]}
                    evt_content['ap_list'].append(dic)
            except Exception as ex:
                demisto.error(f'Exception when getting AP summary: {str(ex)}')
                demisto.error(traceback.format_exc())
                t_back = sys.exc_info()[-1]
                stk = traceback.extract_tb(t_back, 1)
                fname = stk[0][2]
                raise Exception('Unsupported format from OS - %s when getting AP summary from WLC %s %s' % (aruba_os, str(ex), fname))

        def wlc_aruba_get_sysinfo(self, net_connect):
            """
                Function will get info of Aruba OS.
            """
            system_name = 'aruba_controller'
            aruba_os = 'unknown'
            try:
                cmd = 'show switchinfo'
                output = net_connect.send_command(cmd)
                lines = output.split("\n")
                for line in lines:
                    if 'Hostname is' in line:
                        system_name = line.split('Hostname is')[1].strip()
                    elif 'ArubaOS' in line:
                        aruba_os = line
                        self.aruba_os_version = CommonUtility.extract_aruba_os_version(aruba_os)
                        self.aruba_version_prior_8_9_flag = CommonUtility.check_aruba_version_prior_8_9(self.aruba_os_version)
                    else:
                        continue
            except Exception as ex:
                demisto.error(f'Exception when getting sysinfo: {str(ex)}')
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format when getting sysinfo(Hostname and OS version) from WLC')
            return system_name, aruba_os

        @staticmethod
        def wlc_aruba_flatten_ap_list(evt_content, aruba_os):
            """
            Function will format the response
            """
            try:
                ap_list_dict = evt_content["ap_list"]
                del evt_content["ap_list"]
                flatten_list = []
                for item in ap_list_dict:
                    dic = item
                    for val in dic.values():
                        flatten_list.append(val)
                evt_content["ap_list"] = flatten_list
            except Exception as ex:
                demisto.error(f'Exception when flattening AP list: {str(ex)}')
                demisto.error(traceback.format_exc())
                raise Exception('Unsupported format when flattening AP list from WLC OS: %s. Error: %s' % (aruba_os, str(ex)))

        @staticmethod
        def wlc_construct_source_fields_from_json(evt_content, system_name):
            """
            Function will construct source fields from json.
            """
            json_obj = {}
            source = {}
            wlc_id = system_name
            tenant_id = 's3fvtu3j'
            inspector_id = '44454C4C5800104D8037B1C04F315132'

            source["eventLevel"] = "EV_EVENT"
            source["evtType"] = "evt_wlc_output"
            source["tenantid"] = tenant_id
            source["evtContent"] = evt_content
            json_obj["evtSource"] = "wireless_controller"
            json_obj["wlcId-tenant-inspector"] = wlc_id + tenant_id + inspector_id
            json_obj["timestamp"] = int(time.time())
            json_obj["_source"] = source

            return json_obj


        def wlc_get_devices_data(self):
            """ main function for pulling the information from wireless controller from the inspector

            This function calls other subroutines responsible for individual chunk of work and is the
            only entry point in data path. It constructs a JSON object and write into the file
            which can be consumed by API team to display the wireless data onto dashboard.

            """
            evt_content = {}
            json_obj = None

            try:
                net_connect = self.net_connect
                system_name, aruba_os = self.wlc_aruba_get_sysinfo(net_connect)
                self.wlc_aruba_get_ap_summary(net_connect, evt_content, aruba_os)
                self.wlc_aruba_flatten_ap_list(evt_content, aruba_os)

                filename = ''
                if system_name:
                    timestamp = str(strftime('%Y-%m-%d_%H:%M:%S', gmtime()))
                    filename = str(system_name + '_') + timestamp
                    evt_content['file-id'] = filename
                    json_obj = self.wlc_construct_source_fields_from_json(evt_content, system_name)
            except Exception as ex:
                demisto.error('Error while getting device data' + str(ex))
                raise ex
            finally:
                # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
                demisto.info('WLC info closing connection')
                self.wlc_cleanup()

            return json_obj

        @staticmethod
        def __format_duration_timestamp(duration):
            conn_duration = ''
            duration_dict = {
                "h": '00',
                "m": '00',
                "s": '00'
            }
            duration_values = duration.split(':')
            for val in duration_values:
                if 'h' in val:
                    duration_dict['h'] = val.split('h')[0]
                    if len(val.split('h')[0]) < 2:
                        duration_dict['h'] = '0' + duration_dict['h']
                if 'm' in val:
                    duration_dict['m'] = val.split('m')[0]
                    if len(val.split('m')[0]) < 2:
                        duration_dict['m'] = '0' + duration_dict['m']
                if 's' in val:
                    duration_dict['s'] = val.split('s')[0]
                    if len(val.split('s')[0]) < 2:
                        duration_dict['s'] = '0' + duration_dict['s']
            conn_duration = duration_dict['h'] + ':' + duration_dict['m'] + ':' + duration_dict['s']
            return conn_duration

        def get_ble_client_aruba_beacon(self, client_data):
            """
            Function will give all info about BLE Device Aruba Beacons.
            :param client_data: Client data.
            """
            client_info = {}
            try:
                mac_address = ''
                bt_device_type = ''
                conn_state = 'No'
                connected_duration = ''
                hw_type = ''
                fw_version = ''
                bt_sig_corp_id = ''
                bt_address_type = ''
                # Defaulting BT type to BLE
                bt_type = 'BLE'

                # Get the MAC address
                ps = re.findall(r'(\w+:\w+:\w+:\w+:\w+:\w+)', client_data)
                if not ps:
                    return
                mac_address = str(ps[0])
                parts = client_data.split('  ')
                cleaned_parts = []
                for part in parts:
                    if not part:
                        continue
                    cleaned_parts.append(part)
                if cleaned_parts[1].strip() != "--":
                    hw_type = cleaned_parts[1].strip()
                if cleaned_parts[2].strip() != "--":
                    fw_version = cleaned_parts[2].strip()
                if cleaned_parts[4].strip() != "--":
                    status = cleaned_parts[4].strip()
                if cleaned_parts[13].strip() != "--":
                    connected_duration = cleaned_parts[13].strip()
                    if connected_duration:
                        connected_duration = self.__format_duration_timestamp(connected_duration)
                        conn_state = 'Yes'
                else:
                    connected_duration = '00:00:00'
                    conn_state = 'No'
                if 'L' in status:
                    bt_device_type += "AP\'s local beacon"
                if 'I' in status:
                    bt_device_type += ":" + "iBeacon"
                if 'A' in status:
                    bt_device_type += ":" + "Beacon management capable"
                if 'H' in status:
                    bt_device_type += ":" + "High power beacon"
                if 'T' in status:
                    bt_device_type += ":" + "Asset Tag Beacon"
                if 'U' in status:
                    bt_device_type += ":" + "Upgrade of firmware pending"
                if 'u' in status:
                    bt_device_type += ":" + "Beacon management update received"
                client_info["macAddress"] = mac_address
                client_info["bluetoothType"] = bt_type
                client_info["bluetoothDeviceType"] = bt_device_type
                client_info["connectionState"] = conn_state
                client_info["connectedDuration"] = connected_duration
                client_info["hwType"] = hw_type
                client_info["fwVersion"] = fw_version
                client_info["bluetoothAddressType"] = bt_address_type
                client_info["bluetoothCompanyId"] = bt_sig_corp_id
                client_info["isBluetooth"] = True
            except Exception as ex:
                demisto.error("Exception when getting BLE Device Aruba Beacons, error message- "+str(ex))
            return client_info

        def get_ble_client_apb(self, client_data):
            """
            Function will give all info about BLE Device APB's.
            :param client_data: Client data.
            """
            client_info = {}
            try:
                mac_address = ''
                bt_device_type = ''
                conn_state = 'No'
                connected_duration = ''
                hw_type = ''
                fw_version = ''
                bt_sig_corp_id = ''
                bt_address_type = ''
                # Defaulting BT type to BLE
                bt_type = 'BLE'
                # Get the MAC address
                ps = re.findall(r'(\w+:\w+:\w+:\w+:\w+:\w+)', client_data)
                if not ps:
                    return
                mac_address = str(ps[0])
                parts = client_data.split('  ')
                cleaned_parts = []
                for part in parts:
                    if not part:
                        continue
                    cleaned_parts.append(part)
                if cleaned_parts[1].strip() != "--":
                    hw_type = cleaned_parts[1].strip()
                if cleaned_parts[2].strip() != "--":
                    fw_version = cleaned_parts[2].strip()
                if cleaned_parts[4].strip() != "--":
                    status = cleaned_parts[4].strip()
                if cleaned_parts[8].strip() != "--":
                    connected_duration = cleaned_parts[8].strip()
                    if connected_duration:
                        connected_duration = self.__format_duration_timestamp(connected_duration)
                        conn_state = 'Yes'
                else:
                    connected_duration = '00:00:00'
                    conn_state = 'No'
                if 'L' in status:
                    bt_device_type += "AP\'s local beacon"
                if 'I' in status:
                    bt_device_type += ":" + "iBeacon"
                if 'A' in status:
                    bt_device_type += ":" + "Beacon management capable"
                if 'H' in status:
                    bt_device_type += ":" + "High power beacon"
                if 'T' in status:
                    bt_device_type += ":" + "Asset Tag Beacon"
                if 'U' in status:
                    bt_device_type += ":" + "Upgrade of firmware pending"
                if 'u' in status:
                    bt_device_type += ":" + "Beacon management update received"
                client_info["macAddress"] = mac_address
                client_info["bluetoothType"] = bt_type
                client_info["bluetoothDeviceType"] = bt_device_type
                client_info["connectionState"] = conn_state
                client_info["connectedDuration"] = connected_duration
                client_info["hwType"] = hw_type
                client_info["fwVersion"] = fw_version
                client_info["bluetoothAddressType"] = bt_address_type
                client_info["bluetoothCompanyId"] = bt_sig_corp_id
                client_info["isBluetooth"] = True
            except Exception as ex:
                demisto.error("Exception when getting BLE Device APB's, error message- "+str(ex))
            return client_info

        def get_ble_client_asset_tag(self, client_data):
            """
            Function will give all info about BLE Device Asset Tags.
            :param client_data: Client data.
            """
            client_info = {}
            try:
                mac_address = ''
                bt_device_type = ''
                conn_state = 'No'
                connected_duration = ''
                hw_type = ''
                fw_version = ''
                bt_sig_corp_id = ''
                bt_address_type = ''
                # Defaulting BT type to BLE
                bt_type = 'BLE'
                # Get the MAC address
                ps = re.findall(r'(\w+:\w+:\w+:\w+:\w+:\w+)', client_data)
                if not ps:
                    return
                mac_address = str(ps[0])
                parts = client_data.split('  ')
                cleaned_parts = []
                for part in parts:
                    if not part:
                        continue
                    cleaned_parts.append(part)
                if cleaned_parts[1].strip() != "--":
                    hw_type = cleaned_parts[1].strip()
                if cleaned_parts[2].strip() != "--":
                    fw_version = cleaned_parts[2].strip()
                if cleaned_parts[4].strip() != "--":
                    status = cleaned_parts[4].strip()
                if cleaned_parts[8].strip() != "--":
                    connected_duration = cleaned_parts[8].strip()
                    if connected_duration:
                        connected_duration = self.__format_duration_timestamp(connected_duration)
                        conn_state = 'Yes'
                else:
                    connected_duration = '00:00:00'
                    conn_state = 'No'
                if 'L' in status:
                    bt_device_type += "AP\'s local beacon"
                if 'I' in status:
                    bt_device_type += ":" + "iBeacon"
                if 'A' in status:
                    bt_device_type += ":" + "Beacon management capable"
                if 'H' in status:
                    bt_device_type += ":" + "High power beacon"
                if 'T' in status:
                    bt_device_type += ":" + "Asset Tag Beacon"
                if 'U' in status:
                    bt_device_type += ":" + "Upgrade of firmware pending"
                if 'u' in status:
                    bt_device_type += ":" + "Beacon management update received"
                client_info["macAddress"] = mac_address
                client_info["bluetoothType"] = bt_type
                client_info["bluetoothDeviceType"] = bt_device_type
                client_info["connectionState"] = conn_state
                client_info["connectedDuration"] = connected_duration
                client_info["hwType"] = hw_type
                client_info["fwVersion"] = fw_version
                client_info["bluetoothAddressType"] = bt_address_type
                client_info["bluetoothCompanyId"] = bt_sig_corp_id
                client_info["isBluetooth"] = True
            except Exception as ex:
                demisto.error("Exception when getting BLE Device Asset Tags, error message- "+str(ex))
            return client_info

        def get_ble_client_generic(self, client_data):
            """
            Function will give all info about BLE Device Generic.
            :param client_data: Client data.
            """
            client_info = {}
            try:
                mac_address = ''
                bt_type = ''
                bt_device_type = ''
                conn_state = 'Yes'
                connected_duration = ''
                hw_type = ''
                fw_version = ''
                bt_sig_corp_id = ''
                bt_address_type = ''
                # Defaulting BT type to BLE
                bt_type = 'BLE'
                # Get the MAC address
                ps = re.findall(r'(\w+:\w+:\w+:\w+:\w+:\w+)', client_data)
                if not ps:
                    return
                mac_address = str(ps[0])

                # Get the various field values
                parts = client_data.split('  ')
                cleaned_parts = []
                for part in parts:
                    if not part:
                        continue
                    cleaned_parts.append(part)

                # Get BLE address type
                if cleaned_parts[1].strip() != "--":
                    bt_address_type = cleaned_parts[1].strip()
                if bt_address_type == 'Public':
                    # Get BLE device type
                    if cleaned_parts[4].strip() != "--":
                        bt_device_type = cleaned_parts[4].strip()
                    # Get BLE Sig company id
                    if cleaned_parts[6].strip() != "--":
                        bt_sig_corp_id = cleaned_parts[6].strip()
                    # Populate the BLE entry values
                    client_info["macAddress"] = mac_address
                    client_info["bluetoothType"] = bt_type
                    client_info["bluetoothDeviceType"] = bt_device_type
                    client_info["connectionState"] = conn_state
                    client_info["connectedDuration"] = connected_duration
                    client_info["hwType"] = hw_type
                    client_info["fwVersion"] = fw_version
                    client_info["bluetoothAddressType"] = bt_address_type
                    client_info["bluetoothCompanyId"] = bt_sig_corp_id
                    client_info["isBluetooth"] = True
            except Exception as ex:
                demisto.error("Exception when getting BLE Device Generic, error message- "+str(ex))
            return client_info

        def wlc_aruba_get_active_bt_clients(self, net_connect, active_ap):
            """ Gets the information about all bluetooth clients connected to access points.

            :param net_connect: ssh connection handler to device
            :param evt_content: event content dictionary holding the data format
            :param active_ap: active ap name
            """
            client_info_list = []
            if not active_ap:
                return None

            # converting active_ap to string if it is in bytes
            try:
                active_ap = active_ap.decode('utf-8')
            except (UnicodeDecodeError, AttributeError):
                pass

            cmd = "show ap debug ble-table ap-name " + str(active_ap) + ' all'

            try:
                output = net_connect.send_command(cmd)
                lines = output.split("\n")

                for line in lines:
                    if not line:
                        continue
                    # Check for BT client type
                    parts = line.split(' ')
                    if parts[0] == "BLE" and parts[1] == "Device":
                        if len(parts) > 3:
                            client_type = parts[3].strip()
                            if len(parts) > 4:
                                client_type += " " + parts[4].strip()
                        continue

                    # Check if this is a Client entry by checkin the first entry as MAC address
                    ps = re.findall(r'(\w+:\w+:\w+:\w+:\w+:\w+)', line)
                    if not ps:
                        continue
                    # Get the BT Client entry details
                    if client_type == "[APBs]":
                        client_info = self.get_ble_client_apb(line)
                    elif client_type == "[Aruba Beacons]":
                        client_info = self.get_ble_client_aruba_beacon(line)
                    elif client_type == "[Generic]":
                        client_info = self.get_ble_client_generic(line)
                    elif client_type == "[Asset Tags]":
                        client_info = self.get_ble_client_asset_tag(line)
                    else:
                        client_info = None
                    if client_info is not None:
                        client_info_list.append(client_info)
            except Exception as ex:
                #demisto.error(f'Exception when getting AP summary: {str(ex)}')
                raise Exception("Exception when getting AP summary, error message- "+str(ex)+". While running command "+str(cmd))
            return client_info_list



        def wlc_aruba_get_bt_ap_summary(self, net_connect, evt_content, aruba_os):
            """ Gets the access points summary information from the CLI

            :param net_connect: ssh connection handler to device
            :param evt_content: event content dictionary holding the data format
            """
            try:
                ap_name, ap_info = self.get_ap_details(net_connect, evt_content)
                evt_content["uniqueClients"] = 0
                for ap_name in ap_info:
                    active_ap = ap_name
                    total_clients = evt_content["totalClients"]
                    if total_clients > 0:
                        client_info_list = self.wlc_aruba_get_active_bt_clients(net_connect, active_ap)
                        if client_info_list:
                            evt_content["uniqueClients"] += len(client_info_list)
                            for each_dict in client_info_list:
                                ap_info[ap_name]["client_list"].append(each_dict)
                evt_content['ap_list'] = []
                for key in sorted(ap_info):
                    dic = {key: ap_info[key]}
                    evt_content['ap_list'].append(dic)
            except Exception as ex:
                demisto.error(f'Exception when getting bluetooth AP summary: {str(ex)}')
                raise Exception('Unsupported format when getting bluetooth AP summary from WLC OS: %s. Error: %s' % (aruba_os, str(ex)))


        def wlc_get_bluetooth_devices_data(self):
            """ main function for pulling the information from wireless controller from the inspector

            This function calls other subroutines responsible for individual chunk of work and is the
            only entry point in data path. It constructs a JSON object and write into the file
            which can be consumed by API team to display the wireless data onto dashboard.

            """
            evt_content = {}
            json_obj = None

            try:
                net_connect = self.net_connect
                system_name, aruba_os = self.wlc_aruba_get_sysinfo(net_connect)
                self.wlc_aruba_get_bt_ap_summary(net_connect, evt_content, aruba_os)
                self.wlc_aruba_flatten_ap_list(evt_content, aruba_os)

                filename = ''
                if system_name:
                    timestamp = str(strftime('%Y-%m-%d_%H:%M:%S', gmtime()))
                    filename = str(system_name + '_') + timestamp
                    evt_content['file-id'] = filename
                    json_obj = self.wlc_construct_source_fields_from_json(evt_content, system_name)
            finally:
                # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
                demisto.info('WLC info closing connection')
                self.wlc_cleanup()
            return json_obj

        @staticmethod
        def __extract_aruba_wlc_device_data(mac_address, client_data):
            """
            Function will extract Aruba WLC device data.
            :param mac_address: mac-address.
            :param client_data: client data.
            """
            data = {}
            try:
                ap_list = client_data.get('_source', {}).get('evtContent', {}).get('ap_list', [])
                for access_point in ap_list:
                    clients_list = access_point.get('client_list', [])
                    for client in clients_list:
                        data = {}
                        client_mac = client.get('macAddress', '').lower()
                        if mac_address == client_mac:
                            data['MAC Address'] = client_mac
                            data['IP Address'] = client.get('ipAddress', '')
                            data['Radio'] = client.get('radio', '')
                            data['Connection State'] = client.get('status', '')
                            data['SSID'] = client.get('SSID', '')
                            data['Connected Duration'] = client.get('connectedDuration', '').strip()
                            data['Auth Method'] = client.get('authMethod', '').strip()
                            data['Encryption Cipher'] = access_point.get('monitor_ap_list').get('encryptionCipher', '')
                            data['RSSI'] = client.get('rssi', '')
                            data['SNR'] = client.get('snr', '')
                            data['Authentication Status'] = client.get('authenticationStatus', '').strip()
                            data['BSSID'] = client.get('BSSID', '')
                            data['Device Type'] = client.get('deviceType', '')
                            data['AP Name'] = access_point.get('apName', '')
                            data['AP IP Address'] = access_point.get('apIPAddress', '')
                            data['AP MAC Address'] = access_point.get('apMacAddress', '')
                            data['AP Model'] = access_point.get('apModel', '')
                            data['AP Encryption Cipher'] = access_point.get('monitor_ap_list').get('encryptionCipher', '')
                            data['AP Radio Slot ID'] = client.get('slot_id', '')
                            data['Location'] = access_point.get('location', '')
                            break
            except Exception as ex:
                demisto.error("Exception while exctracting device data: %s" % str(ex))
            return data

        def wlc_get_client_details_using_mac(self, args):
            """ function for pulling the client information from wireless controller from the inspector
            :return: client details
            """
            # Getting ssh connection handler to device
            try:
                mac_address = args.get('mac_address')
            except Exception as ex:
                demisto.error("Exception while getting client detail using mac address: %s" % str(ex))
                raise ex

            client_data = self.wlc_get_devices_data()
            active_client_details = self.__extract_aruba_wlc_device_data(mac_address, client_data)
            if not active_client_details:
                active_client_details = {}
            return active_client_details

        @staticmethod
        def run_wlc_command(net_connect, command):
            """
            This function will run all the show commands.
            :return: json response
            """
            net_connect.send_command("no paging")
            cmd = str(command)
            output = net_connect.send_command(cmd)
            return output

        def execute_command(self, command):
            """
            This function will run the execute command.
            :param: show command which user will enter manually.
            :return: json response
            """
            if command in (None, ''):
                raise Exception("Command can not be Null.")
            result = None

            try:
                net_connect = self.net_connect
                result = self.run_wlc_command(net_connect, command)
            except Exception as ex:
                msg = "Failed to run command %s, error %s" % (command, ex)
                raise msg
            finally:
                # Make sure we close the WLC connection to prevent resource leaks. Any exceptions will be handled by caller.
                demisto.info('WLC info closing connection')
                self.wlc_cleanup()

            return result


    class CommonUtility:
        """
            Class which contains common utility functions for both workflows
        """

        @staticmethod
        def extract_aruba_os_version(aruba_os_string):
            """
                Method to extract the OS version
            """
            os_version = ""
            os_version_pattern = re.compile(r"(\d+(\.\d+){3,4})")
            search_version = os_version_pattern.search(aruba_os_string)
            if search_version:
                os_version = search_version[0]
            return os_version


        @staticmethod
        def check_aruba_version_prior_8_9(os_version):
            """
                Method to check if the version is greater than 8.9.0.0 as some fields have changed post that version in output
            """
            aruba_version_prior_8_9_flag = False
            os_version_split = os_version.split(".", 2)
            if len(os_version_split) >= 2:
                aruba_version_prior_8_9_flag = False if int(os_version_split[0]+os_version_split[1]) >= 89 else True
            return aruba_version_prior_8_9_flag

        @staticmethod
        def extract_valid_bssid(bssid_string):
            """
                Method to extract valid bssid using regex
                As the BSSID can come in response as 1c:28:af:68:66:41(*) or 1c:28:af:68:66:41(+)
            """

            bssid_format = re.compile(r'(?:[0-9a-fA-F]:?){12}')
            extracted_bssid = re.findall(bssid_format, bssid_string)
            if len(extracted_bssid) > 0:
                bssid_string = str(extracted_bssid[0])
            return bssid_string

        @staticmethod
        def switch_mapping(data):
            """
                Method to map switch data
            """
            switch_data = {}
            if data:
                key_mapping = {
                    'switch_name': 'Name',
                    'switch_type': 'Type',
                    'switch_model': 'Model',
                    'switch_version': 'Version',
                    'switch_nodepath': 'Nodepath',
                    'switch_status': 'Status',
                    'switch_crashInfo': 'CrashInfo',
                    'switch_license': 'License',
                    'switch_release_type': 'Release Type'
                }
                for switch_key, _data_key in key_mapping.items():
                    switch_data[switch_key] = data.get(_data_key, '')
            return switch_data

        @staticmethod
        def iap_mapping(data):
            """
                Method to map switch data
            """
            iap_data = {}
            if data:
                key_mapping = {
                    'vc_name': 'VC Name',
                    'vc_flags': 'Flags',
                    'vc_branch': 'Branch (Subnet / Vlan)',
                    'vc_branch_name': 'VC Branch Name',
                    'vc_bid': 'Bid',
                    'vc_status': 'Status',
                    'vc_subnet_range': 'Subnet Range',
                    'vc_client_count': 'Client count'
                    }

            for iap_key, _data_key in key_mapping.items():
                iap_data[iap_key] = _data.get(_data_key, '')
            return iap_data



    def main() -> None:
        """
            main function, parses params and runs command functions
        """
        access_method = demisto.params().get('access_method')

        args = demisto.args()

        demisto.debug(f'Command being called is {demisto.command()}')
        try:
            # The command demisto.command() holds the command sent from the user.
            if demisto.command() == 'test-module':
                # This is the call made when pressing the integration test button.
                try:
                    if access_method == "SSH":
                        ssh_parser = ArubaControllerSSHParser()

                        ssh_parser.connection_handler()
                        ssh_parser.wlc_cleanup()
                        return_results('ok')
                    else:
                        api_parser = ArubaControllerAPIParser()
                        if api_parser.aruba_uid:
                            api_parser.logout()
                            return_results('ok')
                        else:
                            api_parser.logout()
                            return_results('Could not login, please check the credentials provided')

                except Exception as ex:
                    return_error("WLC got exception: %s" % str(ex))
            elif demisto.command() == 'aruba-wlc-get-all-client-details':
                # this command will just fetch all the data from WLC
                try:
                    if access_method == "SSH":
                        ssh_parser = ArubaControllerSSHParser()
                        json_obj = ssh_parser.wlc_get_devices_data()
                    else:
                        api_parser = ArubaControllerAPIParser()
                        json_obj = api_parser.wlc_get_devices_data()
                    rp_data = {}
                    if json_obj:
                        rp_data["Total Clients"] = json_obj["_source"]["evtContent"]["uniqueClients"]
                    else:
                        rp_data["Total Clients"] = 0
                    return_results(CommandResults(
                        readable_output=tableToMarkdown("Asset Report Summary:", rp_data, removeNull=True),
                        outputs_prefix='aruba-wlc-IoT.devices',
                        outputs=json_obj
                    ))
                except Exception as ex:
                    return_error("Exception while running aruba-wlc-get-all-client-details command: %s" % str(ex))
            elif demisto.command() == 'aruba-wlc-get-active-ap':
                # this command will just fetch all the active APs from WLC
                try:
                    rp_data = {}
                    if access_method == "SSH":
                        ssh_parser = ArubaControllerSSHParser()
                        active_ap_list = ssh_parser.wlc_get_active_ap()
                    else:
                        api_parser = ArubaControllerAPIParser()
                        active_ap_list = api_parser.wlc_get_active_ap()
                    if active_ap_list:
                        rp_data["Total Active AP"] = len(active_ap_list)
                    else:
                        rp_data["Total Active AP"] = 0
                    return_results(CommandResults(
                        readable_output=tableToMarkdown("Asset Report Summary:", rp_data, removeNull=True),
                        outputs_prefix='aruba-wlc-IoT.active_ap',
                        outputs=active_ap_list
                    ))
                except Exception as ex:
                    return_error("Exception while running aruba-wlc-get-active-ap command: %s" % str(ex))

            elif demisto.command() == 'aruba-wlc-get-active-client-list':
                # this command will just fetch all the active client MAC addresses from WLC
                try:
                    if access_method == "SSH":
                        ssh_parser = ArubaControllerSSHParser()
                        active_client_list = ssh_parser.wlc_get_active_client_list(args)
                    else:
                        api_parser = ArubaControllerAPIParser()
                        active_client_list = api_parser.wlc_get_active_client_list(args)
                    rp_data = {}
                    if active_client_list:
                        rp_data["Total Active Clients"] = len(active_client_list)
                    else:
                        rp_data["Total Active Clients"] = 0
                    return_results(CommandResults(
                        readable_output=tableToMarkdown("Asset Report Summary:", rp_data, removeNull=True),
                        outputs_prefix='aruba-wlc-IoT.active_client_list',
                        outputs=active_client_list
                    ))
                except Exception as ex:
                    return_error("Exception while running wlc-get-active-client-list command: %s" % str(ex))
            elif demisto.command() == 'aruba-wlc-get-client-details-using-mac':
                # this command will just fetch all the active client details from WLC
                try:
                    if access_method == "SSH":
                        ssh_parser = ArubaControllerSSHParser()
                        active_client_details = ssh_parser.wlc_get_client_details_using_mac(args)
                    else:
                        api_parser = ArubaControllerAPIParser()
                        active_client_details = api_parser.wlc_get_client_details_using_mac(args)
                    return_results(CommandResults(
                        readable_output=tableToMarkdown("Asset Summary for MAC: {}".format(
                            args.get('mac_address')), active_client_details, removeNull=True),
                        outputs_prefix='aruba-wlc-IoT.active_client_details',
                        outputs=active_client_details
                    ))
                except Exception as ex:
                    return_error("Exception while running aruba-wlc-get-client-details-using-mac command: %s" % str(ex))
            elif demisto.command() == 'aruba-wlc-get-all-bluetooth-client-details':
                # this command will just fetch all the data from WLC
                try:
                    if access_method == "SSH":
                        ssh_parser = ArubaControllerSSHParser()
                        json_obj = ssh_parser.wlc_get_bluetooth_devices_data()
                    else:
                        api_parser = ArubaControllerAPIParser()
                        json_obj = api_parser.wlc_get_bluetooth_devices_data()
                    rp_data = {}
                    if json_obj:
                        rp_data["Total Clients"] = json_obj["_source"]["evtContent"]["uniqueClients"]
                    else:
                        rp_data["Total Clients"] = 0
                    return_results(CommandResults(
                        readable_output=tableToMarkdown("Asset Report Summary:", rp_data, removeNull=True),
                        outputs_prefix='aruba-wlc-IoT.bt_devices',
                        outputs=json_obj
                    ))
                except Exception as ex:
                    return_error("Exception while running aruba-wlc-get-all-bluetooth-client-details command: %s" % str(ex))
            elif demisto.command() == 'aruba-wlc-get-all-switches':
                # this command will just fetch all the data from WLC
                try:
                    if access_method == "SSH":
                        ssh_parser = ArubaControllerSSHParser()
                        json_obj = ssh_parser.wlc_get_switch_details()
                    else:
                        api_parser = ArubaControllerAPIParser()
                        json_obj = api_parser.wlc_get_switch_details()
                    rp_data = {}
                    if json_obj:
                        rp_data["Total Switch"] = len(json_obj)
                    else:
                        rp_data["Total Switch"] = 0
                    return_results(CommandResults(
                        readable_output=tableToMarkdown("Asset Report Summary:", rp_data, removeNull=True),
                        outputs_prefix='aruba-wlc-IoT.switches',
                        outputs=json_obj
                    ))
                except Exception as ex:
                    return_error("Exception while running aruba-wlc-get-all-switches command: %s" % str(ex))
            elif demisto.command() == 'aruba-wlc-get-all-iap':
                # this command will just fetch all the data from WLC
                try:
                    if access_method == "SSH":
                        ssh_parser = ArubaControllerSSHParser()
                        json_obj = ssh_parser.wlc_get_all_iap()
                    else:
                        api_parser = ArubaControllerAPIParser()
                        json_obj = api_parser.wlc_get_all_iap()
                    rp_data = {}
                    if json_obj:
                        rp_data["Total IAPs"] = len(json_obj)
                    else:
                        rp_data["Total IAPs"] = 0
                    return_results(CommandResults(
                        readable_output=tableToMarkdown("Asset Report Summary:", rp_data, removeNull=True),
                        outputs_prefix='aruba-wlc-IoT.switches',
                        outputs=json_obj
                    ))
                except Exception as ex:
                    return_error("Exception while running aruba-wlc-get-all-iap command: %s" % str(ex))
            elif demisto.command() == 'aruba-wlc-execute-command':
                command = demisto.args().get('command')
                try:
                    if access_method == "SSH":
                        ssh_parser = ArubaControllerSSHParser()
                        return_results(ssh_parser.execute_command(command))
                    else:
                        api_parser = ArubaControllerAPIParser()
                        return_results(api_parser.execute_command(command))
                except Exception as ex:
                    return_error("Execute command got exception: %s" % str(ex))

        # Log exceptions and return errors
        except Exception as ex:
            demisto.error(traceback.format_exc())  # Show the traceback
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(ex)}')

    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('PANW IoT 3rd Party Integration - Aruba WLAN Controller', 'end', __line__())
  subtype: python3
  type: python
sourcemoduleid: Aruba WLAN Controller
