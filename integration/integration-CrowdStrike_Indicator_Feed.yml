category: Data Enrichment & Threat Intelligence
commonfields:
  id: CrowdStrike Indicator Feed
  version: -1
configuration:
- defaultvalue: "true"
  display: Fetch indicators
  name: feed
  required: false
  type: 8
- defaultvalue: https://api.crowdstrike.com/
  display: CrowdStrike Base URL
  name: base_url
  required: true
  type: 0
- additionalinfo: For non 6.1 - enter your CrowdStrike API Client Secret in the password
    field.
  display: CrowdStrike API Client ID
  displaypassword: CrowdStrike API Client Secret
  name: credentials
  required: true
  type: 9
- defaultvalue: "10"
  display: The amount of time (in seconds) that a request will wait for a client to
    establish a connection to a remote machine before a timeout occurs.
  name: timeout
  required: false
  type: 0
- additionalinfo: 'The indicator types to fetch. Out-of-the-box indicator types supported
    in XSOAR are: "Account", "Domain", "Email", "File MD5", "File SHA-256", "IP",
    "Registry Key", and "URL". The default is "ALL".'
  display: Type
  name: type
  options:
  - ALL
  - Account
  - Domain
  - Email
  - File MD5
  - File SHA-256
  - IP
  - Registry Key
  - URL
  required: false
  type: 16
- additionalinfo: 'The time range to consider for the initial data fetch. Warning:
    This feed may fetch tens of thousands of indicators per day. Please consider this
    when configuring this parameter to further in the past, as it may overload the
    system with indicators.'
  defaultvalue: 1 week
  display: First fetch time
  name: first_fetch
  required: true
  type: 0
- additionalinfo: Maximum number of indicators per fetch. Value should be between
    1 - 10000. A large value may result in a timeout.
  defaultvalue: "5000"
  display: Max. indicators per fetch
  name: max_indicator_to_fetch
  required: false
  type: 0
- additionalinfo: Malicious confidence level to filter by.
  display: Malicious confidence
  name: malicious_confidence
  options:
  - high
  - medium
  - low
  - unverified
  required: false
  type: 16
- display: Include deleted indicators
  name: include_deleted
  required: false
  type: 8
- additionalinfo: 'Advanced: FQL query. For more information visit the CrowdStrike
    documentation.'
  display: Filter
  name: filter
  required: false
  type: 0
- additionalinfo: Generic phrase match search across all indicator fields.
  display: Generic phrase match
  name: generic_phrase
  required: false
  type: 0
- additionalinfo: Indicators from this integration instance will be marked with this
    reputation.
  defaultvalue: Bad
  display: Indicator Reputation
  name: feedReputation
  options:
  - None
  - Good
  - Suspicious
  - Bad
  required: false
  type: 18
- additionalinfo: Reliability of the source providing the intelligence data.
  defaultvalue: A - Completely reliable
  display: Source Reliability
  name: feedReliability
  options:
  - A - Completely reliable
  - B - Usually reliable
  - C - Fairly reliable
  - D - Not usually reliable
  - E - Unreliable
  - F - Reliability cannot be judged
  required: true
  type: 15
- additionalinfo: The Traffic Light Protocol (TLP) designation to apply to indicators
    fetched from the feed.
  defaultvalue: GREEN
  display: Traffic Light Protocol Color
  name: tlp_color
  options:
  - RED
  - AMBER
  - GREEN
  - WHITE
  required: false
  type: 15
- defaultvalue: indicatorType
  display: ""
  name: feedExpirationPolicy
  options:
  - never
  - interval
  - indicatorType
  - suddenDeath
  required: false
  type: 17
- defaultvalue: "20160"
  display: ""
  name: feedExpirationInterval
  required: false
  type: 1
- defaultvalue: "240"
  display: Feed Fetch Interval
  name: feedFetchInterval
  required: false
  type: 19
- additionalinfo: Supports CSV values.
  display: Tags
  name: feedTags
  required: false
  type: 0
- additionalinfo: Create relationships between indicators as part of Enrichment.
  defaultvalue: "true"
  display: Create relationships
  name: create_relationships
  required: false
  type: 8
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- additionalinfo: When selected, the exclusion list is ignored for indicators from
    this feed. This means that if an indicator from this feed is on the exclusion
    list, the indicator might still be added to the system.
  display: Bypass exclusion list
  name: feedBypassExclusionList
  required: false
  type: 8
- additionalinfo: Incremental feeds pull only new or modified indicators that have
    been sent from the integration. As the determination if the indicator is new or
    modified happens on the 3rd-party vendor's side, and only indicators that are
    new or modified are sent to Cortex XSOAR, all indicators coming from these feeds
    are labeled new or modified.
  defaultvalue: "true"
  display: Incremental Feed
  hidden: true
  name: feedIncremental
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: 5.5.0
    itemVersion: 2.1.16
    packID: FeedCrowdstrikeFalconIntel
    packName: Crowdstrike Falcon Intel Feed
    packPropagationLabels:
    - all
    prevname: ""
    propagationLabels: []
    toServerVersion: ""
description: Retrieves indicators from the CrowdStrike Falcon Intel Feed.
detaileddescription: |-
  To define a CrowdStrike API client, you must be assigned the role of a Falcon Administrator. This will allow you to view, create, or modify API clients or keys. Secrets are only shown when a new API client is created or when it is reset.

  1. Log in to the Falcon UI.
  2. Navigate to **Support** > **API Clients and Keys**.
  3. From there you can view existing clients, add new API clients, or view the audit log.

  For more information visit the [CrowdStrike documentation](https://www.crowdstrike.com/blog/tech-center/get-access-falcon-apis/).


  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/crowd-strike-indicator-feed)
display: CrowdStrike Indicator Feed
image: data:image/png;base64,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
name: CrowdStrike Indicator Feed
script:
  commands:
  - arguments:
    - description: The maximum number of indicators to return. Default is 50.
      name: limit
    - description: The index of the first indicator to fetch.
      name: offset
    - description: The minimum timestamp to fetch indicators by.
      name: last_run
    description: Gets indicators from the CrowdStrike Falcon Intel Feed.
    name: crowdstrike-indicators-list
    outputs:
    - contextPath: CrowdStrikeFalconIntel.Indicators.id
      description: Indicator ID.
      type: String
    - contextPath: CrowdStrikeFalconIntel.Indicators.value
      description: Indicator value.
      type: String
    - contextPath: CrowdStrikeFalconIntel.Indicators.type
      description: Indicator type.
      type: String
    - contextPath: CrowdStrikeFalconIntel.Indicators.fields.reports
      description: Indicator reports.
      type: Unknown
    - contextPath: CrowdStrikeFalconIntel.Indicators.fields.actors
      description: Actors related to the indicator.
      type: Unknown
    - contextPath: CrowdStrikeFalconIntel.Indicators.fields.malwarefamily
      description: Indicator malware families.
      type: Unknown
    - contextPath: CrowdStrikeFalconIntel.Indicators.fields.stixkillchainphases
      description: Indicator kill chains.
      type: Unknown
    - contextPath: CrowdStrikeFalconIntel.Indicators.fields.maliciousconfidence
      description: Indicator malicious confidence.
      type: String
    - contextPath: CrowdStrikeFalconIntel.Indicators.fields.tags
      description: Indicator labels.
      type: Unknown
    - contextPath: CrowdStrikeFalconIntel.Indicators.fields.targets
      description: Targets of the indicator.
      type: Unknown
    - contextPath: CrowdStrikeFalconIntel.Indicators.fields.threattypes
      description: Indicator threat types.
      type: Unknown
    - contextPath: CrowdStrikeFalconIntel.Indicators.fields.vulnerabilities
      description: Indicator vulnerabilities.
      type: Unknown
    - contextPath: CrowdStrikeFalconIntel.Indicators.fields.ipaddress
      description: Indicator related IP address.
      type: Unknown
    - contextPath: CrowdStrikeFalconIntel.Indicators.fields.domainname
      description: Indicator related domains.
      type: Unknown
    - contextPath: CrowdStrikeFalconIntel.Indicators.fields.updateddate
      description: Indicator update date.
      type: Date
    - contextPath: CrowdStrikeFalconIntel.Indicators.fields.creationdate
      description: Indicator creation date.
      type: Unknown
    - contextPath: CrowdStrikeFalconIntel.Indicators.rawJSON
      description: Raw response.
      type: Unknown
  - arguments: []
    description: 'Resets the retrieving start time according to the `First Fetch Time`
      parameter, WARNING: This command will reset your fetch history.'
    name: crowdstrike-reset-fetch-indicators
  dockerimage: demisto/python3:3.10.13.84405
  feed: true
  nativeimage:
  - "8.6"
  runonce: false
  script: |
    register_module_line('CrowdStrike Indicator Feed', 'start', __line__())
    ### pack version: 2.1.16


    import copy



    ### GENERATED CODE ###: from CrowdStrikeApiModule import *  # noqa: E402
    # This code was inserted in place of an API module.
    register_module_line('CrowdStrikeApiModule', 'start', __line__(), wrapper=-3)


    from datetime import timedelta
    import dateparser

    TOKEN_LIFE_TIME = timedelta(minutes=28)


    class CrowdStrikeClient(BaseClient):

        def __init__(self, params):
            """
            CrowdStrike Client class that implements OAuth2 authentication.
            Args:
                params: Demisto params
            """
            credentials = params.get('credentials', {})
            self._client_id = credentials.get('identifier')
            self._client_secret = credentials.get('password')
            super().__init__(base_url=params.get('server_url', 'https://api.crowdstrike.com/'),
                             verify=not params.get('insecure', False), ok_codes=tuple(),
                             proxy=params.get('proxy', False))  # type: ignore[misc]
            self.timeout = float(params.get('timeout', '10'))
            self._token = self._get_token()
            self._headers = {'Authorization': 'bearer ' + self._token}

        @staticmethod
        def _error_handler(res: requests.Response):
            """
            Converting the errors of the API to a string, in case there are no error, return an empty string
            :param res: the request's response
            :return: None
            """
            err_msg = 'Error in API call [{}] - {}\n'.format(res.status_code, res.reason)
            try:
                # Try to parse json error response
                error_entry = res.json()
                errors = error_entry.get('errors', [])
                err_msg += '\n'.join(f"{error.get('code')}: {error.get('message')}" for  # pylint: disable=no-member
                                     error in errors)
                if 'Failed to issue access token - Not Authorized' in err_msg:
                    err_msg = err_msg.replace('Failed to issue access token - Not Authorized',
                                              'Client Secret is invalid.')
                elif 'Failed to generate access token for clientID' in err_msg:
                    err_msg = err_msg.replace('Failed to generate access token for clientID=', 'Client ID (')
                    if err_msg.endswith('.'):
                        err_msg = err_msg[:-1]
                    err_msg += ') is invalid.'
                raise DemistoException(err_msg)
            except ValueError:
                err_msg += '\n{}'.format(res.text)
                raise DemistoException(err_msg)

        def http_request(self, method, url_suffix, full_url=None, headers=None, json_data=None, params=None, data=None,
                         files=None, timeout=10, ok_codes=None, return_empty_response=False, auth=None, resp_type='json'):
            """A wrapper for requests lib to send our requests and handle requests and responses better.

            :type method: ``str``
            :param method: The HTTP method, for example: GET, POST, and so on.

            :type url_suffix: ``str``
            :param url_suffix: The API endpoint.

            :type full_url: ``str``
            :param full_url:
                Bypasses the use of self._base_url + url_suffix. This is useful if you need to
                make a request to an address outside of the scope of the integration
                API.

            :type headers: ``dict``
            :param headers: Headers to send in the request. If None, will use self._headers.

            :type params: ``dict``
            :param params: URL parameters to specify the query.

            :type data: ``dict``
            :param data: The data to send in a 'POST' request.

            :type json_data: ``dict``
            :param json_data: The dictionary to send in a 'POST' request.

            :type files: ``dict``
            :param files: The file data to send in a 'POST' request.

            :type timeout: ``float`` or ``tuple``
            :param timeout:
                The amount of time (in seconds) that a request will wait for a client to
                establish a connection to a remote machine before a timeout occurs.
                can be only float (Connection Timeout) or a tuple (Connection Timeout, Read Timeout).

            :type ok_codes: ``tuple``
            :param ok_codes:
                The request codes to accept as OK, for example: (200, 201, 204). If you specify
                "None", will use self._ok_codes.

            :type return_empty_response: ``bool``
            :param return_empty_response: Indicates whether we are expecting empty response (like 204) or not.

            :return: Depends on the resp_type parameter
            :rtype: ``dict`` or ``str`` or ``requests.Response``
            """

            req_timeout = timeout
            if self.timeout:
                req_timeout = self.timeout

            return super()._http_request(method=method, url_suffix=url_suffix, full_url=full_url, headers=headers,
                                         json_data=json_data, params=params, data=data, files=files, timeout=req_timeout,
                                         ok_codes=ok_codes, return_empty_response=return_empty_response, auth=auth,
                                         error_handler=self._error_handler, resp_type=resp_type)

        def _get_token(self, force_gen_new_token=False):
            """
                Retrieves the token from the server if it's expired and updates the global HEADERS to include it

                :param force_gen_new_token: If set to True will generate a new token regardless of time passed

                :rtype: ``str``
                :return: Token
            """
            now = datetime.now()
            ctx = get_integration_context()
            if not ctx or not ctx.get('generation_time', force_gen_new_token):
                # new token is needed
                auth_token = self._generate_token()
            else:
                generation_time = dateparser.parse(ctx.get('generation_time'))
                if generation_time and now:
                    time_passed = now - generation_time
                else:
                    time_passed = TOKEN_LIFE_TIME
                if time_passed < TOKEN_LIFE_TIME:
                    # token hasn't expired
                    return ctx.get('auth_token')
                else:
                    # token expired
                    auth_token = self._generate_token()

            ctx.update({'auth_token': auth_token, 'generation_time': now.strftime("%Y-%m-%dT%H:%M:%S")})
            set_integration_context(ctx)
            return auth_token

        def _generate_token(self) -> str:
            """Generate an Access token using the user name and password
            :return: valid token
            """
            body = {
                'client_id': self._client_id,
                'client_secret': self._client_secret
            }
            token_res = self.http_request('POST', '/oauth2/token', data=body, auth=(self._client_id, self._client_secret))
            return token_res.get('access_token')

        def check_quota_status(self) -> dict:
            """Checking the status of the quota
            :return: http response
            """
            url_suffix = "/falconx/entities/submissions/v1?ids="
            return self.http_request('GET', url_suffix)

    register_module_line('CrowdStrikeApiModule', 'end', __line__(), wrapper=1)
    ### END GENERATED CODE ###

    # IMPORTS
    import urllib3

    urllib3.disable_warnings()


    XSOAR_TYPES_TO_CROWDSTRIKE = {
        'account': "username",
        'domain': "domain",
        'email': "email_address",
        'file md5': "hash_md5",
        'file sha-256': "hash_sha256",
        'ip': "ip_address",
        'registry key': "registry",
        'url': "url"
    }
    CROWDSTRIKE_TO_XSOAR_TYPES = {
        'username': FeedIndicatorType.Account,
        'domain': FeedIndicatorType.Domain,
        'email_address': FeedIndicatorType.Email,
        'hash_md5': FeedIndicatorType.File,
        'hash_sha1': FeedIndicatorType.File,
        'hash_sha256': FeedIndicatorType.File,
        'registry': FeedIndicatorType.Registry,
        'url': FeedIndicatorType.URL,
        'ip_address': FeedIndicatorType.IP,
        'reports': ThreatIntel.ObjectsNames.REPORT,
        'actors': ThreatIntel.ObjectsNames.THREAT_ACTOR,
        'malware_families': ThreatIntel.ObjectsNames.MALWARE,
        'vulnerabilities': FeedIndicatorType.CVE
    }
    INDICATOR_TO_CROWDSTRIKE_RELATION_DICT: Dict[str, Any] = {
        ThreatIntel.ObjectsNames.REPORT: {
            FeedIndicatorType.File: EntityRelationship.Relationships.INDICATOR_OF,
            FeedIndicatorType.IP: EntityRelationship.Relationships.INDICATOR_OF,
            FeedIndicatorType.Domain: EntityRelationship.Relationships.INDICATOR_OF,
            FeedIndicatorType.URL: EntityRelationship.Relationships.INDICATOR_OF,
            FeedIndicatorType.Email: EntityRelationship.Relationships.RELATED_TO,
            FeedIndicatorType.Registry: EntityRelationship.Relationships.RELATED_TO,
            FeedIndicatorType.Account: EntityRelationship.Relationships.RELATED_TO
        },
        ThreatIntel.ObjectsNames.THREAT_ACTOR: {
            FeedIndicatorType.File: EntityRelationship.Relationships.INDICATOR_OF,
            FeedIndicatorType.IP: EntityRelationship.Relationships.INDICATOR_OF,
            FeedIndicatorType.Domain: EntityRelationship.Relationships.INDICATOR_OF,
            FeedIndicatorType.URL: EntityRelationship.Relationships.INDICATOR_OF,
            FeedIndicatorType.Email: EntityRelationship.Relationships.INDICATOR_OF,
            FeedIndicatorType.Registry: EntityRelationship.Relationships.RELATED_TO,
            FeedIndicatorType.Account: EntityRelationship.Relationships.RELATED_TO
        },
        ThreatIntel.ObjectsNames.MALWARE: {
            FeedIndicatorType.File: EntityRelationship.Relationships.INDICATOR_OF,
            FeedIndicatorType.IP: EntityRelationship.Relationships.INDICATOR_OF,
            FeedIndicatorType.Domain: EntityRelationship.Relationships.INDICATOR_OF,
            FeedIndicatorType.URL: EntityRelationship.Relationships.INDICATOR_OF,
            FeedIndicatorType.Email: EntityRelationship.Relationships.INDICATOR_OF,
            FeedIndicatorType.Registry: EntityRelationship.Relationships.RELATED_TO,
            FeedIndicatorType.Account: EntityRelationship.Relationships.RELATED_TO
        },
        FeedIndicatorType.CVE: {
            FeedIndicatorType.File: EntityRelationship.Relationships.INDICATOR_OF,
            FeedIndicatorType.IP: EntityRelationship.Relationships.INDICATOR_OF,
            FeedIndicatorType.Domain: EntityRelationship.Relationships.INDICATOR_OF,
            FeedIndicatorType.URL: EntityRelationship.Relationships.INDICATOR_OF,
            FeedIndicatorType.Email: EntityRelationship.Relationships.INDICATOR_OF,
            FeedIndicatorType.Registry: EntityRelationship.Relationships.RELATED_TO,
            FeedIndicatorType.Account: EntityRelationship.Relationships.RELATED_TO
        }
    }
    CROWDSTRIKE_INDICATOR_RELATION_FIELDS = ['reports', 'actors', 'malware_families', 'vulnerabilities', 'relations']


    def kill_chain_standard_values(phases: list | None):
        """
        Will convert crowdstrike's return values for kill chain to our standard kill chain syntax.
        Args:
            phase: the raw inout from the api
        Returns: the standardized value, or the given value if not found
        """
        if not phases:
            return phases
        return [{
            'reconnaissance': 'Reconnaissance',
            'weaponization': 'Weaponization',
            'installation': 'Installation',
            'exploitation': 'Exploitation',
            'delivery': 'Delivery',
            'c2': 'Command & Control',
            'actionOnObjectives': 'Actions on Objectives'
        }.get(phase.lower(), phase) for phase in phases]


    class Client(CrowdStrikeClient):

        def __init__(self, credentials, base_url, include_deleted, type, limit, tlp_color=None, feed_tags=None,
                     malicious_confidence=None, filter_string=None, generic_phrase=None, insecure=True, proxy=False,
                     first_fetch=None, create_relationships=True, timeout='10'):
            params = assign_params(credentials=credentials,
                                   server_url=base_url,
                                   insecure=insecure,
                                   ok_codes=(),
                                   proxy=proxy,
                                   timeout=timeout)
            super().__init__(params)
            self.type = type
            self.malicious_confidence = malicious_confidence
            self.filter_string = filter_string
            self.generic_phrase = generic_phrase
            self.include_deleted = include_deleted
            self.tlp_color = tlp_color
            self.feed_tags = feed_tags
            self.limit = limit
            self.first_fetch = first_fetch
            self.create_relationships = create_relationships

        def get_indicators(self, params):
            response = super().http_request(
                method='GET',
                params=params,
                url_suffix='intel/combined/indicators/v1',
                timeout=30
            )
            return response

        def get_actors_names_request(self, params_string):
            response = self._http_request(
                method='GET',
                url_suffix=f'intel/entities/actors/v1?{params_string}',
                timeout=30
            )
            if 'resources' not in response:
                raise DemistoException("Get actors request completed. Parse error: could not find resources in response.")
            return response['resources']

        def fetch_indicators(self,
                             limit: int,
                             offset: int = 0,
                             fetch_command: bool = False,
                             manual_last_run: int = 0) -> list:
            """ Get indicators from CrowdStrike API

            Args:
                limit(int): number of indicators to return
                offset: indicators offset
                fetch_command: In order not to update last_run time if it is not fetch command
                manual_last_run: The minimum timestamp to fetch indicators by

            Returns:
                (list): parsed indicators
            """
            indicators: list[dict] = []
            filter_string = f'({self.filter_string})' if self.filter_string else ''
            if self.type:
                type_fql = self.build_type_fql(self.type)
                filter_string = f'({type_fql})+{filter_string}' if filter_string else f'({type_fql})'

            if self.malicious_confidence:
                malicious_confidence_fql = ','.join([f"malicious_confidence:'{item}'"
                                                     for item in self.malicious_confidence])
                filter_string = f"{filter_string}+({malicious_confidence_fql})" if filter_string else f'({malicious_confidence_fql})'

            if manual_last_run:
                filter_string = f'{filter_string}+(last_updated:>={manual_last_run})' \
                                if filter_string else f'(last_updated:>={manual_last_run})'

            if fetch_command:
                if last_run := self.get_last_run():
                    filter_string = f'{filter_string}+({last_run})' if filter_string else f'({last_run})'
                else:
                    filter_string, indicators = self.handle_first_fetch_context_or_pre_2_1_0(filter_string)
                    if indicators:
                        limit = limit - len(indicators)

            if filter_string or not fetch_command:
                demisto.debug(f'{filter_string=}')
                params = assign_params(include_deleted=self.include_deleted,
                                       limit=limit,
                                       offset=offset, q=self.generic_phrase,
                                       filter=filter_string,
                                       sort='_marker|asc')

                response = self.get_indicators(params=params)

                # need to fetch all indicators after the limit
                if resources := response.get('resources', []):
                    new_last_marker_time = resources[-1].get('_marker')
                else:
                    new_last_marker_time = demisto.getIntegrationContext().get('last_marker_time')
                    last_marker_time_for_debug = new_last_marker_time or 'No data yet'
                    demisto.debug('There are no indicators, '
                                  f'using last_marker_time={last_marker_time_for_debug} from Integration Context')

                if fetch_command:
                    context = demisto.getIntegrationContext()
                    demisto.info(f"last_marker_time before updating: {context.get('last_marker_time')}")
                    context.update({'last_marker_time': new_last_marker_time})
                    demisto.setIntegrationContext(context)
                    demisto.info(f'set last_run to: {new_last_marker_time}')

                indicators.extend(self.create_indicators_from_response(response,
                                                                       self.get_actors_names_request,
                                                                       self.tlp_color,
                                                                       self.feed_tags,
                                                                       self.create_relationships,
                                                                       ))
            return indicators

        def handle_first_fetch_context_or_pre_2_1_0(self, filter_string: str) -> tuple[str, list[dict]]:
            '''
            Checks whether the context integration uses the format used up to version 2_1_0
            (when the `last_update` parameter was removed),
            or whether this is the first time of the fetch,
            If so, the function imports one indicator
            and extracts the `_marker` from it to import the following indicators.

            The function is only called in the following two cases:
                1. At the first run of v2.1.0 or newer.
                2. In order to transfer the context integration to the new implementation

            Returns:
                Tuple:
                    1. filter_string with the _marker key - str.
                    2. parse indicator that retrieved - list[dict].
            '''
            filter_for_first_fetch = filter_string
            if last_run := demisto.getIntegrationContext().get('last_updated') or self.first_fetch:
                last_run = f'last_updated:>={int(last_run)}'
                filter_for_first_fetch = f'{filter_string}+({last_run})' if filter_string else f'({last_run})'

            params = assign_params(include_deleted=self.include_deleted,
                                   limit=1,
                                   q=self.generic_phrase,
                                   filter=filter_for_first_fetch,
                                   sort='last_updated|asc')
            response = self.get_indicators(params=params)

            # In case there is an indicator for extracting the `_marker`
            # it allows fetching following indicators better.
            if resources := response.get('resources', []):
                _marker = resources[-1].get('_marker')
                demisto.debug(f'Importing the indicator marker in first time: {_marker=}')
                last_run = f"_marker:>'{_marker}'"
                parse_indicator = self.create_indicators_from_response(response,
                                                                       self.get_actors_names_request,
                                                                       self.tlp_color,
                                                                       self.feed_tags,
                                                                       self.create_relationships)
                filter_string = f'{filter_string}+({last_run})' if filter_string else f'({last_run})'
                return filter_string, parse_indicator

            # In case no indicator is returned
            demisto.debug('No indicator returned')
            return '', []

        @staticmethod
        def get_last_run() -> str:
            """ Gets last run time in timestamp

            Returns:
                last run in timestamp, or '' if no last run.
                Taken from Integration Context key last_marker_time.

            """
            if last_run := demisto.getIntegrationContext().get('last_marker_time'):
                demisto.info(f'get last_run: {last_run}')
                params = f"_marker:>'{last_run}'"
            else:
                demisto.debug('There is no last_run (last_marker_time in Integration Context)')
                params = ''
            return params

        @staticmethod
        def create_indicators_from_response(raw_response, get_actors_names_request_func, tlp_color=None, feed_tags=None,
                                            create_relationships=True) -> list:
            """ Builds indicators from API raw response

                Args:
                    raw_response: response from crowdstrike API
                    tlp_color: tlp color chosen by customer
                    feed_tags: Feed tags to filter by
                    create_relationships: Whether to create relationships.

                Returns:
                    (list): list of indicators
                """

            parsed_indicators: list = []
            indicator: dict = {}

            for resource in raw_response['resources']:
                if not (type_ := auto_detect_indicator_type_from_cs(resource['indicator'], resource['type'])):
                    demisto.debug(f"Indicator {resource['indicator']} of type {resource['type']} is not supported in XSOAR, skipping")
                    continue
                indicator = {
                    'type': type_,
                    'value': resource.get('indicator'),
                    'rawJSON': resource,
                    'fields': {'actor': resource.get('actors'),
                               'reports': resource.get('reports'),
                               'malwarefamily': resource.get('malware_families'),
                               'stixkillchainphases': kill_chain_standard_values(resource.get('kill_chains')),
                               'ipaddress': resource.get('ip_address_types'),
                               'domainname': resource.get('domain_types'),
                               'targets': resource.get('targets'),
                               'threattypes': [{'threatcategory': threat} for threat in resource.get('threat_types', [])],
                               'vulnerabilities': resource.get('vulnerabilities'),
                               'confidence': resource.get('malicious_confidence'),
                               'updateddate': resource.get('last_updated'),
                               'creationdate': resource.get('published_date'),
                               'tags': [label.get('name') for label in resource.get('labels')]  # type: ignore
                               }
                }
                if tlp_color:
                    indicator['fields']['trafficlightprotocol'] = tlp_color
                if feed_tags:
                    indicator['fields']['tags'].extend(feed_tags)
                if create_relationships:
                    relationships = create_and_add_relationships(indicator, resource, get_actors_names_request_func)
                    indicator['relationships'] = relationships
                parsed_indicators.append(indicator)

            return parsed_indicators

        @staticmethod
        def build_type_fql(types_list: list) -> str:
            """ Builds an indicator type query for the filter parameter

            Args:
                types_list(list): indicator types that was chosen by user

            Returns:
                (str): FQL query containing the relevant indicator types we want to fetch from Crowdstrike
            """

            if 'ALL' in types_list:
                # Replaces "ALL" for all types supported on XSOAR.
                crowdstrike_types = [f"type:'{type}'" for type in CROWDSTRIKE_TO_XSOAR_TYPES]
            else:
                crowdstrike_types = [f"type:'{XSOAR_TYPES_TO_CROWDSTRIKE.get(type.lower())}'" for type in types_list if
                                     type.lower() in XSOAR_TYPES_TO_CROWDSTRIKE]

            result = ','.join(crowdstrike_types)
            return result


    def create_and_add_relationships(indicator: dict, resource: dict, get_actors_names_request_func) -> list:
        """
        Creates and adds relationships to indicators for each CrowdStrike relationships type.

        Args:
            indicator(dict): The indicator in XSOAR format.
            resource(dict): The indicator from the response.

        Returns:
            List of relationships objects.
        """

        relationships = []

        for field in CROWDSTRIKE_INDICATOR_RELATION_FIELDS:
            if field in resource and resource[field]:
                relationships.extend(create_relationships(field, indicator, resource, get_actors_names_request_func))

        return relationships


    def create_relationships(
        field: str, indicator: dict, resource: dict, get_actors_names_request_func
    ) -> List:
        """
        Creates indicator relationships.

        Args:
            field(str): A CrowdStrike indicator field which contains relationships.
            indicator(dict): The indicator in XSOAR format.
            resource(dict): The indicator from the response.

        Returns:
            List of relationships objects.
        """
        relationships = []
        if field == 'actors' and resource['actors']:
            resource['actors'] = change_actors_from_id_to_name(resource['actors'], get_actors_names_request_func)
        for relation in resource[field]:
            if field == 'relations' and not CROWDSTRIKE_TO_XSOAR_TYPES.get(relation.get('type')):
                demisto.debug(f"The related indicator type {relation.get('type')} is not supported in XSOAR.")
                continue
            if field == 'relations':
                related_indicator_type = auto_detect_indicator_type_from_cs(relation['indicator'], relation['type'])
                relation_name = EntityRelationship.Relationships.RELATED_TO
            else:
                related_indicator_type = CROWDSTRIKE_TO_XSOAR_TYPES[field]
                relation_name = INDICATOR_TO_CROWDSTRIKE_RELATION_DICT[related_indicator_type].get(indicator['type'],
                                                                                                   indicator['type'])

            indicator_relation = EntityRelationship(
                name=relation_name,
                entity_a=indicator['value'],
                entity_a_type=indicator['type'],
                entity_b=relation['indicator'] if field == 'relations' else relation,
                entity_b_type=related_indicator_type,
                reverse_name=EntityRelationship.Relationships.RELATIONSHIPS_NAMES.get(relation_name, '')
            ).to_indicator()

            relationships.append(indicator_relation)
        return relationships


    def change_actors_from_id_to_name(indicator_actors_array: List[str], get_name_of_actors__func):
        integration_context = get_integration_context()
        actors_to_convert = []
        converted_actors_array = []
        for actor in indicator_actors_array:
            if converted_actor := integration_context.get(actor, None):
                converted_actors_array.append(converted_actor)
            else:
                actors_to_convert.append(actor)
        if actors_to_convert:
            actor_ids_params = 'ids=' + '&ids='.join(actors_to_convert) + '&fields=name'
            actors_response = get_name_of_actors__func(actor_ids_params)
            converted_actors_from_request = []
            for actor_dict in actors_response:
                converted_actors_from_request.append(actor_dict.get('name'))
            zipped_actors_list_to_context = dict(zip(actors_to_convert, converted_actors_from_request))
            update_integration_context(zipped_actors_list_to_context)
            converted_actors_array += converted_actors_from_request
        return converted_actors_array


    def auto_detect_indicator_type_from_cs(value: str, crowdstrike_resource_type: str) -> str | None:
        '''
        The function determines the type of indicator according to two cases::
        1. In case the type is ip_address then the type is detected by auto_detect_indicator_type function (CSP).
        2. In any other case, the type is converted by the table CROWDSTRIKE_TO_XSOAR_TYPES to a type of XSOAR.
        '''
        if crowdstrike_resource_type == 'ip_address':
            return auto_detect_indicator_type(value)

        return CROWDSTRIKE_TO_XSOAR_TYPES.get(crowdstrike_resource_type)


    def fetch_indicators_command(client: Client):
        """ fetch indicators from the Crowdstrike Intel

        Args:
            client: Client object

        Returns:
            list of indicators(list)
        """
        parsed_indicators = client.fetch_indicators(
            fetch_command=True,
            limit=client.limit
        )
        # we submit the indicators in batches
        for b in batch(parsed_indicators, batch_size=2000):
            demisto.createIndicators(b)
        return parsed_indicators


    def crowdstrike_indicators_list_command(client: Client, args: dict) -> CommandResults:
        """ Gets indicator from Crowdstrike Intel to readable output

        Args:
            client: Client object
            args: demisto.args()

        Returns:
            readable_output, raw_response
        """

        offset = arg_to_number(args.get('offset', 0)) or 0
        limit = arg_to_number(args.get('limit', 50)) or 50
        last_run = arg_to_number(args.get('last_run', 0)) or 0
        parsed_indicators = client.fetch_indicators(
            limit=limit,
            offset=offset,
            fetch_command=False,
            manual_last_run=last_run
        )
        if outputs := copy.deepcopy(parsed_indicators):
            for indicator in outputs:
                indicator['id'] = indicator.get('rawJSON', {}).get('id')

            readable_output = tableToMarkdown(name='Indicators from CrowdStrike Falcon Intel', t=outputs,
                                              headers=["type", "value", "id"], headerTransform=pascalToSpace)

            return CommandResults(
                outputs=outputs,
                outputs_prefix='CrowdStrikeFalconIntel.Indicators',
                outputs_key_field='id',
                readable_output=readable_output,
                raw_response=parsed_indicators
            )
        else:
            return CommandResults(
                readable_output='No Indicators.'
            )


    def test_module(client: Client, args: dict) -> str:
        try:
            client.fetch_indicators(limit=client.limit, fetch_command=False)
        except Exception:
            raise Exception("Could not fetch CrowdStrike Indicator Feed\n"
                            "\nCheck your API key and your connection to CrowdStrike.")
        return 'ok'


    def reset_last_run():
        """
        Reset the last run from the integration context
        """
        demisto.setIntegrationContext({})
        return CommandResults(readable_output='Fetch history deleted successfully')


    ''' MAIN FUNCTION '''


    def main() -> None:
        params = demisto.params()

        credentials = params.get('credentials')
        proxy = params.get('proxy', False)
        insecure = params.get('insecure', False)
        first_fetch_param = params.get('first_fetch')
        first_fetch_datetime = arg_to_datetime(first_fetch_param) if first_fetch_param else None
        first_fetch = first_fetch_datetime.timestamp() if first_fetch_datetime else None

        base_url = params.get('base_url')
        tlp_color = params.get('tlp_color')
        include_deleted = params.get('include_deleted', False)
        type = argToList(params.get('type'), 'ALL')
        malicious_confidence = argToList(params.get('malicious_confidence'))
        filter_string = params.get('filter')
        generic_phrase = params.get('generic_phrase')
        max_fetch = arg_to_number(params.get('max_indicator_to_fetch')) if params.get('max_indicator_to_fetch') else 10000
        max_fetch = min(max_fetch, 10000)  # type: ignore
        feed_tags = argToList(params.get('feedTags'))
        create_relationships = params.get('create_relationships', True)
        timeout = params.get('timeout')

        args = demisto.args()

        try:
            command = demisto.command()
            demisto.info(f'Command being called is {demisto.command()}')

            client = Client(
                credentials=credentials,
                base_url=base_url,
                insecure=insecure,
                proxy=proxy,
                tlp_color=tlp_color,
                feed_tags=feed_tags,
                include_deleted=include_deleted,
                type=type,
                malicious_confidence=malicious_confidence,
                filter_string=filter_string,
                generic_phrase=generic_phrase,
                limit=max_fetch,
                first_fetch=first_fetch,
                create_relationships=create_relationships,
                timeout=timeout
            )

            if command == 'test-module':
                # This is the call made when pressing the integration Test button.
                result = test_module(client, args)
                return_results(result)

            elif command == 'fetch-indicators':
                fetch_indicators_command(client=client)

            elif command == 'crowdstrike-indicators-list':
                return_results(crowdstrike_indicators_list_command(client, args))

            elif command == "crowdstrike-reset-fetch-indicators":
                return_results(reset_last_run())

        # Log exceptions and return errors
        except Exception as e:
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}')


    ''' ENTRY POINT '''

    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()

    register_module_line('CrowdStrike Indicator Feed', 'end', __line__())
  subtype: python3
  type: python
system: true
