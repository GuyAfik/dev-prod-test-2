category: Vulnerability Management
commonfields:
  id: PANW IoT 3rd Party Integration - Tenable.io
  version: -1
configuration:
- defaultvalue: https://cloud.tenable.com/
  display: URL
  name: url
  required: true
  type: 0
- display: Access key
  name: access-key
  required: true
  type: 4
- display: Secret key
  name: secret-key
  required: true
  type: 4
- display: Trust any certificate (not secure)
  name: unsecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: A comprehensive asset-centric solution to accurately track resources
  while accommodating dynamic assets such as cloud, mobile devices, containers, and
  web applications.
detaileddescription: "Tenable.io Integration\n\n\nPlease configure the instance by
  providing following details:\n\n1.Name of the instance\n2.URL of Tenable Cloud instance,
  ie: https://cloud.tenable.com/ \n3.Access and secret keys from Tenable API Access
  Key\n"
display: PANW IoT 3rd Party Integration - Tenable.io
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAMAAACgee/qAAABBVBMVEUAAABFVWVIV2ZEVWZIV2hJW2lFVWVFVWVKXGpOXnMAqLYAp7ZEVGQAp7UAqLYAqLZsdIAAp7ZEVWUAp7UAp7UAqLUAp7VFVWUAp7UAqLUAqLZEVGQAqLZFVWUAqLYAqLdEVGUAp7UAp7UAp7VEVWQAp7YAussAp7UAp7UAp7UAqLZFVmZHV2YAr7xQZHNEVWRFVWRFVWVFV2YAqbYAt8FEVGVEVWVFVWZGVmUAqrhIWGlMWmxFVGVEVWVFVWVFVWRGVWYAqLZHV2YAqrYArbtFVGUAqbVFWGlHV2lFVWREVWUAp7QAp7VGV2ZEVWVGVmVFVmYArLdEVWREVmUAq7dEVWVEVGQidPTWAAAAVnRSTlMAjCF7JhjRmRUMdmD0h2pSBIv8k4+voZ+Yb0/qZGRKRLy1qZyWgwXFgH5ZRjMQCPm1h008CfB1XEIoHxDj24+CbkE5LhewNyob5sK8pC+rVFEgpqEz5PhyY/gAAAQ1SURBVFjD7ZTZctowFEAva8DGNsZL7GDM4pp9h7AECBAC2ZukTfX/n1ItcQwkM51Op+lDOQ/oXkvWsdCV4MCBAwcO/D4be9yHf4BQbUiKXukV4XMRpJ7r3JXypVJBHMPnIQj31lJdFkWh52qybpzAH/AFIRTz0yBOA/Axap6/dK2GxHFiybpU+L5ZBcZjIBCI/zWxWlqZjpzXtILCibrSs8pFAxhHZJK/JZbvqiVBtmyxAStx495XZc7S/0B89EvxpHZFvIWCmS1nTVZTtsVrDa4krD6apNnccyST4NPcEzffi5Ns20adIfZWS32zzGXhlSKv3vdPShydoj3Fb+Xa30hydXyDUPpbncSZdrsdiQVmqVZ0QN1nnWgLJWbnZ564vk6gxNfwtvj6fIZQYl3D0WMNXIlTQTGK4HOpCS/3GolmiJHGcSiFGHOcBHCbOWX5Gi+k43Wmukw8YA8SQ188TCDGd/qpOiiVfn73+HC8IZaKu+I5eiNDxT4juPCTRJiIfeqeeMg+DJGMihvlii3vinmzXL1b4mAxj+Jx5/MB1HE7fZrER/hBesLEt4vRgKw6BNBGucxDcDgjo5k4t6iFSOftqziC13uaiTXrOYRaZAfKWb4i23tiUZUc4e1oRHC7xsOvABNLI9Sh4nO62Tg4xvufAcIVMVLxnKRhLEMXTNzBv11aX/jTv+K2J9sVY/NerOjb4iae4jZOOUYoSsVBOjcTw+RxMHxIQpp0HtF3MNQ2YGKsu4lTBng/kriINUmoZPfEriipcsMX0/l9Wr44wsQDWjg3j1MiZu8QuuSPYeIU2oYUf0EsjK09cWEjqXZvS/yAdojviTNe4aR2VkyL7oiKm2gHciZN3TjhdsViYVWV+9aW+Bo3s9AbzT1xGv8u4qRwtsWskjtsxaS2/Amucef4riyVK9ve4j23cu2s5InJqCnemIk/ZFd8hki9EG488RlNyYcMqZiGV7BDXgNJE5/BI1t2N6t8VgFP3H01teO0nBYfir8D4YcnjgbJtULq4ZqJM+RhhL4SAoaR54q8Y/N9mo3NpWg+awrzQohcH19z+BSR4HzRyaXQaF+cTGPBE0DsGHlilIq2bxBVUjE9RShxtJivWygDlGrVkE9454XHG90Qs5J1knfzCjBGiBKBi1PkEQX4qLhO01vFNUWMH5NXMQTZIzoyzq5mYWlmVZOzTNWVhYLrOOO8AR7fEWL/djiHKKl18J0Y5i16XWamnvjhFhHaMf+ujn1LIcrtBTB0WAp9scCPObnS2yi9Z80Bn/CoO2KlEruodWsPExqGw+EkvYdwEKF9T916E4Lh8BlEaGew9lQLe0NiQJjU8QT1mF9NellSpYahNPDq+UbFMeCzeLac/J3BFRzdFCoS2V+bW8En8cJpmmpfwtKgFcfZ8Hn0s4Kuq0Vacb0iHDhw4MCB/5yfYHowcdS9KS4AAAAASUVORK5CYII=
name: PANW IoT 3rd Party Integration - Tenable.io
script:
  commands:
  - arguments:
    - description: |-
        The ID of the folder whose scans should be listed. Scans are stored
        in specific folders on Tenable, e.g.: folderId=8.
      name: folderId
    - description: 'Limit the results to those that have only changed since this time.
        Format: YYYY-MM-DD'
      name: lastModificationDate
    - description: 'Limit the results to those that have only changed since this time.
        Format: "YYYY-MM-DD hh:mm:ss"'
      name: lastModificationTimestamp
    description: Retrieves scans from the Tenable platform.
    name: tenable-io-list-scans
    outputs:
    - contextPath: TenableIO.Scan.Id
      description: The unique ID of the scan.
      type: number
    - contextPath: TenableIO.Scan.Name
      description: The name of the scan.
      type: string
    - contextPath: TenableIO.Scan.Target
      description: The targets to scan.
      type: string
    - contextPath: TenableIO.Scan.Status
      description: The status of the scan (completed, aborted, imported, pending,
        running, resuming, canceling, cancelled, pausing, paused, stopping, stopped).
      type: string
    - contextPath: TenableIO.Scan.StartTime
      description: The scheduled start time for the scan.
      type: date
    - contextPath: TenableIO.Scan.EndTime
      description: The scheduled end time for the scan.
      type: date
    - contextPath: TenableIO.Scan.Enabled
      description: If true, the schedule for the scan is enabled.
      type: boolean
    - contextPath: TenableIO.Scan.Type
      description: The type of scan (local, remote, or agent).
      type: string
    - contextPath: TenableIO.Scan.Owner
      description: The owner of the scan.
      type: string
    - contextPath: TenableIO.Scan.Scanner
      description: The scanner assigned for the scan.
      type: string
    - contextPath: TenableIO.Scan.Policy
      description: The policy assigned for the scan.
      type: string
    - contextPath: TenableIO.Scan.CreationDate
      description: The creation date for the scan in Unix time.
      type: date
    - contextPath: TenableIO.Scan.LastModificationDate
      description: The last modification date for the scan in Unix time.
      type: date
    - contextPath: TenableIO.Scan.FolderId
      description: The unique ID of the folder where the scan has been stored.
      type: number
  - arguments:
    - default: true
      description: The ID of the scan to launch.
      name: scanId
      required: true
    - description: If specified, targets to be scanned instead of the default. This
        value can be an array where each index is a target, or an array with a single
        index of comma-separated targets.
      name: scanTargets
    description: Launches a scan with existing or custom targets. You can specify
      custom targets in the command arguments.
    name: tenable-io-launch-scan
    outputs:
    - contextPath: TenableIO.Scan.Id
      description: The unique ID of the scan.
      type: number
    - contextPath: TenableIO.Scan.Targets
      description: The targets to scan.
      type: string
    - contextPath: TenableIO.Scan.Status
      description: The status of the scan (completed, aborted, imported, pending,
        running, resuming, canceling, cancelled, pausing, paused, stopping, stopped).
      type: string
  - arguments:
    - default: true
      description: The ID of the scan to retrieve.
      name: scanId
      required: true
    - auto: PREDEFINED
      defaultValue: "no"
      description: 'If true, the report will contain remediation and host information
        for the specified scan. Otherwise, the report will only contain vulnerabilities.
        Possible values: "yes" and "no".'
      name: detailed
      predefined:
      - "yes"
      - "no"
    - auto: PREDEFINED
      defaultValue: "no"
      description: 'Whether to return the basic details of the specified scan. Possible
        values: "yes" and "no".'
      name: info
      predefined:
      - "yes"
      - "no"
    description: Retrieves a scan report for the specified scan.
    name: tenable-io-get-scan-report
    outputs:
    - contextPath: TenableIO.Scan.Id
      description: The unique ID of the scan.
      type: number
    - contextPath: TenableIO.Scan.Name
      description: The name of the scan.
      type: string
    - contextPath: TenableIO.Scan.Targets
      description: The targets to scan.
      type: string
    - contextPath: TenableIO.Scan.Status
      description: The status of the scan ("completed", "aborted", "imported", "pending",
        "running", "resuming", "canceling", "cancelled", "pausing", "paused", "stopping",
        "stopped").
      type: string
    - contextPath: TenableIO.Scan.StartTime
      description: The scheduled start time for the scan.
      type: string
    - contextPath: TenableIO.Scan.EndTime
      description: The scheduled end time for the scan.
      type: string
    - contextPath: TenableIO.Scan.Scanner
      description: The scanner assigned for the scan.
      type: string
    - contextPath: TenableIO.Scan.Policy
      description: The policy assigned to the scan.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Id
      description: The unique ID of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Name
      description: The name of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Severity
      description: The severity level of the vulnerability.
      type: number
    - contextPath: TenableIO.Vulnerabilities.Description
      description: The description of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Synopsis
      description: A brief summary of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Solution
      description: Information on how to fix the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.FirstSeen
      description: When the vulnerability was first seen.
      type: date
    - contextPath: TenableIO.Vulnerabilities.LastSeen
      description: When the vulnerability was last seen.
      type: date
    - contextPath: TenableIO.Vulnerabilities.VulnerabilityOccurences
      description: A count of the vulnerability occurrences.
      type: number
    - contextPath: TenableIO.Assets.Hostname
      description: The name of the host.
      type: string
    - contextPath: TenableIO.Assets.Score
      description: The overall score for the host.
      type: number
    - contextPath: TenableIO.Assets.Critical
      description: The percentage of critical findings on the host.
      type: number
    - contextPath: TenableIO.Assets.High
      description: The number of high findings on the host.
      type: number
    - contextPath: TenableIO.Assets.Medium
      description: The number of medium findings on the host.
      type: number
    - contextPath: TenableIO.Assets.Low
      description: The number of low findings on the host.
      type: number
    - contextPath: TenableIO.Remediations.Id
      description: The unique ID of the remediation.
      type: string
    - contextPath: TenableIO.Remediations.Description
      description: Specific information related to the vulnerability and steps to
        remediate.
      type: string
    - contextPath: TenableIO.Remediations.AffectedHosts
      description: The number of hosts affected.
      type: number
    - contextPath: TenableIO.Remediations.AssociatedVulnerabilities
      description: The number of vulnerabilities associated with the remedy.
      type: number
  - arguments:
    - default: true
      description: The unique ID of the vulnerability.
      name: vulnerabilityId
      required: true
    description: Retrieves details for the specified vulnerability.
    name: tenable-io-get-vulnerability-details
    outputs:
    - contextPath: TenableIO.Vulnerabilities.Name
      description: The name of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Severity
      description: Integer [0-4] indicating how severe the vulnerability is, where
        0 is info only.
      type: number
    - contextPath: TenableIO.Vulnerabilities.Type
      description: The type of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Family
      description: Object containing plugin information such as family, type, and
        publication and modification dates.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Description
      description: The description of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Synopsis
      description: A brief summary of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Solution
      description: Information on how to fix the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.FirstSeen
      description: When the vulnerability was first seen.
      type: date
    - contextPath: TenableIO.Vulnerabilities.LastSeen
      description: When the vulnerability was last seen.
      type: date
    - contextPath: TenableIO.Vulnerabilities.PublicationDate
      description: The publication date of the vulnerability.
      type: date
    - contextPath: TenableIO.Vulnerabilities.ModificationDate
      description: The last modification date for the vulnerability in Unix time.
      type: date
    - contextPath: TenableIO.Vulnerabilities.VulnerabilityOccurences
      description: A count of the vulnerability occurrences.
      type: number
    - contextPath: TenableIO.Vulnerabilities.CvssVector
      description: The Common Vulnerability Scoring System vector.
      type: string
    - contextPath: TenableIO.Vulnerabilities.CvssBaseScore
      description: The Common Vulnerability Scoring System allotted base score.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Cvss3Vector
      description: The Common Vulnerability Scoring System version 3 vector.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Cvss3BaseScore
      description: The Common Vulnerability Scoring System version 3 allotted base
        score.
      type: string
  - arguments:
    - description: Hostname of the asset.
      name: hostname
    - description: IP of the asset.
      name: ip
    - description: The number of days of data prior to and including today that should
        be returned.
      name: dateRange
    description: Gets a list of up to 5000 of the vulnerabilities recorded for a specified
      asset.
    name: tenable-io-get-vulnerabilities-by-asset
    outputs:
    - contextPath: TenableIO.Assets.Hostname
      description: Hostname of the asset.
      type: number
    - contextPath: TenableIO.Assets.Vulnerabilities
      description: A list of all the vulnerability IDs associated with the asset.
      type: number
    - contextPath: TenableIO.Vulnerabilities.Id
      description: The vulnerability unique ID.
      type: number
    - contextPath: TenableIO.Vulnerabilities.Name
      description: The name of the vulnerability.
      type: string
    - contextPath: TenableIO.Vulnerabilities.Severity
      description: Integer [0-4] indicating how severe the vulnerability is, where
        0 is info only.
      type: number
    - contextPath: TenableIO.Vulnerabilities.Family
      description: The vulnerability family.
      type: string
    - contextPath: TenableIO.Vulnerabilities.VulnerabilityOccurences
      description: The number of times the vulnerability was found.
      type: number
    - contextPath: TenableIO.Vulnerabilities.VulnerabilityState
      description: The current state of the reported vulnerability ("Active", "Fixed",
        "New", etc.).
      type: string
  - arguments:
    - default: true
      description: The unique ID of the scan.
      name: scanId
      required: true
    description: 'Checks the status of a specific scan using the scan ID. Possible
      values: "Running", "Completed", and "Empty" (Ready to run).'
    name: tenable-io-get-scan-status
    outputs:
    - contextPath: TenableIO.Scan.Id
      description: The unique ID of the scan specified.
      type: string
    - contextPath: TenableIO.Scan.Status
      description: The status of the scan specified.
      type: string
  - arguments:
    - description: Comma-separated list of scan IDs.
      isArray: true
      name: scanId
      required: true
    description: Resumes all scans inputted as an array. Will resume scans whose status
      is 'Paused'.
    name: tenable-io-resume-scan
    outputs:
    - contextPath: TenableIO.Scan.Id
      description: The unique ID of the scan.
      type: String
    - contextPath: TenableIO.Scan.Status
      description: The status of the scan (completed, aborted, imported, pending,
        running, resuming, canceling, cancelled, pausing, paused, stopping, stopped).
      type: String
  - arguments:
    - description: Comma-separated list of scan IDs.
      isArray: true
      name: scanId
      required: true
    description: Pauses all scans inputted as an array. Will pause scans whose status
      is 'Running'.
    name: tenable-io-pause-scan
    outputs:
    - contextPath: TenableIO.Scan.Id
      description: The unique id of the scan.
      type: String
    - contextPath: TenableIO.Scan.Status
      description: The status of the scan (completed, aborted, imported, pending,
        running, resuming, canceling, cancelled, pausing, paused, stopping, stopped).
      type: String
  - arguments: []
    description: 'Retrieves scanners from Tenable.io cloud '
    name: tenable-io-fetch-scanners
    outputs:
    - contextPath: Tenable.Scanners
      description: List of scanners fetched
  - arguments: []
    description: 'Retrieves scan profiles from Tenable.io cloud '
    name: tenable-io-fetch-profiles
    outputs:
    - contextPath: Tenable.Profiles
      description: List of profiles fetched
  - arguments:
    - description: Profile/Template Id fetched from the incident
      name: profile_Id
    - default: true
      defaultValue: tenable
      description: Type of scan
      name: scan_name
      required: true
    - description: Scanner Id fetched from incident
      name: scanner_Id
      required: true
    - description: Ip address of the targeted device
      name: IP
      required: true
    - description: Job ID for the triggered scan fetched from incident
      name: job_id
      required: true
    description: Initiate a Vulnerability Scan on a device from Pan IoT UI.
    name: tenable-io-initiate-scan
    outputs:
    - contextPath: Tenable.scanUUID
      description: Scan UUID
    - contextPath: Tenable.scanId
      description: Scan ID required to launch the scan
  - arguments:
    - description: IP of the device to fetch the corresponding asset id
      name: IP
      required: true
    description: Command to fetch asset ID for the device from the device IP
    name: tenable-io-fetch-assetID
    outputs:
    - contextPath: Tenable.assetID
      description: Asset Id for the given device IP
  - arguments:
    - description: Scan UUID of the device
      name: scanUUID
      required: true
    - description: Asset ID of the device
      name: assetID
      required: true
    - auto: PREDEFINED
      description: File format to generate the report in - "CSV or PDF"
      name: format
      predefined:
      - csv
      - pdf
      required: true
    description: Generate scan reports in CSV/PDF formats
    name: tenable-io-generate-report
    outputs:
    - contextPath: Tenable.reportID
      description: Report Id required to get the report downloaded
  - arguments:
    - description: 'UUID of the scan '
      name: scanUUID
      required: true
    - description: Report Id required to get the report downloaded
      name: reportID
      required: true
    - description: format of the report
      name: format
      required: true
    description: Download the generated report
    name: tenable-io-download-report
    outputs:
    - contextPath: Tenable.downloadedreport
      description: Downloaded report in the specified format
  - arguments:
    - description: UUID of the scan
      name: scan_uuid
      required: true
    - description: Report Id of the file to be downloaded
      name: report_id
      required: true
    description: To check the status of the report , if 'ready' to get downloaded
    name: tenable-io-check-report-status
    outputs:
    - contextPath: Tenable.report.status
      description: Status of the report , if 'ready' for download or not
  - arguments: []
    description: Returns the list of scan engines with more details
    name: tenable-io-fetch-scanners-details
    outputs:
    - contextPath: Tenable.ScannersDetails
      description: Tenable  detailed Scan Engines
      type: unknown
  runonce: false
  script: |
    register_module_line('PANW IoT 3rd Party Integration - Tenable.io', 'start', __line__())








    import os
    import sys
    import time
    import traceback
    from datetime import datetime


    import requests

    from requests.exceptions import HTTPError

    requests.packages.urllib3.disable_warnings()


    FIELD_NAMES_MAP = {
        'ScanType': 'Type',
        'ScanStart': 'StartTime',
        'ScanEnd': 'EndTime',
        'ScannerName': 'Scanner',
        'SeenLast': 'LastSeen',
        'SeenFirst': 'FirstSeen',
        'PluginId': 'Id',
        'Count': 'VulnerabilityOccurences'
    }

    REMEDIATIONS_NAMES_MAP = {
        'Value': 'Id',
        'Vulns': 'AssociatedVulnerabilities',
        'Hosts': 'AffectedHosts',
        'Remediation': 'Description'
    }

    ASSET_VULNS_NAMES_MAP = {
        'PluginId': 'Id',
        'PluginFamily': 'Family',
        'PluginName': 'Name',
        'Count': 'VulnerabilityOccurences'
    }

    GET_SCANS_HEADERS = [
        'FolderId',
        'Id',
        'Name',
        'Targets',
        'Status',
        'StartTime',
        'EndTime',
        'Enabled',
        'Type',
        'Owner',
        'Scanner',
        'Policy',
        'CreationDate',
        'LastModificationDate'
    ]

    LAUNCH_SCAN_HEADERS = [
        'Id',
        'Targets',
        'Status'
    ]

    SCAN_REPORT_INFO_HEADERS = [
        'Id',
        'Name',
        'Targets',
        'Status',
        'StartTime',
        'EndTime',
        'Scanner',
        'Policy'
    ]

    SCAN_REPORT_VULNERABILITIES_HEADERS = [
        'Id',
        'Name',
        'Severity',
        'Description',
        'Synopsis',
        'Solution',
        'FirstSeen',
        'LastSeen',
        'VulnerabilityOccurences'
    ]

    SCAN_REPORT_HOSTS_HEADERS = [
        'Hostname',
        'Score',
        'Severity',
        'Critical',
        'High',
        'Medium',
        'Low'
    ]

    SCAN_REPORT_REMEDIATIONS_HEADERS = [
        'Id',
        'Description',
        'AffectedHosts',
        'AssociatedVulnerabilities'
    ]

    VULNERABILITY_DETAILS_HEADERS = [
        'Name',
        'Severity',
        'Type',
        'Family',
        'Description',
        'Synopsis',
        'Solution',
        'FirstSeen',
        'LastSeen',
        'PublicationDate',
        'ModificationDate',
        'VulnerabilityOccurences',
        'CvssVector',
        'CvssBaseScore',
        'Cvss3Vector',
        'Cvss3BaseScore'
    ]

    ASSET_VULNS_HEADERS = [
        'Id',
        'Name',
        'Severity',
        'Family',
        'VulnerabilityOccurences',
        'VulnerabilityState'
    ]

    severity_to_text = [
        'None',
        'Low',
        'Medium',
        'High',
        'Critical']

    settings_url = demisto.params()['url']
    BASE_URL = settings_url if settings_url.endswith('/') else settings_url + '/'
    ACCESS_KEY = demisto.params()['access-key']
    SECRET_KEY = demisto.params()['secret-key']
    AUTH_HEADERS = {'X-ApiKeys': 'accessKey={}; secretKey={}'.format(ACCESS_KEY, SECRET_KEY)}
    NEW_HEADERS = {
        'X-ApiKeys': 'accessKey={}; secretKey={}'.format(ACCESS_KEY, SECRET_KEY),
        'accept': "application/json",
        'content-type': "application/json"
    }
    USE_SSL = not demisto.params()['unsecure']

    if not demisto.params()['proxy']:
        del os.environ['HTTP_PROXY']
        del os.environ['HTTPS_PROXY']
        del os.environ['http_proxy']
        del os.environ['https_proxy']


    ''' WRAPPER CLASS '''


    class RestApiCall(object):
        '''
            Wrapper class to make GET or POST api calls
        '''

        def __init__(self, verify=None, proxies=None, timeout=30):
            self.verify = verify
            self.proxies = proxies
            self.timeout = timeout

        def post(self, url, headers={}, data=None, auth=None):
            '''
                Wrapper for POST method
            '''
            return requests.post(url, headers=headers, data=data, auth=auth, verify=self.verify, proxies=self.proxies, timeout=self.timeout)

        def get(self, url, headers={}):
            '''
                Wrapper for GET method
            '''
            return requests.get(url, headers=headers, verify=self.verify, proxies=self.proxies, timeout=self.timeout)


    def flatten(d):
        r = {}  # type: ignore
        for k, v in d.iteritems():
            if isinstance(v, dict):
                r.update(flatten(v))
        d.update(r)
        return d


    def filter_dict_null(d):
        if isinstance(d, dict):
            return dict((k, v) for k, v in d.items() if v is not None)
        return d


    def filter_dict_keys(d, keys):
        if isinstance(d, list):
            return map(lambda x: filter_dict_keys(x, keys), d)
        if isinstance(d, dict):
            return {k: v for k, v in d.iteritems() if k in keys}
        return d


    def convert_severity_values(d):
        if isinstance(d, list):
            return map(convert_severity_values, d)
        if isinstance(d, dict):
            return {k: (severity_to_text[v] if k == 'Severity' else v) for k, v in d.iteritems()}
        return d


    def convert_dict_context_dates(d):
        def convert_epoch_to_date(k, v):
            if any(s in k.lower() for s in ('date', 'time')):
                try:
                    return datetime.utcfromtimestamp(int(v)).strftime('%Y-%m-%dT%H:%M:%SZ')
                except Exception:
                    pass
            return v

        if isinstance(d, list):
            return map(convert_dict_context_dates, d)
        if isinstance(d, dict):
            return {k: convert_dict_context_dates(convert_epoch_to_date(k, v)) for k, v in d.iteritems()}
        return d


    def convert_dict_readable_dates(d):
        def convert_epoch_to_date(k, v):
            return formatEpochDate(v) if isinstance(v, int) and any(s in k.lower() for s in ('date', 'time')) else v

        if isinstance(d, list):
            return map(convert_dict_readable_dates, d)
        if isinstance(d, dict):
            return {k: convert_dict_readable_dates(convert_epoch_to_date(k, v)) for k, v in d.iteritems()}
        return d


    def get_entry_for_object(title, context_key, obj, headers=None, remove_null=False):
        def intersection(lst1, lst2):
            return [value for value in lst1 if value in lst2]

        if len(obj) == 0:
            return "There is no output result"
        filtered_obj = filter_dict_null(obj)
        if isinstance(filtered_obj, list):
            filtered_obj = map(filter_dict_null, filtered_obj)
        if headers and isinstance(filtered_obj, dict):
            headers = intersection(headers, filtered_obj.keys())

        hr_obj = convert_dict_readable_dates(filtered_obj)
        context_obj = convert_dict_context_dates(filter_dict_keys(filtered_obj, headers) if headers else filtered_obj)

        return {
            'Type': entryTypes['note'],
            'Contents': obj,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': tableToMarkdown(title, hr_obj, headers, removeNull=remove_null),
            'EntryContext': {
                context_key: context_obj
            }
        }


    def replace_keys(src, trans_map=FIELD_NAMES_MAP, camelize=True):

        def snake_to_camel(snake_str):
            components = snake_str.split('_')
            return ''.join(map(lambda x: x.decode('utf-8').title(), components))

        def replace(key, trans_map):
            if key in trans_map:
                return trans_map[key]
            return key

        if isinstance(src, list):
            return map(lambda x: replace_keys(x, trans_map, camelize), src)
        if camelize:
            src = {snake_to_camel(k): v for k, v in src.iteritems()}
        if trans_map:
            src = {replace(k, trans_map): v for k, v in src.iteritems()}
        return src


    def date_range_to_param(date_range):
        params = {}
        if date_range:
            try:
                date_range = int(date_range)
                params['date_range'] = date_range
            except ValueError:
                return_error("Invalid date range: {}".format(date_range))
        return params


    def get_scan_error_message(response, scan_id):
        code = response.status_code
        message = "Error processing request"
        if scan_id:
            message += " for scan with id {}".format(scan_id)
        message += ". Got response status code: {}".format(code)
        if code == 401:
            message += " - Scan is disabled."
        elif code == 403:
            message += " - {}".format(response.json()['error'])
        elif code == 404:
            message += " - Scan does not exist."
        elif code == 409:
            message += " - Scan cannot be launched in its current status."
        return message


    # Request/Response methods
    # kwargs: request parameters
    def send_scan_request(scan_id="", endpoint="", method='GET', ignore_license_error=False, **kwargs):
        if endpoint:
            endpoint = '/' + endpoint
        full_url = "{0}scans/{1!s}{2}".format(BASE_URL, scan_id, endpoint)
        try:
            res = requests.request(method, full_url, headers=AUTH_HEADERS, verify=USE_SSL, params=kwargs)
            res.raise_for_status()
            return res.json()
        except HTTPError:
            if ignore_license_error and res.status_code in (403, 500):
                return
            err_msg = get_scan_error_message(res, scan_id)
            if demisto.command() != 'test-module':
                return_error(err_msg)
            else:
                demisto.results(err_msg)
            demisto.error(traceback.format_exc())
            sys.exit(0)
        except ValueError:
            demisto.results("No JSON returned by Tenable server.")
            demisto.error(traceback.format_exc())
            sys.exit(0)


    def get_scan_info(scans_result_elem):
        response = send_scan_request(scans_result_elem['id'], ignore_license_error=True)
        if response:
            response['info'].update(scans_result_elem)
            return response['info']


    def send_vuln_details_request(plugin_id, date_range=None):
        full_url = "{}{}{}/{}".format(BASE_URL, "workbenches/vulnerabilities/", plugin_id, "info")
        res = requests.get(full_url, headers=AUTH_HEADERS, verify=USE_SSL, params=date_range_to_param(date_range))
        return res.json()


    def get_vuln_info(vulns):
        vulns_info = {v['plugin_id']: v for v in vulns}
        infos = []
        errors = []
        for pid, info in vulns_info.iteritems():
            vuln_details = send_vuln_details_request(pid)
            if u'error' in vuln_details:
                errors.append(info)
            else:
                info.update(flatten(vuln_details['info']))
                infos.append(info)
        return infos, errors


    def send_assets_request(params):
        full_url = "{}{}".format(BASE_URL, "workbenches/assets")
        res = requests.request("GET", full_url, headers=AUTH_HEADERS, params=params, verify=USE_SSL)
        return res.json()


    def get_asset_id(params):
        assets = send_assets_request(params)
        if 'error' in assets:
            return_error(assets['error'])
        if assets.get('assets'):
            return assets['assets'][0]['id']
        return None


    def send_asset_vuln_request(asset_id, date_range):
        full_url = "{}workbenches/assets/{}/vulnerabilities/".format(BASE_URL, asset_id)
        res = requests.get(full_url, headers=AUTH_HEADERS, verify=USE_SSL, params=date_range_to_param(date_range))
        res.raise_for_status()
        return res.json()


    def test_module():
        send_scan_request()
        return 'ok'


    def get_scans_command():
        folder_id, last_modification_date, last_modification_timestamp = demisto.getArg(
            'folderId'), demisto.getArg('lastModificationDate'), demisto.getArg('lastModificationTimestamp')
        # validation for different formats of time from user, throw error when both specified.
        if last_modification_date and last_modification_timestamp:
            return_error("Please provide either one of the arguments: lastModificationDate Or lastModificationTimestamp")

        if last_modification_date:
            last_modification_date = int(time.mktime(datetime.strptime(last_modification_date[0:len('YYYY-MM-DD')],
                                                                       "%Y-%m-%d").timetuple()))
        elif last_modification_timestamp:
            last_modification_date = int(time.mktime(datetime.strptime(last_modification_timestamp[0:len('YYYY-MM-DD hh:mm:ss')],
                                                                       "%Y-%m-%d %H:%M:%S").timetuple()))

        response = send_scan_request(folder_id=folder_id, last_modification_date=last_modification_date)
        scan_entries = map(get_scan_info, response['scans'])
        valid_scans = filter(lambda x: x is not None, scan_entries)
        invalid_scans = [k for k, v in zip(response['scans'], scan_entries) if v is None]
        res = [get_entry_for_object('Tenable.io - List of Scans', 'TenableIO.Scan(val.Id && val.Id === obj.Id)',
                                    replace_keys(valid_scans), GET_SCANS_HEADERS)]
        if invalid_scans:
            res.append(get_entry_for_object('Inactive Web Applications Scans - Renew WAS license to use these scans',
                                            'TenableIO.Scan(val.Id && val.Id === obj.Id)', replace_keys(invalid_scans),
                                            GET_SCANS_HEADERS, remove_null=True))
        return res


    def launch_scan_command():
        scan_id, targets = demisto.getArg('scanId'), demisto.getArg('scanTargets')
        scan_info = send_scan_request(scan_id)['info']
        if not targets:
            targets = scan_info.get('targets', '')
        res = send_scan_request(scan_id, 'launch', 'POST', alt_targets=targets)
        res.update({
            'id': scan_id,
            'targets': targets,
            'status': 'pending'
        })

        return get_entry_for_object('The requested scan was launched successfully',
                                    'TenableIO.Scan(val.Id && val.Id === obj.Id)', replace_keys(res), LAUNCH_SCAN_HEADERS)


    def get_report_command():
        scan_id, info, detailed = demisto.getArg('scanId'), demisto.getArg('info'), demisto.getArg('detailed')
        results = []
        scan_details = send_scan_request(scan_id)
        if info == 'yes':
            scan_details['info']['id'] = scan_id
            scan_details['info'] = replace_keys(scan_details['info'])
            results.append(
                get_entry_for_object('Scan basic info', 'TenableIO.Scan(val.Id && val.Id === obj.Id)', scan_details['info'],
                                     SCAN_REPORT_INFO_HEADERS))

        if 'vulnerabilities' not in scan_details:
            return "No vulnerabilities found."
        vuln_info, vulns_not_found = get_vuln_info(scan_details['vulnerabilities'])
        vuln_info = convert_severity_values(replace_keys(vuln_info))
        results.append(get_entry_for_object('Vulnerabilities', 'TenableIO.Vulnerabilities', vuln_info,
                                            SCAN_REPORT_VULNERABILITIES_HEADERS))
        if len(vulns_not_found) > 0:
            vulns_not_found = replace_keys(vulns_not_found)
            results.append(get_entry_for_object('Vulnerabilities - Missing From Workbench', 'TenableIO.Vulnerabilities',
                                                vulns_not_found, SCAN_REPORT_VULNERABILITIES_HEADERS, True))

        if detailed == 'yes':
            assets = replace_keys(scan_details['hosts'] + scan_details['comphosts'])
            results.append(get_entry_for_object('Assets', 'TenableIO.Assets', assets, SCAN_REPORT_HOSTS_HEADERS))
            if 'remediations' in scan_details and 'remediations' in scan_details['remediations'] and len(
                    scan_details['remediations']['remediations']) > 0:
                remediations = replace_keys(scan_details['remediations']['remediations'], REMEDIATIONS_NAMES_MAP)
                results.append(get_entry_for_object('Remediations', 'TenableIO.Remediations', remediations,
                                                    SCAN_REPORT_REMEDIATIONS_HEADERS))
        return results


    def get_vulnerability_details_command():
        plugin_id, date_range = demisto.getArg('vulnerabilityId'), demisto.getArg('dateRange')
        info = send_vuln_details_request(plugin_id, date_range)
        if 'error' in info:
            return_error(info['error'])
        return get_entry_for_object('Vulnerability details - {}'.format(plugin_id), 'TenableIO.Vulnerabilities',
                                    convert_severity_values(replace_keys(flatten(info['info']))),
                                    VULNERABILITY_DETAILS_HEADERS)


    def args_to_request_params(hostname, ip, date_range):
        if not hostname and not ip:
            return_error("Please provide one of the following arguments: hostname, ip")

        indicator = hostname if hostname else ip

        params = {
            "filter.0.filter": "host.target",
            "filter.0.quality": "eq",
            "filter.0.value": indicator
        }

        if date_range:
            if not date_range.isdigit():
                return_error("Invalid date range: {}".format(date_range))
            else:
                params["date_range"] = date_range

        return params, indicator


    def get_vulnerabilities_by_asset_command():
        hostname, ip, date_range = demisto.getArg('hostname'), demisto.getArg('ip'), demisto.getArg('dateRange')
        params, indicator = args_to_request_params(hostname, ip, date_range)

        asset_id = get_asset_id(params)
        if not asset_id:
            return 'No Vulnerabilities for asset {}'.format(indicator)

        info = send_asset_vuln_request(asset_id, date_range)
        if 'error' in info:
            return_error(info['error'])

        vulns = convert_severity_values(replace_keys(info['vulnerabilities'], ASSET_VULNS_NAMES_MAP))
        if vulns:
            entry = get_entry_for_object('Vulnerabilities for asset {}'.format(indicator), 'TenableIO.Vulnerabilities',
                                         vulns, ASSET_VULNS_HEADERS)
            entry['EntryContext']['TenableIO.Assets(val.Hostname === obj.Hostname)'] = {
                'Vulnerabilities': map(lambda x: x['plugin_id'], info['vulnerabilities']),
                'Hostname': indicator
            }
            return entry


    def get_scan_status_command():
        scan_id = demisto.getArg('scanId')
        scan_details = send_scan_request(scan_id)
        scan_status = {
            'Id': scan_id,
            'Status': scan_details['info']['status']
        }
        return get_entry_for_object('Scan status for {}'.format(scan_id), 'TenableIO.Scan(val.Id && val.Id === obj.Id)', scan_status)


    def pause_scan_command():
        scan_ids = str(demisto.getArg('scanId')).split(",")

        results = []

        for scan_id in scan_ids:
            scan_id = scan_id.strip()

            scan_details = send_scan_request(scan_id)
            scan_status = {
                'Id': scan_id,
                'Status': scan_details['info']['status']
            }

            if scan_status["Status"].lower() == "running":
                send_scan_request(scan_id, "pause", "POST")
                resumed_scan = {
                    "Id": scan_id,
                    "Status": "Pausing"
                }
                results.append(get_entry_for_object("The requested scan was paused successfully",
                                                    'TenableIO.Scan(val.Id && val.Id === obj.Id)',
                                                    replace_keys(resumed_scan), ["Id", "Status"]))

            else:
                results.append(
                    "Command 'tenable-io-pause-scan' cannot be called while scan status is {} for scanID"
                    " {}".format(scan_status["Status"], scan_id))

        return results


    def resume_scan_command():
        scan_ids = str(demisto.getArg('scanId')).split(",")

        results = []

        for scan_id in scan_ids:
            scan_id = scan_id.strip()
            scan_details = send_scan_request(scan_id)
            scan_status = {
                'Id': scan_id,
                'Status': scan_details['info']['status']
            }

            if scan_status["Status"].lower() == "paused":
                send_scan_request(scan_id, "resume", "POST")
                resumed_scan = {
                    "Id": scan_id,
                    "Status": "Resuming"
                }
                results.append(get_entry_for_object("The requested scan was resumed successfully",
                                                    'TenableIO.Scan(val.Id && val.Id === obj.Id)',
                                                    replace_keys(resumed_scan), ["Id", "Status"]))

            else:
                results.append(
                    "Command 'tenable-io-resume-scan' cannot be called while scan status is {} for scanID "
                    "{}".format(scan_status["Status"], scan_id))

        return results


    def fetch_profiles_command():
        op_data = {}

        profile_list = []
        full_url = "{}editor/scan/templates".format(BASE_URL)

        try:
            rest_object = RestApiCall()
            res = rest_object.get(full_url, AUTH_HEADERS)
            if res.status_code == 200:
                resp_json = None
                try:
                    resp_json = res.json()
                except ValueError:
                    raise Exception('No JSON response from Tenable server. Please check your URL.')
                profiles = resp_json["templates"]

                for profile in profiles:
                    profile_map = {}
                    profile_map['profileName'] = profile.get('title')
                    profile_map['profileId'] = profile.get('uuid')
                    profile_list.append(profile_map)

        except Exception as exception:
            return_error("No Profiles were fetched: {}".format(exception))

        op_data['Total Profiles fetched'] = len(profile_list)

        results = CommandResults(
            readable_output=tableToMarkdown("Summary:", op_data, removeNull=True),
            outputs_prefix='Tenable.Profiles',
            outputs=profile_list
        )

        return_results(results)


    def fetch_scanners_command():
        op_data = {}

        scanner_list = []

        full_url = "{}scanners/".format(BASE_URL)
        return_outputs(BASE_URL)
        try:
            rest_object = RestApiCall()
            res = rest_object.get(full_url, AUTH_HEADERS)
            if res.status_code == 200:
                resp_json = None
                try:
                    resp_json = res.json()
                except ValueError:
                    raise Exception('No JSON response from Tenable server. Please check your URL.')
                scanners = resp_json["scanners"]

                for scanner in scanners:
                    scanner_map = {}
                    scanner_map['scannerName'] = scanner.get('name')
                    scanner_map['scannerId'] = scanner.get('id')
                    scanner_list.append(scanner_map)

        except Exception as exception:
            return_error("No Scanners were fetched: {}".format(exception))

        op_data['Total Scanners fetched'] = len(scanner_list)

        results = CommandResults(
            readable_output=tableToMarkdown("Summary:", op_data, removeNull=True),
            outputs_prefix='Tenable.Scanners',
            outputs=scanner_list
        )

        return_results(results)

    def fetch_scanners_details_command():
        op_data = {}

        scanner_list = []

        full_url = "{}scanners/".format(BASE_URL)
        # demisto.results(full_url)
        try:
            rest_object = RestApiCall()
            res = rest_object.get(full_url, AUTH_HEADERS)
            if res.status_code == 200:
                resp_json = None
                try:
                    resp_json = res.json()
                except ValueError:
                    raise Exception('No JSON response from Tenable server. Please check your URL.')
                scanners = resp_json["scanners"]

                for scanner in scanners:
                    scanner_map = {}
                    scanner_map['scannerName'] = scanner.get('name')
                    scanner_map['scannerId'] = scanner.get('id')
                    scanner_map['scannerAddress'] = scanner.get('ip_addresses')
                    scanner_list.append(scanner_map)

        except Exception as exception:
            return_error("No Scanners were fetched: {}".format(exception))

        op_data['Total Scanners fetched'] = len(scanner_list)

        command_results = CommandResults(
            outputs_prefix='Tenable.Scanners',
            outputs=scanner_list
        )
        return_results(command_results)

    def initiate_scan_command():
        template_ID = demisto.args().get('profile_Id')
        scan_name = demisto.args().get('scan_name')
        scanner_ID = demisto.args().get('scanner_Id')
        device_ip = demisto.args().get('IP')

        op_data = {}
        scan_id = ''
        scan_uuid = ''
        full_url = "{}scans/".format(BASE_URL)
        data = {
            "uuid": template_ID,
            "settings": {
                "name": scan_name,
                "enabled": 'true',
                "scanner_id": scanner_ID,
                "text_targets": device_ip
            }
        }

        data = json.dumps(data)

        try:
            rest_object = RestApiCall()
            res = rest_object.post(full_url, headers=NEW_HEADERS, data=data)
            if res.status_code == 200:
                resp_json = res.json()
                scan_id = resp_json['scan']['id']
                scan_uuid = resp_json['scan']['uuid']
            else:
                raise Exception(res.json()['error'])

        except Exception as exception:
            return_error("Error in initiating the scan: {}".format(exception))

        ids = [
            {
                'scanId': scan_id,
                'scanUUID': scan_uuid
            }
        ]
        context = {
            'Tenable(val.ID && val.ID === obj.ID)': ids
        }
        title = 'Returned ids Summary'
        human_readable = tableToMarkdown(title, ids, removeNull=True)

        return_outputs(readable_output=human_readable, outputs=context)


    def fetch_assetID_from_IP_command():

        IP = demisto.args().get('IP')
        op_data = {}
        fetched_assets = []
        full_url = "{}assets/".format(BASE_URL)
        asset_id = ''

        try:
            rest_object = RestApiCall()
            res = rest_object.get(full_url, AUTH_HEADERS)
            if res.status_code == 200:
                resp_json = res.json()
                fetched_assets = resp_json['assets']

            for asset in fetched_assets:
                if asset.get('last_scan_target') == IP:
                    asset_id = asset.get('id')

        except Exception as exception:
            return_error("No AssetId was fetched: {}".format(exception))

        op_data['Asset ID'] = asset_id

        results = CommandResults(
            readable_output=tableToMarkdown("Summary:", op_data, removeNull=True),
            outputs_prefix='Tenable.assetID',
            outputs=asset_id
        )

        return_results(results)


    def generate_report_command():

        scan_uuid = demisto.args().get('scanUUID')
        asset_id = demisto.args().get('assetID')
        report_format = demisto.args().get('format')
        report_ID = ''
        op_data = {}
        full_url = "{}scans/{}/export".format(BASE_URL, scan_uuid)
        data = {
            "format": report_format,
            "chapters": "vuln_by_host",
            "asset_id": asset_id
        }

        data = json.dumps(data)

        try:
            rest_object = RestApiCall()
            res = rest_object.post(full_url, headers=NEW_HEADERS,  data=data)

            if res.status_code == 200:
                resp_json = res.json()
                report_ID = resp_json['file']

        except Exception as exception:
            return_error("Error in generating report: {}".format(exception))

        op_data['Report ID'] = report_ID

        results = CommandResults(
            readable_output=tableToMarkdown("Summary:", op_data, removeNull=True),
            outputs_prefix='Tenable.reportID',
            outputs=report_ID
        )

        return_results(results)


    def download_report_command():

        scan_uuid = demisto.args().get('scanUUID')
        report_id = demisto.args().get('reportID')
        report_format = demisto.args().get('format')
        downloaded_report = ''
        full_url = "{}scans/{}/export/{}/download".format(BASE_URL, scan_uuid, report_id)

        try:
            rest_object = RestApiCall()
            res = rest_object.get(full_url, AUTH_HEADERS)

            if res.status_code == 200:
                downloaded_report = res.content

            file_entry = fileResult(filename="tenable_" + report_id + "." + report_format, data=downloaded_report)
            # file_entry['Contents'] = res.content

        except Exception as exception:
            return_error("Error in downloading report: {}".format(exception))

        return_results(file_entry)


    def check_downloaded_report_status_command():

        scan_uuid = demisto.args().get('scan_uuid')
        report_id = demisto.args().get('report_id')
        full_url = "{}scans/{}/export/{}/status".format(BASE_URL, scan_uuid, report_id)
        status = ''
        op_data = {}

        try:
            rest_object = RestApiCall()
            res = rest_object.get(full_url, AUTH_HEADERS)
            if res.status_code == 200:
                resp_json = res.json()
                status = resp_json['status']

        except Exception as exception:
            return_error("Report status was not fetched: {}".format(exception))

        op_data['Scan Status'] = status

        results = CommandResults(
            readable_output=tableToMarkdown("Summary:", op_data, removeNull=True),
            outputs_prefix='Tenable.report.status',
            outputs=status
        )

        return_results(results)


    if demisto.command() == 'test-module':
        demisto.results(test_module())
    elif demisto.command() == 'tenable-io-list-scans':
        demisto.results(get_scans_command())
    elif demisto.command() == 'tenable-io-launch-scan':
        demisto.results(launch_scan_command())
    elif demisto.command() == 'tenable-io-get-scan-report':
        demisto.results(get_report_command())
    elif demisto.command() == 'tenable-io-get-vulnerability-details':
        demisto.results(get_vulnerability_details_command())
    elif demisto.command() == 'tenable-io-get-vulnerabilities-by-asset':
        demisto.results(get_vulnerabilities_by_asset_command())
    elif demisto.command() == 'tenable-io-get-scan-status':
        demisto.results(get_scan_status_command())
    elif demisto.command() == 'tenable-io-pause-scan':
        demisto.results(pause_scan_command())
    elif demisto.command() == 'tenable-io-resume-scan':
        demisto.results(resume_scan_command())
    elif demisto.command() == 'tenable-io-fetch-scanners':
        demisto.results(fetch_scanners_command())
    elif demisto.command() == 'tenable-io-fetch-scanners-details':
        fetch_scanners_details_command()
    elif demisto.command() == 'tenable-io-fetch-profiles':
        fetch_profiles_command()
    elif demisto.command() == 'tenable-io-initiate-scan':
        demisto.results(initiate_scan_command())
    elif demisto.command() == 'tenable-io-fetch-assetID':
        demisto.results(fetch_assetID_from_IP_command())
    elif demisto.command() == 'tenable-io-generate-report':
        demisto.results(generate_report_command())
    elif demisto.command() == 'tenable-io-download-report':
        demisto.results(download_report_command())
    elif demisto.command() == 'tenable-io-check-report-status':
        demisto.results(check_downloaded_report_status_command())





    register_module_line('PANW IoT 3rd Party Integration - Tenable.io', 'end', __line__())
  subtype: python3
  type: python
sourcemoduleid: Tenable.io
