category: Endpoint
commonfields:
  id: PANW IoT 3rd Party Integration - CrowdstrikeFalcon
  version: -1
configuration:
- defaultvalue: https://api.crowdstrike.com
  display: Server URL (e.g., https://api.crowdstrike.com)
  name: url
  required: true
  type: 0
- display: Client ID
  name: client_id
  required: true
  type: 0
- display: Secret
  name: secret
  required: true
  type: 4
- defaultvalue: 3 days
  display: First fetch timestamp (<number> <time unit>, e.g., 12 hours, 7 days)
  name: fetch_time
  required: false
  type: 0
- defaultvalue: "15"
  display: Max incidents per fetch
  name: incidents_per_fetch
  required: false
  type: 0
- display: Detections fetch query
  name: fetch_query
  required: false
  type: 0
- display: Incidents fetch query
  name: incidents_fetch_query
  required: false
  type: 0
- display: Fetch incidents
  name: isFetch
  required: false
  type: 8
- display: Incident type
  name: incidentType
  required: false
  type: 13
- display: Trust any certificate (not secure)
  name: insecure
  required: false
  type: 8
- display: Use system proxy settings
  name: proxy
  required: false
  type: 8
- additionalinfo: Choose what to fetch - incidents or detections or both
  defaultvalue: Detections
  display: Fetch types
  name: fetch_incidents_or_detections
  options:
  - Detections
  - Incidents
  required: false
  type: 16
- defaultvalue: "1"
  display: Incidents Fetch Interval
  name: incidentFetchInterval
  required: false
  type: 19
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: The CrowdStrike Falcon OAuth 2 API (formerly the Falcon Firehose API),
  enables fetching and resolving detections, searching devices, getting behaviors
  by ID, containing hosts, and lifting host containment. getting behaviors by ID,
  containing hosts, and lifting host containment.
detaileddescription: |-
  To get an The API client ID and secret please contact the crowdstrike support: support@crowdstrike.com

  ---
  [View Integration Documentation](https://xsoar.pan.dev/docs/reference/integrations/crowdstrike-falcon)
display: PANW IoT 3rd Party Integration - CrowdStrike Falcon
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAdISURBVHgB7VpdVttGFL4jkZw+Os9tQVlBnRXErCBmBZgVYEOSV8xbS2MwK8CsIM4KUFYQdwUobd7j15ZKk+/OjzSSZWzn5wST+c4Rtq9m7ty5/xpB5OHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eHh4eFx7yEpapHHvUJQJUjavKAVAKeIJP3SwmeDvhDMQ9LPTb7oO6KQQ+0rojWGqBIkbb3G36mgv/dum4iN7+NvH19dw8ZguScoSeAouCeOaqbmYxxeMKg8w9eWMw735QhyHBu5Ppq1ppj/GPOnZbp45NCu8RGZLT4C5XWFtytLD/MmC/aVEKXQxwaPuKJbEUREWVysnwOyyTHu83pTnS0tL7XPPehsBHl2NS3dFvQhBg16EV07DvOhD3k9b3VB70s2DWqGYCOidVsk60XlkMpKYLRAf7fA6+2YhualjHtFswaIIEcfxnpn5Do3dMz7v6nn/tqmXIasU/CzymXFaaMvkGXXzG3N2VcEVe3Sl4GdsGOcbSloZ7PGZScLerQiZgysFSJ2cLVZuVVjQakdZ1EeC4/K4BTy0nA4dqPTzIJxxDapiFFoWIOYDVuFxpqX6OkNKTR1NqCRI3bbrPXMkdx+bxW07JJmwHKo69yRb6gdLnPmyp6OBnZ4lkspd1LMl5ez+xOIuuv39euRdbQly9lGZJyNkWjeM87qyJOvU+ZSx5pTFoTY1pElr/h7YbTAVSqnm5H5McK4oZvuCsgJ6JxunnJ2yKk6YiK7CSh027k3KVKYeIb5HM0xKQOqNNZlJ3QWMYqTuwW/D3HN3iwN8mxt4dNmAfANeE078gz3IW/6hijccZQba/k2W9X9UQ0sHbwSfKzQW0gngyo9JzWDSk6JNN+vDqhpsrjBiJraUNYj5DU21C2Y5ixL9ajeuGqZM10XRd8QoKxgDOVFzsqXFV4xFV5vxok3VgZTQliWhPLMkHHNN0qUb2gh5F/F97SBNcc6GnPA+MGFSeMrGMdZAfs2PYGdP15QNqrgsfGce5Huc+w1izkpmtpclxwjJ9qjWamckm36vHlMy6FBRdMxNekmQWQkzspP3QmmNFhnsuNGlBud65kaGeP72zJNbW1Ii7FVfA0VX0RB10nBibkZlSNqJURU7H1sUv4qaNyytjW+vWYQzJkI5cguDHqkDSGemDrT0Ytlx7pOhmf2UYIjvK5ma7g1WqUVm0YnVKpNm0f28aTcjEiVGbTzyUpdDc61vJa3QjwnpRUc1RqlFD/R++CmjjNL0NX7zuX7rAjmjt/5sQKPlAPLZsS2k0FdTLis2auOS62BnUarY7tp49nG+zhtZb8ZI+/rtl2c6Q3M66JZYTYiBDvDlVnn2Fm5j7YACg6vqFBGoh8Ncj5jKm0wmZisEzt8aporDawr+TJrGIeQpjFUkdI0afmjvmayyEowfG3aj6C37gqzYYM8Yx3V6LVl91Psq4zgdsFUZ9ayNUg3VDZ92ZZfvnWMNK3vonOncdNTk+s96MNK1+wiLtJ5ziemYtNOvXQdhca0HKa6gbHNyVw5kroOdXkEfSpk3l/2UMjYwO6r8TllQiwzCFHMRti3D9r6ICNqm8OJyNBZ2Ulx2KC8LTIsJmU6PyJx5/nPuFgjMp1sxhE0NXPienlUw9Nw+Ro65tO02uw5411MXXlnx6cmg4RJnRzz9ufIoVB00SUZrHx5ljI6LY1xdNZylp7QLal+ns4WAot0bEeon4Xr6HWp2WNtYJqpkcn3uaEdujfyfUDF0HlThU/bSS9VYzzuOMqG3jwytOaclt7jO2CpJmsRTOPU14cVqttUJ0wrnth43HXo6N268nX4HkOfZW+e3YU6fNg9bB8cvOjQD4wN+sowablnovirpujDg5d8fFl6Bhycnsw/DxdhW0jJ580j+kHx1Q1ssegs+POYyobMxHt8jshjKXwzA38zCHF9enoysj+73W5jI3iIc1rqkP6viXGa/bs3HA5nssdh78U+5vftuMHpHzuYH4XhgwuS6j11As/sDQYn6oQNGQPP9TQS6t0zv6KkHtYe0hohoDVDIGTz4OBln6/n3ectNmSG97pp9t+TNJP81qsdBA/a1Xk8FsYdwkjnPE4EqTrHDoOHVzDuFPMfk8Q7ZEkX7DRmWiQEtZk36Jcw9BGtGdbOwHjghtLlU76yQERMy7KbcRBstMPQvvTWdBepwKtBQRNEYH84/HPy6tWrGIbkeh6lWXYOR0lSedPH74brIFJKdU8Kfu9Ma3eAs3YpWiK1ng5O8rdSKsUGD9/BEpeIzOMwELUH8QGJGuP8hDSeURgGpXtCiHvz/L52EVwFoq2Fj4aOvhs2TH2UBekY3tG0j01dld5/xxscHMhI/d8koXig/hEhTYMJ3ROsvYE5PbOREMUfdbNUvM+VIpsgHFuHhy/bg8EABpbngsQFmifJ6ZxrbZbJHdTwNtO4AUOd7bHhyeNugVP1PLrTNKmuu25sdZyHh4eHh4eHh4eHx4+KTzEFUWi48FQaAAAAAElFTkSuQmCC
name: PANW IoT 3rd Party Integration - CrowdstrikeFalcon
script:
  commands:
  - arguments:
    - description: The query by which to filter the device.
      name: filter
    - description: A comma-separated list of device IDs by which to limit the results.
      name: ids
    - auto: PREDEFINED
      description: 'The status of the device. Possible values are: "Normal", "containment_pending",
        "contained", and "lift_containment_pending".'
      name: status
      predefined:
      - normal
      - containment_pending
      - contained
      - lift_containment_pending
    - auto: PREDEFINED
      description: The host name of the device.
      name: hostname
      predefined:
      - ""
    - auto: PREDEFINED
      description: 'The platform name of the device. Possible values are: "Windows","Mac",
        and "Linux".'
      name: platform_name
      predefined:
      - Windows
      - Mac
      - Linux
    - description: The site name of the device.
      name: site_name
    description: Searches for a device that matches the query.
    name: cs-falcon-search-device
    outputs:
    - contextPath: CrowdStrike.Device.ID
      description: The ID of the device.
      type: String
    - contextPath: CrowdStrike.Device.LocalIP
      description: The local IP address of the device.
      type: String
    - contextPath: CrowdStrike.Device.ExternalIP
      description: The external IP address of the device.
      type: String
    - contextPath: CrowdStrike.Device.Hostname
      description: The host name of the device.
      type: String
    - contextPath: CrowdStrike.Device.OS
      description: The operating system of the device.
      type: String
    - contextPath: CrowdStrike.Device.MacAddress
      description: The MAC address of the device.
      type: String
    - contextPath: CrowdStrike.Device.FirstSeen
      description: The first time the device was seen.
      type: String
    - contextPath: CrowdStrike.Device.LastSeen
      description: The last time the device was seen.
      type: String
    - contextPath: CrowdStrike.Device.PolicyType
      description: The policy type of the device.
      type: String
    - contextPath: CrowdStrike.Device.Status
      description: The device status.
      type: String
    - contextPath: Endpoint.Hostname
      description: The endpoint's hostname.
      type: String
    - contextPath: Endpoint.OS
      description: The endpoint's operation system.
      type: String
    - contextPath: Endpoint.IPAddress
      description: The endpoint's IP address.
      type: String
    - contextPath: Endpoint.ID
      description: The endpoint's ID.
      type: String
    - contextPath: Endpoint.Status
      description: The endpoint's status.
      type: String
    - contextPath: Endpoint.IsIsolated
      description: The endpoint's isolation status.
      type: String
    - contextPath: Endpoint.MACAddress
      description: The endpoint's MAC address.
      type: String
    - contextPath: Endpoint.Vendor
      description: The integration name of the endpoint vendor.
      type: String
    - contextPath: Endpoint.OSVersion
      description: The endpoint's operation system version.
      type: String
  - arguments:
    - description: The ID of the behavior.
      name: behavior_id
      required: true
    description: Searches for and fetches the behavior that matches the query.
    name: cs-falcon-get-behavior
    outputs:
    - contextPath: CrowdStrike.Behavior.FileName
      description: The file name of the behavior.
      type: String
    - contextPath: CrowdStrike.Behavior.Scenario
      description: The scenario name of the behavior.
      type: String
    - contextPath: CrowdStrike.Behavior.MD5
      description: The MD5 hash of the IOC in the behavior.
      type: String
    - contextPath: CrowdStrike.Behavior.SHA256
      description: The SHA256 hash of the IOC in the behavior.
      type: String
    - contextPath: CrowdStrike.Behavior.IOCType
      description: The type of the indicator of compromise.
      type: String
    - contextPath: CrowdStrike.Behavior.IOCValue
      description: The value of the IOC.
      type: String
    - contextPath: CrowdStrike.Behavior.CommandLine
      description: The command line executed in the behavior.
      type: String
    - contextPath: CrowdStrike.Behavior.UserName
      description: The user name related to the behavior.
      type: String
    - contextPath: CrowdStrike.Behavior.SensorID
      description: The sensor ID related to the behavior.
      type: String
    - contextPath: CrowdStrike.Behavior.ParentProcessID
      description: The ID of the parent process.
      type: String
    - contextPath: CrowdStrike.Behavior.ProcessID
      description: The process ID of the behavior.
      type: String
    - contextPath: CrowdStrike.Behavior.ID
      description: The ID of the behavior.
      type: String
  - arguments:
    - description: The IDs of the detections to search. If provided, will override
        other arguments.
      isArray: true
      name: ids
    - description: |-
        Filter detections using a query in Falcon Query Language (FQL).
        e.g., filter="device.hostname:'CS-SE-TG-W7-01'"
        For a full list of valid filter options, see: https://falcon.crowdstrike.com/support/documentation/2/query-api-reference#detectionsearch
      name: filter
    description: Search for details of specific detections, either using a filter
      query, or by providing the IDs of the detections.
    name: cs-falcon-search-detection
    outputs:
    - contextPath: CrowdStrike.Detection.Behavior.FileName
      description: The file name of the behavior.
      type: String
    - contextPath: CrowdStrike.Detection.Behavior.Scenario
      description: The scenario name of the behavior.
      type: String
    - contextPath: CrowdStrike.Detection.Behavior.MD5
      description: The MD5 hash of the IOC of the behavior.
      type: String
    - contextPath: CrowdStrike.Detection.Behavior.SHA256
      description: The SHA256 hash of the IOC of the behavior.
      type: String
    - contextPath: CrowdStrike.Detection.Behavior.IOCType
      description: The type of the IOC.
      type: String
    - contextPath: CrowdStrike.Detection.Behavior.IOCValue
      description: The value of the IOC.
      type: String
    - contextPath: CrowdStrike.Detection.Behavior.CommandLine
      description: The command line executed in the behavior.
      type: String
    - contextPath: CrowdStrike.Detection.Behavior.UserName
      description: The user name related to the behavior.
      type: String
    - contextPath: CrowdStrike.Detection.Behavior.SensorID
      description: The sensor ID related to the behavior.
      type: String
    - contextPath: CrowdStrike.Detection.Behavior.ParentProcessID
      description: The ID of the parent process.
      type: String
    - contextPath: CrowdStrike.Detection.Behavior.ProcessID
      description: The process ID of the behavior.
      type: String
    - contextPath: CrowdStrike.Detection.Behavior.ID
      description: The ID of the behavior.
      type: String
    - contextPath: CrowdStrike.Detection.System
      description: The system name of the detection.
      type: String
    - contextPath: CrowdStrike.Detection.CustomerID
      description: The ID of the customer (CID).
      type: String
    - contextPath: CrowdStrike.Detection.MachineDomain
      description: The name of the domain of the detection machine.
      type: String
    - contextPath: CrowdStrike.Detection.ID
      description: The detection ID.
      type: String
    - contextPath: CrowdStrike.Detection.ProcessStartTime
      description: The start time of the process that generated the detection.
      type: Date
  - arguments:
    - description: A comma-separated list of one or more IDs to resolve.
      name: ids
      required: true
    - auto: PREDEFINED
      description: 'The status to which to transition a detection. Possible values
        are: "new", "in_progress", "true_positive", "false_positive", and "ignored".'
      name: status
      predefined:
      - new
      - in_progress
      - true_positive
      - false_positive
      - ignored
    - description: 'A user ID, for example: 1234567891234567891. username and assigned_to_uuid
        are mutually exclusive.'
      name: assigned_to_uuid
    - description: Optional comment to add to the detection. Comments are displayed
        with the detection in Falcon and are usually used to provide context or notes
        for other Falcon users.
      name: comment
    - auto: PREDEFINED
      description: If true, displays the detection in the UI.
      name: show_in_ui
      predefined:
      - "true"
      - "false"
    - description: Username to assign the detections to. (This is usually the userâ€™s
        email address, but may vary based on your configuration). username and assigned_to_uuid
        are mutually exclusive.
      name: username
    description: Resolves and updates a detection using the provided arguments. At
      least one optional argument must be passed, otherwise no change will take place.
    name: cs-falcon-resolve-detection
  - arguments:
    - description: The host agent ID (AID) of the host to contain. Get an agent ID
        from a detection.
      isArray: true
      name: ids
      required: true
    description: Contains containment for a specified host. When contained, a host
      can only communicate with the CrowdStrike cloud and any IPs specified in your
      containment policy.
    name: cs-falcon-contain-host
  - arguments:
    - description: The host agent ID (AID) of the host you want to contain. Get an
        agent ID from a detection
      isArray: true
      name: ids
      required: true
    description: Lifts containment on the host, which returns its network communications
      to normal.
    name: cs-falcon-lift-host-containment
  - arguments:
    - description: A comma-separated list of host agent IDs for which to run commands.
        (Can be retrieved by running the 'cs-falcon-search-device' command.)
      name: host_ids
      required: true
    - description: The type of command to run.
      name: command_type
      required: true
    - description: The full command to run.
      name: full_command
      required: true
    - auto: PREDEFINED
      defaultValue: read
      description: 'The scope for which to run the command. Possible values are: "read",
        "write", and "admin".'
      name: scope
      predefined:
      - read
      - write
      - admin
    - auto: PREDEFINED
      defaultValue: batch
      description: 'The target for which to run the command. Possible values are:
        "single" and "batch".'
      name: target
      predefined:
      - batch
      - single
    description: Sends commands to hosts.
    name: cs-falcon-run-command
    outputs:
    - contextPath: CrowdStrike.Command.HostID
      description: The ID of the host for which the command was running.
      type: String
    - contextPath: CrowdStrike.Command.SessionID
      description: The ID of the session of the host.
      type: string
    - contextPath: CrowdStrike.Command.Stdout
      description: The standard output of the command.
      type: String
    - contextPath: CrowdStrike.Command.Stderr
      description: The standard error of the command.
      type: String
    - contextPath: CrowdStrike.Command.BaseCommand
      description: The base command.
      type: String
    - contextPath: CrowdStrike.Command.FullCommand
      description: The full command.
      type: String
    - contextPath: CrowdStrike.Command.TaskID
      description: (For single host) The ID of the command request which has been
        accepted.
      type: string
    - contextPath: CrowdStrike.Command.Complete
      description: (For single host) True if the command completed.
      type: boolean
    - contextPath: CrowdStrike.Command.NextSequenceID
      description: (For single host) The next sequence ID.
      type: number
  - arguments:
    - description: The script name to upload.
      name: name
      required: true
    - auto: PREDEFINED
      defaultValue: private
      description: 'The permission type for the custom script. Possible values are:
        "private", which is used only by the user who uploaded it, "group", which
        is used by all RTR Admins, and "public", which is used by all active-responders
        and RTR admins.'
      name: permission_type
      predefined:
      - private
      - group
      - public
    - description: The content of the PowerShell script.
      name: content
      required: true
    description: Uploads a script to Falcon.
    name: cs-falcon-upload-script
  - arguments:
    - description: The file entry ID to upload.
      name: entry_id
      required: true
    description: Uploads a file to the CrowdStrike cloud. (Can be used for the RTR
      'put' command.)
    name: cs-falcon-upload-file
  - arguments:
    - description: The ID of the file to delete. (The ID of the file can be retrieved
        by running the 'cs-falcon-list-files' command).
      name: file_id
      required: true
    description: Deletes a file based on the provided ID. Can delete only one file
      at a time.
    name: cs-falcon-delete-file
  - arguments:
    - description: A comma-separated list of file IDs to get. (The list of file IDs
        can be retrieved by running the 'cs-falcon-list-files' command.)
      name: file_id
      required: true
    description: Returns files based on the provided IDs. These files are used for
      the RTR 'put' command.
    name: cs-falcon-get-file
    outputs:
    - contextPath: CrowdStrike.File.ID
      description: The ID of the file.
      type: String
    - contextPath: CrowdStrike.File.CreatedBy
      description: The email address of the user who created the file.
      type: String
    - contextPath: CrowdStrike.File.CreatedTime
      description: The date and time the file was created.
      type: Date
    - contextPath: CrowdStrike.File.Description
      description: The description of the file.
      type: String
    - contextPath: CrowdStrike.File.Type
      description: The type of the file. For example, script.
      type: String
    - contextPath: CrowdStrike.File.ModifiedBy
      description: The email address of the user who modified the file.
      type: String
    - contextPath: CrowdStrike.File.ModifiedTime
      description: The date and time the file was modified.
      type: Date
    - contextPath: CrowdStrike.File.Name
      description: The full name of the file.
      type: String
    - contextPath: CrowdStrike.File.Permission
      description: 'The permission type of the file. Possible values are: "private",
        which is used only by the user who uploaded it, "group", which is used by
        all RTR Admins, and "public", which is used by all active-responders and RTR
        admins'
      type: String
    - contextPath: CrowdStrike.File.SHA256
      description: The SHA-256 hash of the file.
      type: String
    - contextPath: File.Type
      description: The file type.
      type: String
    - contextPath: File.Name
      description: The full name of the file.
      type: String
    - contextPath: File.SHA256
      description: The SHA-256 hash of the file.
      type: String
    - contextPath: File.Size
      description: The size of the file in bytes.
      type: Number
  - arguments: []
    description: Returns a list of put-file IDs that are available for the user in
      the 'put' command.
    name: cs-falcon-list-files
    outputs:
    - contextPath: CrowdStrike.File.ID
      description: The ID of the file.
      type: String
    - contextPath: CrowdStrike.File.CreatedBy
      description: The email address of the user who created the file.
      type: String
    - contextPath: CrowdStrike.File.CreatedTime
      description: The date and time the file was created.
      type: Date
    - contextPath: CrowdStrike.File.Description
      description: The description of the file.
      type: String
    - contextPath: CrowdStrike.File.Type
      description: The type of the file. For example, script.
      type: String
    - contextPath: CrowdStrike.File.ModifiedBy
      description: The email address of the user who modified the file.
      type: String
    - contextPath: CrowdStrike.File.ModifiedTime
      description: The date and time the file was modified.
      type: Date
    - contextPath: CrowdStrike.File.Name
      description: The full name of the file.
      type: String
    - contextPath: CrowdStrike.File.Permission
      description: 'The permission type of the file. Possible values are: "private",
        which is used only by the user who uploaded it, "group", which is used by
        all RTR Admins, and "public", which is used by all active-responders and RTR
        admins.'
      type: String
    - contextPath: CrowdStrike.File.SHA256
      description: The SHA-256 hash of the file.
      type: String
    - contextPath: File.Type
      description: The file type.
      type: String
    - contextPath: File.Name
      description: The full name of the file.
      type: String
    - contextPath: File.SHA256
      description: The SHA-256 hash of the file.
      type: String
    - contextPath: File.Size
      description: The size of the file in bytes.
      type: Number
  - arguments:
    - description: A comma-separated list of script IDs to return. (The script IDs
        can be retrieved by running the 'cs-falcon-list-scripts' command.)
      name: script_id
      required: true
    description: Returns custom scripts based on the provided ID. Used for the RTR
      'runscript' command.
    name: cs-falcon-get-script
    outputs:
    - contextPath: CrowdStrike.Script.ID
      description: The ID of the script.
      type: String
    - contextPath: CrowdStrike.Script.CreatedBy
      description: The email address of the user who created the script.
      type: String
    - contextPath: CrowdStrike.Script.CreatedTime
      description: The date and time the script was created.
      type: Date
    - contextPath: CrowdStrike.Script.Description
      description: The description of the script.
      type: String
    - contextPath: CrowdStrike.Script.ModifiedBy
      description: The email address of the user who modified the script.
      type: String
    - contextPath: CrowdStrike.Script.ModifiedTime
      description: The date and time the script was modified.
      type: Date
    - contextPath: CrowdStrike.Script.Name
      description: The script name.
      type: String
    - contextPath: CrowdStrike.Script.Permission
      description: 'Permission type of the script. Possible values are: "private",
        which is used only by the user who uploaded it, "group", which is used by
        all RTR Admins, and "public", which is used by all active-responders and RTR
        admins.'
      type: String
    - contextPath: CrowdStrike.Script.SHA256
      description: The SHA-256 hash of the script file.
      type: String
    - contextPath: CrowdStrike.Script.RunAttemptCount
      description: The number of times the script attempted to run.
      type: Number
    - contextPath: CrowdStrike.Script.RunSuccessCount
      description: The number of times the script ran successfully.
      type: Number
    - contextPath: CrowdStrike.Script.Platform
      description: The list of operating system platforms on which the script can
        run. For example, Windows.
      type: String
    - contextPath: CrowdStrike.Script.WriteAccess
      description: Whether the user has write access to the script.
      type: Boolean
  - arguments:
    - description: Script ID to delete. (Script IDs can be retrieved by running the
        'cs-falcon-list-scripts' command.)
      name: script_id
      required: true
    description: Deletes a custom-script based on the provided ID. Can delete only
      one script at a time.
    name: cs-falcon-delete-script
  - arguments: []
    description: Returns a list of custom script IDs that are available for the user
      in the 'runscript' command.
    name: cs-falcon-list-scripts
    outputs:
    - contextPath: CrowdStrike.Script.ID
      description: The ID of the script.
      type: String
    - contextPath: CrowdStrike.Script.CreatedBy
      description: The email address of the user who created the script.
      type: String
    - contextPath: CrowdStrike.Script.CreatedTime
      description: The date and time the script was created.
      type: Date
    - contextPath: CrowdStrike.Script.Description
      description: The description of the script.
      type: String
    - contextPath: CrowdStrike.Script.ModifiedBy
      description: The email address of the user who modified the script.
      type: String
    - contextPath: CrowdStrike.Script.ModifiedTime
      description: The date and time the script was modified.
      type: Date
    - contextPath: CrowdStrike.Script.Name
      description: The script name.
      type: String
    - contextPath: CrowdStrike.Script.Permission
      description: 'Permission type of the script. Possible values are: "private",
        which is used only by the user who uploaded it, "group", which is used by
        all RTR Admins, and "public", which is used by all active-responders and RTR
        admins.'
      type: String
    - contextPath: CrowdStrike.Script.SHA256
      description: The SHA-256 hash of the script file.
      type: String
    - contextPath: CrowdStrike.Script.RunAttemptCount
      description: The number of times the script attempted to run.
      type: Number
    - contextPath: CrowdStrike.Script.RunSuccessCount
      description: The number of times the script ran successfully.
      type: Number
    - contextPath: CrowdStrike.Script.Platform
      description: The list of operating system platforms on which the script can
        run. For example, Windows.
      type: String
    - contextPath: CrowdStrike.Script.WriteAccess
      description: Whether the user has write access to the script.
      type: Boolean
  - arguments:
    - description: The name of the script to run.
      name: script_name
    - description: A comma-separated list of host agent IDs to run commands. (The
        list of host agent IDs can be retrieved by running the 'cs-falcon-search-device'
        command.)
      name: host_ids
      required: true
    - description: The PowerShell script code to run.
      name: raw
    - defaultValue: "30"
      description: Timeout for how long to wait for the request in seconds. Maximum
        is 600 (10 minutes).
      name: timeout
    description: Runs a script on the agent host.
    name: cs-falcon-run-script
    outputs:
    - contextPath: CrowdStrike.Command.HostID
      description: The ID of the host for which the command was running.
      type: String
    - contextPath: CrowdStrike.Command.SessionID
      description: The ID of the session of the host.
      type: String
    - contextPath: CrowdStrike.Command.Stdout
      description: The standard output of the command.
      type: String
    - contextPath: CrowdStrike.Command.Stderr
      description: The standard error of the command.
      type: String
    - contextPath: CrowdStrike.Command.BaseCommand
      description: The base command.
      type: String
    - contextPath: CrowdStrike.Command.FullCommand
      description: The full command.
      type: String
  - arguments:
    - description: List of host agent IDs on which to run the RTR command.
      isArray: true
      name: host_ids
      required: true
    - description: Full path to the file that will be retrieved from each host in
        the batch.
      name: file_path
      required: true
    - description: List of a subset of hosts on which to run the command.
      name: optional_hosts
    - description: 'The number of seconds to wait for the request before it times
        out. In ISO time format. For example: 2019-10-17T13:41:48.487520845Z.'
      name: timeout
    - description: 'The amount of time to wait for the request before it times out.
        In duration syntax. For example: 10s. Valid units are: ns, us, ms, s, m, h.
        Maximum value is 10 minutes.'
      name: timeout_duration
    description: Batch executes 'get' command across hosts to retrieve files.
    name: cs-falcon-run-get-command
    outputs:
    - contextPath: CrowdStrike.Command.HostID
      description: The ID of the host on which the command was running.
      type: string
    - contextPath: CrowdStrike.Command.Stdout
      description: The standard output of the command.
      type: string
    - contextPath: CrowdStrike.Command.Stderr
      description: The standard error of the command.
      type: string
    - contextPath: CrowdStrike.Command.BaseCommand
      description: The base command.
      type: string
    - contextPath: CrowdStrike.Command.TaskID
      description: The ID of the command that was running on the host.
      type: string
    - contextPath: CrowdStrike.Command.GetRequestID
      description: The ID of the command request that was accepted.
      type: string
    - contextPath: CrowdStrike.Command.Complete
      description: True if the command completed.
      type: boolean
    - contextPath: CrowdStrike.Command.FilePath
      description: The file path.
      type: string
  - arguments:
    - description: The list of IDs of the command requested.
      isArray: true
      name: request_ids
      required: true
    - description: 'The number of seconds to wait for the request before it times
        out. In ISO time format. For example: 2019-10-17T13:41:48.487520845Z.'
      name: timeout
    - description: 'The amount of time to wait for the request before it times out.
        In duration syntax. For example: 10s. Valid units are: ns, us, ms, s, m, h.
        Maximum value is 10 minutes.'
      name: timeout_duration
    description: Retrieves the status of the specified batch 'get' command.
    name: cs-falcon-status-get-command
    outputs:
    - contextPath: CrowdStrike.File.ID
      description: The ID of the file.
      type: string
    - contextPath: CrowdStrike.File.TaskID
      description: The ID of the command that is running.
      type: string
    - contextPath: CrowdStrike.File.CreatedAt
      description: The date the file was created.
      type: date
    - contextPath: CrowdStrike.File.DeletedAt
      description: The date the file was deleted.
      type: date
    - contextPath: CrowdStrike.File.UpdatedAt
      description: The date the file was last updated.
      type: date
    - contextPath: CrowdStrike.File.Name
      description: The full name of the file.
      type: string
    - contextPath: CrowdStrike.File.SHA256
      description: The SHA256 hash of the file.
      type: string
    - contextPath: CrowdStrike.File.Size
      description: The size of the file in bytes.
      type: number
    - contextPath: File.Name
      description: The full name of the file.
      type: string
    - contextPath: File.Size
      description: The size of the file in bytes.
      type: number
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: string
  - arguments:
    - description: The ID of the command requested.
      name: request_id
      required: true
    - description: The sequence ID in chunk requests.
      name: sequence_id
    - auto: PREDEFINED
      defaultValue: read
      description: 'The scope for which to run the command. Possible values are: "read",
        "write", or "admin".'
      name: scope
      predefined:
      - read
      - write
      - admin
    description: Gets the status of a command executed on a host.
    name: cs-falcon-status-command
    outputs:
    - contextPath: CrowdStrike.Command.TaskID
      description: The ID of the command request that was accepted.
      type: string
    - contextPath: CrowdStrike.Command.Stdout
      description: The standard output of the command.
      type: string
    - contextPath: CrowdStrike.Command.Stderr
      description: The standard error of the command.
      type: string
    - contextPath: CrowdStrike.Command.BaseCommand
      description: The base command.
      type: string
    - contextPath: CrowdStrike.Command.Complete
      description: True if the command completed.
      type: boolean
    - contextPath: CrowdStrike.Command.SequenceID
      description: The sequence ID in the current request.
      type: number
    - contextPath: CrowdStrike.Command.NextSequenceID
      description: The sequence ID for the next request in the chunk request.
      type: number
  - arguments:
    - description: The host agent ID.
      name: host_id
      required: true
    - description: The SHA256 hash of the file.
      name: sha256
      required: true
    - description: The filename to use for the archive name and the file within the
        archive.
      name: filename
    description: Gets the RTR extracted file contents for the specified session and
      SHA256 hash.
    name: cs-falcon-get-extracted-file
  - arguments:
    - description: The ID of the host agent that lists files in the session.
      name: host_id
      required: true
    description: Gets a list of files for the specified RTR session on a host.
    name: cs-falcon-list-host-files
    outputs:
    - contextPath: CrowdStrike.Command.HostID
      description: The ID of the host for which the command was running.
      type: string
    - contextPath: CrowdStrike.Command.TaskID
      description: The ID of the command request that was accepted.
      type: string
    - contextPath: CrowdStrike.Command.SessionID
      description: The ID of the session of the host.
      type: string
    - contextPath: CrowdStrike.File.ID
      description: The ID of the file.
      type: string
    - contextPath: CrowdStrike.File.CreatedAt
      description: The date the file was created.
      type: date
    - contextPath: CrowdStrike.File.DeletedAt
      description: The date the file was deleted.
      type: date
    - contextPath: CrowdStrike.File.UpdatedAt
      description: The date the file was last updated.
      type: date
    - contextPath: CrowdStrike.File.Name
      description: The full name of the file.
      type: string
    - contextPath: CrowdStrike.File.SHA256
      description: The SHA256 hash of the file.
      type: string
    - contextPath: CrowdStrike.File.Size
      description: The size of the file in bytes.
      type: number
    - contextPath: File.Name
      description: The full name of the file.
      type: string
    - contextPath: File.Size
      description: The size of the file in bytes.
      type: number
    - contextPath: File.SHA256
      description: The SHA256 hash of the file.
      type: string
  - arguments:
    - description: The ID of the host for which to extend the session.
      name: host_id
      required: true
    description: Refresh a session timeout on a single host.
    name: cs-falcon-refresh-session
  - arguments:
    - description: 'A comma-separated list of indicator types. Valid types are: "sha256",
        "sha1", "md5", "domain", "ipv4", "ipv6".'
      isArray: true
      name: types
    - description: A comma-separated list of indicator values.
      isArray: true
      name: values
    - description: A comma-separated list of indicator policies.
      isArray: true
      name: policies
    - description: The level at which the indicator will be shared. Only "red" share
        level (not shared) is supported, which indicates that the IOC is not shared
        with other Falcon Host customers.
      isArray: true
      name: share_levels
    - description: A comma-separated list of IOC sources.
      isArray: true
      name: sources
    - description: Start of date range in which to search (YYYY-MM-DD format).
      name: from_expiration_date
    - description: End of date range in which to search (YYYY-MM-DD format).
      name: to_expiration_date
    - description: The maximum number of records to return. The minimum is 1 and the
        maximum is 500. Default is 100.
      name: limit
    - auto: PREDEFINED
      description: 'The order in which the results are returned. Possible values are:
        "type.asc", "type.desc", "value.asc", "value.desc", "policy.asc", "policy.desc",
        "share_level.asc", "share_level.desc", "expiration_timestamp.asc", and "expiration_timestamp.desc".'
      name: sort
      predefined:
      - type.asc
      - type.desc
      - value.asc
      - value.desc
      - policy.asc
      - policy.desc
      - share_level.asc
      - share_level.desc
      - expiration_timestamp.asc
      - expiration_timestamp.desc
    - description: The offset to begin the list from. For example, start from the
        10th record and return the list. Default is 0.
      name: offset
    deprecated: true
    description: Deprecated. Use the cs-falcon-search-custom-iocs command instead.
    name: cs-falcon-search-iocs
    outputs:
    - contextPath: CrowdStrike.IOC.Type
      description: The type of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Value
      description: The string representation of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.ID
      description: The full ID of the indicator (type:value).
      type: string
    - contextPath: CrowdStrike.IOC.Policy
      description: The policy of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.Source
      description: The source of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.ShareLevel
      description: The level at which the indicator will be shared.
      type: string
    - contextPath: CrowdStrike.IOC.Expiration
      description: The datetime when the indicator will expire.
      type: string
    - contextPath: CrowdStrike.IOC.Description
      description: The description of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedTime
      description: The datetime the IOC was created.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedBy
      description: The identity of the user/process who created the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedTime
      description: The datetime the indicator was last modified.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedBy
      description: The identity of the user/process who last updated the IOC.
      type: string
  - arguments:
    - auto: PREDEFINED
      description: 'The IOC type to retrieve. Possible values are: "sha256", "sha1",
        "md5", "domain", "ipv4", and "ipv6".'
      name: type
      predefined:
      - sha256
      - sha1
      - md5
      - domain
      - ipv4
      - ipv6
      required: true
    - description: The string representation of the indicator.
      name: value
      required: true
    deprecated: true
    description: Deprecated. Use the cs-falcon-get-custom-ioc command instead.
    name: cs-falcon-get-ioc
    outputs:
    - contextPath: CrowdStrike.IOC.Type
      description: The type of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Value
      description: The string representation of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.ID
      description: The full ID of the indicator (type:value).
      type: string
    - contextPath: CrowdStrike.IOC.Policy
      description: The policy of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.Source
      description: The source of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.ShareLevel
      description: The level at which the indicator will be shared.
      type: string
    - contextPath: CrowdStrike.IOC.Expiration
      description: The date and time when the indicator will expire.
      type: string
    - contextPath: CrowdStrike.IOC.Description
      description: The description of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedTime
      description: The date and time the IOC was created.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedBy
      description: The identity of the user/process who created the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedTime
      description: The datetime the indicator was last modified.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedBy
      description: The identity of the user/process who last updated the IOC.
      type: string
  - arguments:
    - auto: PREDEFINED
      description: 'The type of the indicator. Possible values are: "sha256", "md5",
        "domain", "ipv4", and "ipv6".'
      name: ioc_type
      predefined:
      - sha256
      - md5
      - domain
      - ipv4
      - ipv6
      required: true
    - description: The string representation of the indicator.
      name: value
      required: true
    - auto: PREDEFINED
      defaultValue: detect
      description: 'The policy to enact when the value is detected on a host. Possible
        values are: "detect" and "none". A value of "none" is equivalent to turning
        the indicator off.'
      name: policy
      predefined:
      - detect
      - none
    - auto: PREDEFINED
      description: The level at which the indicator will be shared. Only "red" share
        level (not shared) is supported, which indicates that the IOC is not shared
        with other Falcon Host customers.
      name: share_level
      predefined:
      - red
    - description: The number of days for which the indicator should be valid. This
        only applies to domain, ipv4, and ipv6 types. Default is 30.
      name: expiration_days
    - description: The source where this indicator originated. This can be used for
        tracking where this indicator was defined. Limited to 200 characters.
      name: source
    - description: A meaningful description of the indicator. Limited to 200 characters.
      name: description
    deprecated: true
    description: Deprecated. Use the cs-falcon-upload-custom-ioc command instead.
    name: cs-falcon-upload-ioc
    outputs:
    - contextPath: CrowdStrike.IOC.Type
      description: The type of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Value
      description: The string representation of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.ID
      description: The full ID of the indicator (type:value).
      type: string
    - contextPath: CrowdStrike.IOC.Policy
      description: The policy of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.Source
      description: The source of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.ShareLevel
      description: The level at which the indicator will be shared.
      type: string
    - contextPath: CrowdStrike.IOC.Expiration
      description: The datetime when the indicator will expire.
      type: string
    - contextPath: CrowdStrike.IOC.Description
      description: The description of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedTime
      description: The datetime the IOC was created.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedBy
      description: The identity of the user/process who created the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedTime
      description: The date and time the indicator was last modified.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedBy
      description: The identity of the user/process who last updated the IOC.
      type: string
  - arguments:
    - auto: PREDEFINED
      description: 'The type of the indicator. Possible values are: "sha256", "md5",
        "sha1", "domain", "ipv4", and "ipv6".'
      name: ioc_type
      predefined:
      - sha256
      - md5
      - sha1
      - domain
      - ipv4
      - ipv6
      required: true
    - description: The string representation of the indicator.
      name: value
      required: true
    - auto: PREDEFINED
      defaultValue: detect
      description: 'The policy to enact when the value is detected on a host. Possible
        values are: "detect" and "none". A value of "none" is equivalent to turning
        the indicator off.'
      name: policy
      predefined:
      - detect
      - none
    - auto: PREDEFINED
      description: The level at which the indicator will be shared. Only "red" share
        level (not shared) is supported, which indicates that the IOC is not shared
        with other Falcon Host customers.
      name: share_level
      predefined:
      - red
    - description: The number of days for which the indicator should be valid. This
        only applies to domain, ipv4, and ipv6 types. Default is 30.
      name: expiration_days
    - description: The source where this indicator originated. This can be used for
        tracking where this indicator was defined. Limited to 200 characters.
      name: source
    - description: A meaningful description of the indicator. Limited to 200 characters.
      name: description
    deprecated: true
    description: Deprecated. Use the cs-falcon-update-custom-ioc command instead.
    name: cs-falcon-update-ioc
    outputs:
    - contextPath: CrowdStrike.IOC.Type
      description: The type of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Value
      description: The string representation of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.ID
      description: The full ID of the indicator (type:value).
      type: string
    - contextPath: CrowdStrike.IOC.Policy
      description: The policy of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.Source
      description: The source of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.ShareLevel
      description: The level at which the indicator will be shared.
      type: string
    - contextPath: CrowdStrike.IOC.Expiration
      description: The datetime when the indicator will expire.
      type: string
    - contextPath: CrowdStrike.IOC.Description
      description: The description of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedTime
      description: The datetime the IOC was created.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedBy
      description: The identity of the user/process who created the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedTime
      description: The date and time the indicator was last modified.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedBy
      description: The identity of the user/process who last updated the IOC.
      type: string
  - arguments:
    - auto: PREDEFINED
      description: 'The IOC type to delete. Possible values are: "sha256", "sha1",
        "md5", "domain", "ipv4", and "ipv6".'
      name: type
      predefined:
      - sha256
      - sha1
      - md5
      - domain
      - ipv4
      - ipv6
      required: true
    - description: The string representation of the indicator.
      name: value
      required: true
    deprecated: true
    description: Deprecated. Use the cs-falcon-delete-custom-ioc command instead.
    name: cs-falcon-delete-ioc
  - arguments:
    - auto: PREDEFINED
      description: 'A comma-separated list of indicator types. Valid types are: "sha256",
        "sha1", "md5", "domain", "ipv4", "ipv6".'
      isArray: true
      name: types
      predefined:
      - sha256
      - sha1
      - md5
      - domain
      - ipv4
      - ipv6
    - description: A comma-separated list of indicator values.
      isArray: true
      name: values
    - description: A comma-separated list of IOC sources.
      isArray: true
      name: sources
    - description: The date on which the indicator will become inactive (ISO 8601
        format, i.e. YYYY-MM-DDThh:mm:ssZ).
      name: expiration
    - defaultValue: "50"
      description: The maximum number of records to return. The minimum is 1 and the
        maximum is 500.
      name: limit
    - auto: PREDEFINED
      description: 'The order in which the results are returned. Possible values are:
        "type.asc", "type.desc", "value.asc", "value.desc", "policy.asc", "policy.desc",
        "share_level.asc", "share_level.desc", "expiration_timestamp.asc", and "expiration_timestamp.desc".'
      name: sort
      predefined:
      - type.asc
      - type.desc
      - value.asc
      - value.desc
      - policy.asc
      - policy.desc
      - share_level.asc
      - share_level.desc
      - expiration_timestamp.asc
      - expiration_timestamp.desc
    - description: The offset to begin the list from. For example, start from the
        10th record and return the list. Default is 0.
      name: offset
    description: Returns a list of your uploaded IOCs that match the search criteria.
    name: cs-falcon-search-custom-iocs
    outputs:
    - contextPath: CrowdStrike.IOC.Type
      description: The type of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Value
      description: The string representation of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.ID
      description: The full ID of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.Severity
      description: The severity level to apply to this indicator.
      type: string
    - contextPath: CrowdStrike.IOC.Source
      description: The source of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Action
      description: Action to take when a host observes the custom IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Expiration
      description: The datetime when the indicator will expire.
      type: string
    - contextPath: CrowdStrike.IOC.Description
      description: The description of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedTime
      description: The datetime the IOC was created.
      type: date
    - contextPath: CrowdStrike.IOC.CreatedBy
      description: The identity of the user/process who created the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedTime
      description: The datetime the indicator was last modified.
      type: date
    - contextPath: CrowdStrike.IOC.ModifiedBy
      description: The identity of the user/process who last updated the IOC.
      type: string
  - arguments:
    - auto: PREDEFINED
      description: 'The IOC type to retrieve. Possible values are: "sha256", "sha1",
        "md5", "domain", "ipv4", and "ipv6". Either ioc_id or ioc_type and value must
        be provided.'
      name: type
      predefined:
      - sha256
      - sha1
      - md5
      - domain
      - ipv4
      - ipv6
    - description: The string representation of the indicator. Either ioc_id or ioc_type
        and value must be provided.
      name: value
    - description: The ID of the IOC to get. Can be retrieved by running the cs-falcon-search-custom-iocs
        command. Either ioc_id or ioc_type and value must be provided.
      name: ioc_id
    description: Gets the full definition of one or more indicators that you are watching.
    name: cs-falcon-get-custom-ioc
    outputs:
    - contextPath: CrowdStrike.IOC.Type
      description: The type of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Value
      description: The string representation of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.ID
      description: The full ID of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.Severity
      description: The severity level to apply to this indicator.
      type: string
    - contextPath: CrowdStrike.IOC.Source
      description: The source of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Action
      description: Action to take when a host observes the custom IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Expiration
      description: The datetime when the indicator will expire.
      type: string
    - contextPath: CrowdStrike.IOC.Description
      description: The description of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedTime
      description: The datetime the IOC was created.
      type: date
    - contextPath: CrowdStrike.IOC.CreatedBy
      description: The identity of the user/process who created the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedTime
      description: The datetime the indicator was last modified.
      type: date
    - contextPath: CrowdStrike.IOC.ModifiedBy
      description: The identity of the user/process who last updated the IOC.
      type: string
  - arguments:
    - auto: PREDEFINED
      description: 'The type of the indicator. Possible values are: "sha256", "md5",
        "domain", "ipv4", and "ipv6".'
      name: ioc_type
      predefined:
      - sha256
      - md5
      - domain
      - ipv4
      - ipv6
      required: true
    - description: The string representation of the indicator.
      name: value
      required: true
    - auto: PREDEFINED
      description: 'Action to take when a host observes the custom IOC. Possible values
        are: no_action - Save the indicator for future use, but take no action. No
        severity required. allow - Applies to hashes only. Allow the indicator and
        do not detect it. Severity does not apply and should not be provided. prevent_no_ui
        - Applies to hashes only. Block and detect the indicator, but hide it from
        Activity > Detections. Has a default severity value. prevent - Applies to
        hashes only. Block the indicator and show it as a detection at the selected
        severity. detect - Enable detections for the indicator at the selected severity.'
      name: action
      predefined:
      - no_action
      - allow
      - prevent_no_ui
      - prevent
      - detect
      required: true
    - auto: PREDEFINED
      description: 'The platforms that the indicator applies to. You can enter multiple
        platform names, separated by commas. Possible values are: mac, windows and
        linux.'
      name: platforms
      predefined:
      - mac
      - windows
      - linux
      required: true
    - auto: PREDEFINED
      description: 'The severity level to apply to this indicator. Required for the
        prevent and detect actions. Optional for no_action. Possible values are: informational,
        low, medium, high, and critical.'
      name: severity
      predefined:
      - informational
      - low
      - medium
      - high
      - critical
    - description: The date on which the indicator will become inactive (ISO 8601
        format, i.e. YYYY-MM-DDThh:mm:ssZ).
      name: expiration
    - description: The source where this indicator originated. This can be used for
        tracking where this indicator was defined. Limited to 200 characters.
      name: source
    - description: A meaningful description of the indicator. Limited to 200 characters.
      name: description
    - auto: PREDEFINED
      description: Whether the indicator is applied globally. Either applied_globally
        or host_groups must be provided.
      name: applied_globally
      predefined:
      - "true"
      - "false"
    - description: List of host group IDs that the indicator applies to. Can be retrieved
        by running the cs-falcon-list-host-groups command. Either applied_globally
        or host_groups must be provided.
      isArray: true
      name: host_groups
    description: Uploads an indicator for CrowdStrike to monitor.
    name: cs-falcon-upload-custom-ioc
    outputs:
    - contextPath: CrowdStrike.IOC.Type
      description: The type of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Value
      description: The string representation of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.ID
      description: The full ID of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.Severity
      description: The severity level to apply to this indicator.
      type: string
    - contextPath: CrowdStrike.IOC.Source
      description: The source of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Action
      description: Action to take when a host observes the custom IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Expiration
      description: The datetime when the indicator will expire.
      type: string
    - contextPath: CrowdStrike.IOC.Description
      description: The description of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedTime
      description: The datetime the IOC was created.
      type: date
    - contextPath: CrowdStrike.IOC.CreatedBy
      description: The identity of the user/process who created the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedTime
      description: The datetime the indicator was last modified.
      type: date
    - contextPath: CrowdStrike.IOC.ModifiedBy
      description: The identity of the user/process who last updated the IOC.
      type: string
  - arguments:
    - description: The ID of the IOC to update. Can be retrieved by running the cs-falcon-search-custom-iocs
        command.
      name: ioc_id
      required: true
    - auto: PREDEFINED
      description: 'Action to take when a host observes the custom IOC. Possible values
        are: no_action - Save the indicator for future use, but take no action. No
        severity required. allow - Applies to hashes only. Allow the indicator and
        do not detect it. Severity does not apply and should not be provided. prevent_no_ui
        - Applies to hashes only. Block and detect the indicator, but hide it from
        Activity > Detections. Has a default severity value. prevent - Applies to
        hashes only. Block the indicator and show it as a detection at the selected
        severity. detect - Enable detections for the indicator at the selected severity.'
      name: action
      predefined:
      - no_action
      - allow
      - prevent_no_ui
      - prevent
      - detect
    - auto: PREDEFINED
      description: 'The platforms that the indicator applies to. You can enter multiple
        platform names, separated by commas. Possible values are: mac, windows and
        linux.'
      name: platforms
      predefined:
      - mac
      - windows
      - linux
    - auto: PREDEFINED
      description: 'The severity level to apply to this indicator. Required for the
        prevent and detect actions. Optional for no_action. Possible values are: informational,
        low, medium, high and critical.'
      name: severity
      predefined:
      - informational
      - low
      - medium
      - high
      - critical
    - description: The date on which the indicator will become inactive (ISO 8601
        format, i.e. YYYY-MM-DDThh:mm:ssZ).
      name: expiration
    - description: The source where this indicator originated. This can be used for
        tracking where this indicator was defined. Limited to 200 characters.
      name: source
    - description: A meaningful description of the indicator. Limited to 200 characters.
      name: description
    description: Updates an indicator for CrowdStrike to monitor.
    name: cs-falcon-update-custom-ioc
    outputs:
    - contextPath: CrowdStrike.IOC.Type
      description: The type of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Value
      description: The string representation of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.ID
      description: The full ID of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.Severity
      description: The severity level to apply to this indicator.
      type: string
    - contextPath: CrowdStrike.IOC.Source
      description: The source of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Action
      description: Action to take when a host observes the custom IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Expiration
      description: The datetime when the indicator will expire.
      type: string
    - contextPath: CrowdStrike.IOC.Description
      description: The description of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.CreatedTime
      description: The datetime the IOC was created.
      type: date
    - contextPath: CrowdStrike.IOC.CreatedBy
      description: The identity of the user/process who created the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.ModifiedTime
      description: The datetime the indicator was last modified.
      type: date
    - contextPath: CrowdStrike.IOC.ModifiedBy
      description: The identity of the user/process who last updated the IOC.
      type: string
  - arguments:
    - description: The ID of the IOC to delete. Can be retrieved by running the cs-falcon-search-custom-iocs
        command.
      name: ioc_id
      required: true
    description: Deletes a monitored indicator.
    name: cs-falcon-delete-custom-ioc
  - arguments:
    - auto: PREDEFINED
      description: 'The IOC type. Possible values are: "sha256", "sha1", "md5", "domain",
        "ipv4", and "ipv6".'
      name: type
      predefined:
      - sha256
      - sha1
      - md5
      - domain
      - ipv4
      - ipv6
      required: true
    - description: The string representation of the indicator.
      name: value
      required: true
    description: The number of hosts that observed the provided IOC.
    name: cs-falcon-device-count-ioc
    outputs:
    - contextPath: CrowdStrike.IOC.Type
      description: The type of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Value
      description: The string representation of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.ID
      description: The full ID of the indicator (type:value).
      type: string
    - contextPath: CrowdStrike.IOC.DeviceCount
      description: The number of devices the IOC ran on.
      type: number
  - arguments:
    - auto: PREDEFINED
      description: 'The IOC type. Possible values are: "sha256", "sha1", "md5", "domain",
        "ipv4", and "ipv6".'
      name: type
      predefined:
      - sha256
      - sha1
      - md5
      - domain
      - ipv4
      - ipv6
      required: true
    - description: The string representation of the indicator.
      name: value
      required: true
    - description: The device ID to check against.
      name: device_id
      required: true
    description: Get processes associated with a given IOC.
    name: cs-falcon-processes-ran-on
    outputs:
    - contextPath: CrowdStrike.IOC.Type
      description: The type of the IOC.
      type: string
    - contextPath: CrowdStrike.IOC.Value
      description: The string representation of the indicator.
      type: string
    - contextPath: CrowdStrike.IOC.ID
      description: The full ID of the indicator (type:value).
      type: string
    - contextPath: CrowdStrike.IOC.Process.ID
      description: The processes IDs associated with the given IOC.
      type: number
    - contextPath: CrowdStrike.IOC.Process.DeviceID
      description: The device the process ran on.
      type: number
  - arguments:
    - default: true
      description: A comma-separated list of process IDs.
      isArray: true
      name: ids
      required: true
    description: Retrieves the details of a process, according to the process ID,
      that is running or that previously ran.
    name: cs-falcon-process-details
    outputs:
    - contextPath: CrowdStrike.Process.process_id
      description: The process ID.
      type: String
    - contextPath: CrowdStrike.Process.process_id_local
      description: Local ID of the process.
      type: String
    - contextPath: CrowdStrike.Process.device_id
      description: The device the process ran on.
      type: String
    - contextPath: CrowdStrike.Process.file_name
      description: The path of the file that ran the process.
      type: String
    - contextPath: CrowdStrike.Process.command_line
      description: The command line command execution.
      type: String
    - contextPath: CrowdStrike.Process.start_timestamp_raw
      description: 'The start datetime of the process in Unix epoch time format. For
        example: 132460167512852140.'
      type: String
    - contextPath: CrowdStrike.Process.start_timestamp
      description: 'The start datetime of the process in ISO time format. For example:
        2019-10-17T13:41:48.487520845Z.'
      type: String
    - contextPath: CrowdStrike.Process.stop_timestamp_raw
      description: 'The stop datetime of the process in Unix epoch time format. For
        example: 132460167512852140.'
      type: Date
    - contextPath: CrowdStrike.Process.stop_timestamp
      description: 'The stop datetime of the process in ISO time format. For example:
        2019-10-17T13:41:48.487520845Z.'
      type: Date
  - arguments:
    - auto: PREDEFINED
      description: 'The type of indicator. Possible values are: "domain", "ipv4",
        "ipv6", "md5", "sha1", or "sha256".'
      name: type
      predefined:
      - domain
      - ipv4
      - ipv6
      - md5
      - sha1
      - sha256
      required: true
    - description: The string representation of the indicator.
      name: value
      required: true
    deprecated: true
    description: Returns a list of device IDs on which an indicator ran.
    name: cs-device-ran-on
    outputs:
    - contextPath: CrowdStrike.DeviceID
      description: Device IDs on which an indicator ran.
      type: string
  - arguments:
    - auto: PREDEFINED
      description: 'The type of indicator. Possible values are: "domain", "ipv4",
        "ipv6", "md5", "sha1", or "sha256".'
      name: type
      predefined:
      - domain
      - ipv4
      - ipv6
      - md5
      - sha1
      - sha256
      required: true
    - description: The string representation of the indicator.
      name: value
      required: true
    description: Returns a list of device IDs on which an indicator ran.
    name: cs-falcon-device-ran-on
    outputs:
    - contextPath: CrowdStrike.DeviceID
      description: Device IDs on which an indicator ran.
      type: string
  - arguments:
    - description: The query used to filter the results.
      name: fetch_query
    description: Lists detection summaries.
    name: cs-falcon-list-detection-summaries
    outputs:
    - contextPath: CrowdStrike.Detections.cid
      description: The organization's customer ID (CID).
      type: String
    - contextPath: CrowdStrike.Detections.created_timestamp
      description: 'The datetime when the detection occurred in ISO time format. For
        example: 2019-10-17T13:41:48.487520845Z.'
      type: Date
    - contextPath: CrowdStrike.Detections.detection_id
      description: The ID of the detection.
      type: String
    - contextPath: CrowdStrike.Detections.device.device_id
      description: The device ID as seen by CrowdStrike.
      type: String
    - contextPath: CrowdStrike.Detections.device.cid
      description: The CrowdStrike Customer ID (CID) to which the device belongs.
      type: String
    - contextPath: CrowdStrike.Detections.device.agent_load_flags
      description: The CrowdStrike agent load flags.
      type: String
    - contextPath: CrowdStrike.Detections.device.agent_local_time
      description: The local time of the sensor.
      type: Date
    - contextPath: CrowdStrike.Detections.device.agent_version
      description: 'The version of the agent that the device is running. For example:
        5.32.11406.0.'
      type: String
    - contextPath: CrowdStrike.Detections.device.bios_manufacturer
      description: The BIOS manufacturer.
      type: String
    - contextPath: CrowdStrike.Detections.device.bios_version
      description: The device's BIOS version.
      type: String
    - contextPath: CrowdStrike.Detections.device.config_id_base
      description: The base of the sensor that the device is running.
      type: String
    - contextPath: CrowdStrike.Detections.device.config_id_build
      description: 'The version of the sensor that the device is running. For example:
        11406.'
      type: String
    - contextPath: CrowdStrike.Detections.device.config_id_platform
      description: The platform ID of the sensor that the device is running.
      type: String
    - contextPath: CrowdStrike.Detections.device.external_ip
      description: The external IP address of the device.
      type: String
    - contextPath: CrowdStrike.Detections.device.hostname
      description: The host name of the device.
      type: String
    - contextPath: CrowdStrike.Detections.device.first_seen
      description: The datetime when the host was first seen by CrowdStrike.
      type: Date
    - contextPath: CrowdStrike.Detections.device.last_seen
      description: The datetime when the host was last seen by CrowdStrike.
      type: Date
    - contextPath: CrowdStrike.Detections.device.local_ip
      description: The local IP address of the device.
      type: String
    - contextPath: CrowdStrike.Detections.device.mac_address
      description: The MAC address of the device.
      type: String
    - contextPath: CrowdStrike.Detections.device.major_version
      description: The major version of the operating system.
      type: String
    - contextPath: CrowdStrike.Detections.device.minor_version
      description: The minor version of the operating system.
      type: String
    - contextPath: CrowdStrike.Detections.device.os_version
      description: The operating system of the device.
      type: String
    - contextPath: CrowdStrike.Detections.device.platform_id
      description: The platform ID of the device that runs the sensor.
      type: String
    - contextPath: CrowdStrike.Detections.device.platform_name
      description: The platform name of the device.
      type: String
    - contextPath: CrowdStrike.Detections.device.product_type_desc
      description: The value indicating the product type. For example, 1 = Workstation,
        2 = Domain Controller, 3 = Server.
      type: String
    - contextPath: CrowdStrike.Detections.device.status
      description: 'The containment status of the machine. Possible values are: "normal",
        "containment_pending", "contained", and "lift_containment_pending".'
      type: String
    - contextPath: CrowdStrike.Detections.device.system_manufacturer
      description: The system manufacturer of the device.
      type: String
    - contextPath: CrowdStrike.Detections.device.system_product_name
      description: The product name of the system.
      type: String
    - contextPath: CrowdStrike.Detections.device.modified_timestamp
      description: 'The datetime the device was last modified in ISO time format.
        For example: 2019-10-17T13:41:48.487520845Z.'
      type: Date
    - contextPath: CrowdStrike.Detections.behaviors.device_id
      description: The ID of the device associated with the behavior.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.timestamp
      description: 'The datetime the behavior detection occurred in ISO time format.
        For example: 2019-10-17T13:41:48.487520845Z.'
      type: Date
    - contextPath: CrowdStrike.Detections.behaviors.behavior_id
      description: The ID of the behavior.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.filename
      description: The file name of the triggering process.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.alleged_filetype
      description: The file extension of the behavior's filename.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.cmdline
      description: The command line of the triggering process.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.scenario
      description: The name of the scenario to which the behavior belongs.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.objective
      description: The name of the objective associated with the behavior.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.tactic
      description: The name of the tactic associated with the behavior.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.technique
      description: The name of the technique associated with the behavior.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.severity
      description: The severity rating for the behavior. The value can be any integer
        between 1-100.
      type: Number
    - contextPath: CrowdStrike.Detections.behaviors.confidence
      description: The true positive confidence rating for the behavior. The value
        can be any integer between 1-100.
      type: Number
    - contextPath: CrowdStrike.Detections.behaviors.ioc_type
      description: 'The type of the triggering IOC. Possible values are: "hash_sha256",
        "hash_md5", "domain", "filename", "registry_key", "command_line", and "behavior".'
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.ioc_value
      description: The IOC value.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.ioc_source
      description: 'The source that triggered an IOC detection. Possible values are:
        "library_load", "primary_module", "file_read", and "file_write".'
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.ioc_description
      description: The IOC description.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.user_name
      description: The user name.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.user_id
      description: The Security Identifier (SID) of the user in Windows.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.control_graph_id
      description: The behavior hit key for the Threat Graph API.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.triggering_process_graph_id
      description: The ID of the process that triggered the behavior detection.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.sha256
      description: The SHA256 of the triggering process.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.md5
      description: The MD5 of the triggering process.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.parent_details.parent_sha256
      description: The SHA256 hash of the parent process.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.parent_details.parent_md5
      description: The MD5 hash of the parent process.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.parent_details.parent_cmdline
      description: The command line of the parent process.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.parent_details.parent_process_graph_id
      description: The process graph ID of the parent process.
      type: String
    - contextPath: CrowdStrike.Detections.behaviors.pattern_disposition
      description: The pattern associated with the action performed on the behavior.
      type: Number
    - contextPath: CrowdStrike.Detections.behaviors.pattern_disposition_details.indicator
      description: Whether the detection behavior is similar to an indicator.
      type: Boolean
    - contextPath: CrowdStrike.Detections.behaviors.pattern_disposition_details.detect
      description: Whether this behavior is detected.
      type: Boolean
    - contextPath: CrowdStrike.Detections.behaviors.pattern_disposition_details.inddet_mask
      description: Whether this behavior is an inddet mask.
      type: Boolean
    - contextPath: CrowdStrike.Detections.behaviors.pattern_disposition_details.sensor_only
      description: Whether this detection is sensor only.
      type: Boolean
    - contextPath: CrowdStrike.Detections.behaviors.pattern_disposition_details.rooting
      description: Whether this behavior is rooting.
      type: Boolean
    - contextPath: CrowdStrike.Detections.behaviors.pattern_disposition_details.kill_process
      description: Whether this detection kills the process.
      type: Boolean
    - contextPath: CrowdStrike.Detections.behaviors.pattern_disposition_details.kill_subprocess
      description: Whether this detection kills the subprocess.
      type: Boolean
    - contextPath: CrowdStrike.Detections.behaviors.pattern_disposition_details.quarantine_machine
      description: Whether this detection was on a quarantined machine.
      type: Boolean
    - contextPath: CrowdStrike.Detections.behaviors.pattern_disposition_details.quarantine_file
      description: Whether this detection was on a quarantined file.
      type: Boolean
    - contextPath: CrowdStrike.Detections.behaviors.pattern_disposition_details.policy_disabled
      description: Whether this policy is disabled.
      type: Boolean
    - contextPath: CrowdStrike.Detections.behaviors.pattern_disposition_details.kill_parent
      description: Whether this detection kills the parent process.
      type: Boolean
    - contextPath: CrowdStrike.Detections.behaviors.pattern_disposition_details.operation_blocked
      description: Whether the operation is blocked.
      type: Boolean
    - contextPath: CrowdStrike.Detections.behaviors.pattern_disposition_details.process_blocked
      description: Whether the process is blocked.
      type: Boolean
    - contextPath: CrowdStrike.Detections.behaviors.pattern_disposition_details.registry_operation_blocked
      description: Whether the registry operation is blocked.
      type: Boolean
    - contextPath: CrowdStrike.Detections.email_sent
      description: Whether an email is sent about this detection.
      type: Boolean
    - contextPath: CrowdStrike.Detections.first_behavior
      description: The datetime of the first behavior.
      type: Date
    - contextPath: CrowdStrike.Detections.last_behavior
      description: The datetime of the last behavior.
      type: Date
    - contextPath: CrowdStrike.Detections.max_confidence
      description: The highest confidence value of all behaviors. The value can be
        any integer between 1-100.
      type: Number
    - contextPath: CrowdStrike.Detections.max_severity
      description: The highest severity value of all behaviors. Value can be any integer
        between 1-100.
      type: Number
    - contextPath: CrowdStrike.Detections.max_severity_displayname
      description: 'The name used in the UI to determine the severity of the detection.
        Possible values are: "Critical", "High", "Medium", and "Low".'
      type: String
    - contextPath: CrowdStrike.Detections.show_in_ui
      description: Whether the detection displays in the UI.
      type: Boolean
    - contextPath: CrowdStrike.Detections.status
      description: The status of detection.
      type: String
    - contextPath: CrowdStrike.Detections.assigned_to_uid
      description: The UID of the user for whom the detection is assigned.
      type: String
    - contextPath: CrowdStrike.Detections.assigned_to_name
      description: The human-readable name of the user to whom the detection is currently
        assigned.
      type: String
    - contextPath: CrowdStrike.Detections.hostinfo.domain
      description: The domain of the Active Directory.
      type: String
    - contextPath: CrowdStrike.Detections.seconds_to_triaged
      description: The amount of time it took to move a detection from "new" to "in_progress".
      type: Number
    - contextPath: CrowdStrike.Detections.seconds_to_resolved
      description: The amount of time it took to move a detection from new to a resolved
        state ("true_positive", "false_positive", and "ignored").
      type: Number
  - arguments:
    - description: The query used to filter the results.
      name: fetch_query
    description: Lists incident summaries.
    name: cs-falcon-list-incident-summaries
    outputs:
    - contextPath: CrowdStrike.Incidents.incident_id
      description: The ID of the incident.
      type: String
    - contextPath: CrowdStrike.Incidents.cid
      description: The organization's customer ID (CID).
      type: String
    - contextPath: CrowdStrike.Incidents.host_ids
      description: The device IDs of all the hosts on which the incident occurred.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.device_id
      description: The device ID as seen by CrowdStrike.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.cid
      description: The host's organization's customer ID (CID).
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.agent_load_flags
      description: The CrowdStrike agent load flags.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.agent_local_time
      description: The local time of the sensor.
      type: Date
    - contextPath: CrowdStrike.Incidents.hosts.agent_version
      description: 'The version of the agent that the device is running. For example:
        5.32.11406.0.'
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.bios_manufacturer
      description: The BIOS manufacturer.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.bios_version
      description: The BIOS version of the device.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.config_id_base
      description: The base of the sensor that the device is running.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.config_id_build
      description: 'The version of the sensor that the device is running. For example:
        11406.'
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.config_id_platform
      description: The platform ID of the sensor that the device is running.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.external_ip
      description: The external IP address of the host.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.hostname
      description: The name of the host.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.first_seen
      description: The date and time when the host was first seen by CrowdStrike.
      type: Date
    - contextPath: CrowdStrike.Incidents.hosts.last_seen
      description: The date and time when the host was last seen by CrowdStrike.
      type: Date
    - contextPath: CrowdStrike.Incidents.hosts.local_ip
      description: The device's local IP address.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.mac_address
      description: The device's MAC address.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.major_version
      description: The major version of the operating system.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.minor_version
      description: The minor version of the operating system.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.os_version
      description: The operating system of the host.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.platform_id
      description: The platform ID of the device that runs the sensor.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.platform_name
      description: The platform name of the host.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.product_type_desc
      description: The value indicating the product type. For example, 1 = Workstation,
        2 = Domain Controller, 3 = Server.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.status
      description: The incident status as a number. For example, 20 = New, 25 = Reopened,
        30 = In Progress, 40 = Closed.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.system_manufacturer
      description: The system manufacturer of the device.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.system_product_name
      description: The product name of the system.
      type: String
    - contextPath: CrowdStrike.Incidents.hosts.modified_timestamp
      description: 'The datetime when a user modified the incident in ISO time format.
        For example: 2019-10-17T13:41:48.487520845Z.'
      type: Date
    - contextPath: CrowdStrike.Incidents.created
      description: The time that the incident was created.
      type: Date
    - contextPath: CrowdStrike.Incidents.start
      description: The recorded time of the earliest incident.
      type: Date
    - contextPath: CrowdStrike.Incidents.end
      description: The recorded time of the latest incident.
      type: Date
    - contextPath: CrowdStrike.Incidents.state
      description: The state of the incident.
      type: String
    - contextPath: CrowdStrike.Incidents.status
      description: The status of the incident.
      type: Number
    - contextPath: CrowdStrike.Incidents.name
      description: The name of the incident.
      type: String
    - contextPath: CrowdStrike.Incidents.description
      description: The description of the incident.
      type: String
    - contextPath: CrowdStrike.Incidents.tags
      description: The tags of the incident.
      type: String
    - contextPath: CrowdStrike.Incidents.fine_score
      description: The incident score.
      type: Number
  - arguments:
    - description: The endpoint ID.
      name: id
    - default: true
      description: The endpoint IP address.
      name: ip
    - description: The endpoint hostname.
      name: hostname
    description: Returns information about an endpoint.
    name: endpoint
    outputs:
    - contextPath: Endpoint.Hostname
      description: The endpoint's hostname.
      type: String
    - contextPath: Endpoint.OS
      description: The endpoint's operation system.
      type: String
    - contextPath: Endpoint.IPAddress
      description: The endpoint's IP address.
      type: String
    - contextPath: Endpoint.ID
      description: The endpoint's ID.
      type: String
    - contextPath: Endpoint.Status
      description: The endpoint's status.
      type: String
    - contextPath: Endpoint.IsIsolated
      description: The endpoint's isolation status.
      type: String
    - contextPath: Endpoint.MACAddress
      description: The endpoint's MAC address.
      type: String
    - contextPath: Endpoint.Vendor
      description: The integration name of the endpoint vendor.
      type: String
    - contextPath: Endpoint.OSVersion
      description: The endpoint's operation system version.
      type: String
  - arguments:
    - description: The name of the host.
      name: name
      required: true
    - auto: PREDEFINED
      description: The group type of the group. Can be 'static' or 'dynamic'.
      name: group_type
      predefined:
      - static
      - dynamic
      required: true
    - description: The description of the host.
      name: description
    - description: The assignment rule.
      name: assignment_rule
    description: Create a host group.
    name: cs-falcon-create-host-group
    outputs:
    - contextPath: CrowdStrike.HostGroup.id
      description: The ID of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.group_type
      description: The group type of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.name
      description: The name of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.description
      description: The description of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.created_by
      description: The client that created the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.created_timestamp
      description: 'The datetime when the host group was created in ISO time format.
        For example: 2019-10-17T13:41:48.487520845Z.'
      type: Date
    - contextPath: CrowdStrike.HostGroup.modified_by
      description: The client that modified the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.modified_timestamp
      description: 'The datetime when the host group was last modified in ISO time
        format. For example: 2019-10-17T13:41:48.487520845Z.'
      type: Date
  - arguments:
    - description: The query by which to filter the devices that belong to the host
        group.
      name: filter
    - description: Page offset.
      name: offset
    - default: true
      defaultValue: "50"
      description: Maximum number of results on a page.
      name: limit
    description: List the available host groups.
    name: cs-falcon-list-host-groups
    outputs:
    - contextPath: CrowdStrike.HostGroup.id
      description: The ID of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.group_type
      description: The group type of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.name
      description: The name of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.description
      description: The description of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.created_by
      description: The client that created the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.created_timestamp
      description: 'The datetime when the host group was created in ISO time format.
        For example: 2019-10-17T13:41:48.487520845Z.'
      type: Date
    - contextPath: CrowdStrike.HostGroup.modified_by
      description: The client that modified the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.modified_timestamp
      description: 'The datetime when the host group was last modified in ISO time
        format. For example: 2019-10-17T13:41:48.487520845Z.'
      type: Date
  - arguments:
    - description: A comma-separated list of the IDs of the host groups to be deleted.
      isArray: true
      name: host_group_id
      required: true
    description: Delete the requested host groups.
    name: cs-falcon-delete-host-groups
  - arguments:
    - description: The ID of the host group.
      name: host_group_id
      required: true
    - description: The name of the host group.
      name: name
    - description: The description of the host group.
      name: description
    - description: The assignment rule.
      name: assignment_rule
    description: Update a host group.
    name: cs-falcon-update-host-group
    outputs:
    - contextPath: CrowdStrike.HostGroup.id
      description: The ID of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.group_type
      description: The group type of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.name
      description: The name of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.description
      description: The description of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.created_by
      description: The client that created the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.created_timestamp
      description: 'The datetime when the host group was created in ISO time format.
        For example: 2019-10-17T13:41:48.487520845Z.'
      type: Date
    - contextPath: CrowdStrike.HostGroup.modified_by
      description: The client that modified the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.modified_timestamp
      description: 'The datetime when the host group was last modified in ISO time
        format. For example: 2019-10-17T13:41:48.487520845Z.'
      type: Date
  - arguments:
    - description: The ID of the host group.
      name: host_group_id
    - description: The query by which to filter the devices that belong to the host
        group.
      name: filter
    - description: Page offset.
      name: offset
    - default: true
      defaultValue: "50"
      description: Maximum number of results on a page.
      name: limit
    description: Get the list of host group members.
    name: cs-falcon-list-host-group-members
    outputs:
    - contextPath: CrowdStrike.Device.ID
      description: The ID of the device.
      type: String
    - contextPath: CrowdStrike.Device.LocalIP
      description: The local IP address of the device.
      type: String
    - contextPath: CrowdStrike.Device.ExternalIP
      description: The external IP address of the device.
      type: String
    - contextPath: CrowdStrike.Device.Hostname
      description: The host name of the device.
      type: String
    - contextPath: CrowdStrike.Device.OS
      description: The operating system of the device.
      type: String
    - contextPath: CrowdStrike.Device.MacAddress
      description: The MAC address of the device.
      type: String
    - contextPath: CrowdStrike.Device.FirstSeen
      description: The first time the device was seen.
      type: String
    - contextPath: CrowdStrike.Device.LastSeen
      description: The last time the device was seen.
      type: String
    - contextPath: CrowdStrike.Device.Status
      description: The device status.
      type: String
  - arguments:
    - description: The ID of the host group.
      name: host_group_id
      required: true
    - description: A comma-separated list of host agent IDs to run commands. (The
        list of host agent IDs can be retrieved by running the 'cs-falcon-search-device'
        command.)
      isArray: true
      name: host_ids
      required: true
    description: Add host group members.
    name: cs-falcon-add-host-group-members
    outputs:
    - contextPath: CrowdStrike.HostGroup.id
      description: The ID of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.group_type
      description: The group type of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.name
      description: The name of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.description
      description: The description of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.created_by
      description: The client that created the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.created_timestamp
      description: 'The datetime when the host group was created in ISO time format.
        For example: 2019-10-17T13:41:48.487520845Z.'
      type: Date
    - contextPath: CrowdStrike.HostGroup.modified_by
      description: The client that modified the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.modified_timestamp
      description: 'The datetime when the host group was last modified in ISO time
        format. For example: 2019-10-17T13:41:48.487520845Z.'
      type: Date
  - arguments:
    - description: The ID of the host group.
      name: host_group_id
      required: true
    - description: A comma-separated list of host agent IDs to run commands. (The
        list of host agent IDs can be retrieved by running the 'cs-falcon-search-device'
        command.)
      isArray: true
      name: host_ids
      required: true
    description: Remove host group members.
    name: cs-falcon-remove-host-group-members
    outputs:
    - contextPath: CrowdStrike.HostGroup.id
      description: The ID of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.group_type
      description: The group type of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.name
      description: The name of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.description
      description: The description of the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.created_by
      description: The client that created the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.created_timestamp
      description: 'The datetime when the host group was created in ISO time format.
        For example: 2019-10-17T13:41:48.487520845Z.'
      type: Date
    - contextPath: CrowdStrike.HostGroup.modified_by
      description: The client that modified the host group.
      type: String
    - contextPath: CrowdStrike.HostGroup.modified_timestamp
      description: 'The datetime when the host group was last modified in ISO time
        format. For example: 2019-10-17T13:41:48.487520845Z.'
      type: Date
  - arguments:
    - description: A comma-separated list of incident IDs.
      isArray: true
      name: ids
      required: true
    - auto: PREDEFINED
      description: The new status of the incident. Can be "New", "In Progress", "Reopened",
        "Closed".
      name: status
      predefined:
      - New
      - In Progress
      - Reopened
      - Closed
      required: true
    description: Resolve incidents.
    name: cs-falcon-resolve-incident
  - arguments:
    - description: The filter field using which a device can be searched. E.g., -
        mac_address or local_ip
      isArray: true
      name: mac_address
    - description: The comma seperated list of search field. E.g., local_ip or mac_address
        of devices
      isArray: true
      name: local_ip
    description: Searches for the unique devices in CrowdStrike using filter i.e.,
      list of mac_address and local_ip
    name: cs-falcon-search-devices-by-mac
    outputs:
    - contextPath: CrowdStrike.Device.ID
      description: The ID of the device.
      type: string
    - contextPath: CrowdStrike.Device.LocalIP
      description: The local IP address of the device.
      type: string
    - contextPath: CrowdStrike.Device.ExternalIP
      description: The external IP address of the device.
      type: string
    - contextPath: CrowdStrike.Device.Hostname
      description: The host name of the device.
      type: string
    - contextPath: CrowdStrike.Device.OS
      description: The operating system of the device.
      type: string
    - contextPath: CrowdStrike.Device.MacAddress
      description: The MAC address of the device.
      type: string
    - contextPath: CrowdStrike.Device.FirstSeen
      description: The first time the device was seen.
      type: string
    - contextPath: CrowdStrike.Device.LastSeen
      description: The last time the device was seen.
      type: string
    - contextPath: CrowdStrike.Device.PolicyType
      description: The policy type of the device.
      type: string
    - contextPath: CrowdStrike.Device.Status
      description: The device status.
      type: string
    - contextPath: Endpoint.Hostname
      description: The endpoint's hostname.
      type: string
    - contextPath: Endpoint.OS
      description: The endpoint's operation system.
      type: string
    - contextPath: Endpoint.IPAddress
      description: The endpoint's IP address.
      type: string
    - contextPath: Endpoint.ID
      description: The endpoint's ID.
      type: string
    - contextPath: Endpoint.Status
      description: The endpoint's status.
      type: string
    - contextPath: Endpoint.IsIsolated
      description: The endpoint's isolation status.
      type: string
    - contextPath: Endpoint.MACAddress
      description: The endpoint's MAC address.
      type: string
    - contextPath: Endpoint.Vendor
      description: The integration name of the endpoint vendor.
      type: string
    - contextPath: Endpoint.OSVersion
      description: The endpoint's operation system version.
      type: string
    - contextPath: CrowdStrike.Device.ProvisionStatus
      description: The provision status of device
      type: string
    - contextPath: CrowdStrike.Device.SerialNumber
      description: The serial number of device.
      type: string
    - contextPath: CrowdStrike.Device.SystemManufacturer
      description: The system_manufacturer of device
      type: string
    - contextPath: CrowdStrike.Device.SystemProductName
      description: The system_product_name of device
      type: string
    - contextPath: CrowdStrike.Device.CPUSignature
      description: The cpu_signature of device
      type: string
    - contextPath: CrowdStrike.Device.AgentVersion
      description: The agent_version of device
      type: string
    - contextPath: CrowdStrike.Device.OSBuild
      description: The os_build of device
      type: string
    - contextPath: CrowdStrike.Device.GroupName
      description: The group name of device
      type: string
    - contextPath: CrowdStrike.Device.Version
      description: The version of device
      type: string
    - contextPath: CrowdStrike.Device.IsIsolated
      description: Device is_isolated
      type: boolean
    - contextPath: CrowdStrike.Device.Status
      description: The operational_status of device
      type: string
  dockerimage: demisto/panw-iot:1.0.0.79918
  isfetch: true
  runonce: false
  script: |
    register_module_line('PANW IoT 3rd Party Integration - CrowdstrikeFalcon', 'start', __line__())


    ''' IMPORTS '''
    import json
    import requests
    import base64
    import email
    import hashlib
    from typing import List
    from dateutil.parser import parse
    from typing import Dict, Tuple, Any, Optional, Union
    from threading import Timer

    # Disable insecure warnings
    requests.packages.urllib3.disable_warnings()

    ''' GLOBALS/PARAMS '''
    INTEGRATION_NAME = 'CrowdStrike Falcon'
    CLIENT_ID = demisto.params().get('client_id')
    SECRET = demisto.params().get('secret')
    # Remove trailing slash to prevent wrong URL path to service
    SERVER = demisto.params()['url'][:-1] if (demisto.params()['url'] and demisto.params()['url'].endswith('/')) else \
        demisto.params()['url']
    # Should we use SSL
    USE_SSL = not demisto.params().get('insecure', False)
    # How many time before the first fetch to retrieve incidents
    FETCH_TIME = demisto.params().get('fetch_time', '3 days')
    BYTE_CREDS = '{name}:{password}'.format(name=CLIENT_ID, password=SECRET).encode('utf-8')
    # Headers to be sent in requests
    HEADERS = {
        'Content-Type': 'application/json',
        'Accept': 'application/json',
        'Authorization': 'Basic {}'.format(base64.b64encode(BYTE_CREDS).decode())
    }
    # Note: True life time of token is actually 30 mins
    TOKEN_LIFE_TIME = 28
    INCIDENTS_PER_FETCH = int(demisto.params().get('incidents_per_fetch', 15))
    # Remove proxy if not set to true in params
    handle_proxy()

    ''' KEY DICTIONARY '''

    DETECTIONS_BASE_KEY_MAP = {
        'device.hostname': 'System',
        'device.cid': 'CustomerID',
        'hostinfo.domain': 'MachineDomain',
        'detection_id': 'ID',
        'created_timestamp': 'ProcessStartTime',
        'max_severity': 'MaxSeverity',
        'show_in_ui': 'ShowInUi',
        'status': 'Status'
    }

    DETECTIONS_BEHAVIORS_KEY_MAP = {
        'filename': 'FileName',
        'scenario': 'Scenario',
        'md5': 'MD5',
        'sha256': 'SHA256',
        'ioc_type': 'IOCType',
        'ioc_value': 'IOCValue',
        'cmdline': 'CommandLine',
        'user_name': 'UserName',
        'behavior_id': 'ID',
    }

    IOC_KEY_MAP = {
        'type': 'Type',
        'value': 'Value',
        'policy': 'Policy',
        'source': 'Source',
        'share_level': 'ShareLevel',
        'expiration': 'Expiration',
        'description': 'Description',
        'created_on': 'CreatedTime',
        'created_by': 'CreatedBy',
        'modified_on': 'ModifiedTime',
        'modified_by': 'ModifiedBy',
        'id': 'ID',
        'platforms': 'Platforms',
        'action': 'Action',
        'severity': 'Severity',
        'tags': 'Tags',
    }

    IOC_DEVICE_COUNT_MAP = {
        'id': 'ID',
        'type': 'Type',
        'value': 'Value',
        'device_count': 'DeviceCount'
    }

    SEARCH_DEVICE_KEY_MAP = {
        'device_id': 'ID',
        'external_ip': 'ExternalIP',
        'local_ip': 'LocalIP',
        'hostname': 'Hostname',
        'os_version': 'OS',
        'mac_address': 'MacAddress',
        'first_seen': 'FirstSeen',
        'last_seen': 'LastSeen',
        'status': 'Status',
    }

    ENDPOINT_MAP = {
        'device_id': 'ID',
        'external_ip': 'ExternalIP',
        'local_ip': 'LocalIP',
        'hostname': 'Hostname',
        'os_type': 'OS',
        'os_version': 'OSVersion',
        'mac_address': 'MacAddress',
        'provision_status': 'ProvisionStatus',
        'serial_number': 'SerialNumber',
        'system_manufacturer': 'SystemManufacturer',
        'system_product_name': 'SystemProductName',
        'cpu_signature': 'CPUSignature',
        'agent_version': 'AgentVersion',
        'os_build': 'OSBuild',
        'group_name': 'GroupName',
        'version': 'Version',
        'is_isolated': 'IsIsolated',
        'status': 'Status',
    }

    ENDPOINT_KEY_MAP = {
        'device_id': 'ID',
        'local_ip': 'IPAddress',
        'os_version': 'OS',
        'hostname': 'Hostname',
        'status': 'Status',
    }

    ''' SPLIT KEY DICTIONARY '''

    """
        Pattern:
        {
            'Path': 'Path to item',
            'NewKey': 'Value of output key',
            'Delim': 'Delimiter char',
            'Index': Split Array Index
        }
    """
    DETECTIONS_BEHAVIORS_SPLIT_KEY_MAP = [
        {
            'Path': 'parent_details.parent_process_graph_id',
            'NewKey': 'SensorID',
            'Delim': ':',
            'Index': 1
        },
        {
            'Path': 'parent_details.parent_process_graph_id',
            'NewKey': 'ParentProcessID',
            'Delim': ':',
            'Index': 2
        },
        {
            'Path': 'triggering_process_graph_id',
            'NewKey': 'ProcessID',
            'Delim': ':',
            'Index': 2
        },
    ]

    HOST_GROUP_HEADERS = ['id', 'name', 'group_type', 'description', 'assignment_rule',
                          'created_by', 'created_timestamp',
                          'modified_by', 'modified_timestamp']

    STATUS_TEXT_TO_NUM = {'New': "20",
                          'Reopened': "25",
                          'In Progress': "30",
                          'Closed': "40"}

    STATUS_NUM_TO_TEXT = {20: 'New',
                          25: 'Reopened',
                          30: 'In Progress',
                          40: 'Closed'}

    ''' HELPER FUNCTIONS '''


    def http_request(method, url_suffix, params=None, data=None, files=None, headers=HEADERS, safe=False,
                     get_token_flag=True, no_json=False, json=None, status_code=None):
        """
            A wrapper for requests lib to send our requests and handle requests and responses better.
            :param json: JSON body
            :type json ``dict`` or ``list``
            :type method: ``str``
            :param method: HTTP method for the request.
            :type url_suffix: ``str``
            :param url_suffix: The suffix of the URL (endpoint)
            :type params: ``dict``
            :param params: The URL params to be passed.
            :type data: ``str``
            :param data: The body data of the request.
            :type headers: ``dict``
            :param headers: Request headers
            :type safe: ``bool``
            :param safe: If set to true will return None in case of http error
            :type get_token_flag: ``bool``
            :param get_token_flag: If set to True will call get_token()
            :type no_json: ``bool``
            :param no_json: If set to true will not parse the content and will return the raw response object for successful
            response
            :type status_code: ``int``
            :param: status_code: The request codes to accept as OK.
            :return: Returns the http request response json
            :rtype: ``dict``
        """
        if get_token_flag:
            token = get_token()
            headers['Authorization'] = 'Bearer {}'.format(token)
        url = SERVER + url_suffix
        try:
            res = requests.request(
                method,
                url,
                verify=USE_SSL,
                params=params,
                data=data,
                headers=headers,
                files=files,
                json=json,
            )
        except requests.exceptions.RequestException as e:
            return_error(f'Error in connection to the server. Please make sure you entered the URL correctly.'
                         f' Exception is {str(e)}.')
        try:
            valid_status_codes = {200, 201, 202, 204}
            # Handling a case when we want to return an entry for 404 status code.
            if status_code:
                valid_status_codes.add(status_code)
            if res.status_code not in valid_status_codes:
                res_json = res.json()
                reason = res.reason
                resources = res_json.get('resources', {})
                if resources:
                    if isinstance(resources, list):
                        reason += f'\n{str(resources)}'
                    else:
                        for host_id, resource in resources.items():
                            errors = resource.get('errors', [])
                            if errors:
                                error_message = errors[0].get('message')
                                reason += f'\nHost ID {host_id} - {error_message}'
                elif res_json.get('errors'):
                    errors = res_json.get('errors', [])
                    for error in errors:
                        reason += f"\n{error.get('message')}"
                err_msg = 'Error in API call to CrowdStrike Falcon: code: {code} - reason: {reason}'.format(
                    code=res.status_code,
                    reason=reason
                )
                # try to create a new token
                if res.status_code == 403 and get_token_flag:
                    LOG(err_msg)
                    token = get_token(new_token=True)
                    headers['Authorization'] = 'Bearer {}'.format(token)
                    return http_request(
                        method=method,
                        url_suffix=url_suffix,
                        params=params,
                        data=data,
                        headers=headers,
                        files=files,
                        json=json,
                        safe=safe,
                        get_token_flag=False,
                        status_code=status_code,
                        no_json=no_json,
                    )
                elif safe:
                    return None
                return_error(err_msg)
            return res if no_json else res.json()
        except ValueError as exception:
            raise ValueError(
                f'Failed to parse json object from response: {exception} - {res.content}')  # type: ignore[str-bytes-safe]


    def create_entry_object(contents: Union[List[Any], Dict[str, Any]] = {}, ec: Union[List[Any], Dict[str, Any]] = None,
                            hr: str = ''):
        """
            Creates an entry object
            :type contents: ``dict``
            :param contents: Raw response to output
            :type ec: ``dict``
            :param ec: Entry context of the entry object
            :type hr: ``str``
            :param hr: Human readable
            :return: Entry object
            :rtype: ``dict``
        """
        return {
            'Type': entryTypes['note'],
            'Contents': contents,
            'ContentsFormat': formats['json'],
            'ReadableContentsFormat': formats['markdown'],
            'HumanReadable': hr,
            'EntryContext': ec
        }


    def detection_to_incident(detection):
        """
            Creates an incident of a detection.
            :type detection: ``dict``
            :param detection: Single detection object
            :return: Incident representation of a detection
            :rtype ``dict``
        """
        incident = {
            'name': 'Detection ID: ' + str(detection.get('detection_id')),
            'occurred': str(detection.get('created_timestamp')),
            'rawJSON': json.dumps(detection),
            'severity': severity_string_to_int(detection.get('max_severity_displayname'))
        }
        return incident


    def incident_to_incident_context(incident):
        """
                Creates an incident context of a incident.
                :type incident: ``dict``
                :param incident: Single detection object
                :return: Incident context representation of a incident
                :rtype ``dict``
            """
        incident_id = str(incident.get('incident_id'))
        incident_context = {
            'name': f'Incident ID: {incident_id}',
            'occurred': str(incident.get('start')),
            'rawJSON': json.dumps(incident)
        }
        return incident_context


    def severity_string_to_int(severity):
        """
            Converts a severity string to DBot score representation
            :type severity: ``str``
            :param severity: String representation of a severity
            :return: DBot score representation of the severity
            :rtype ``int``
        """
        if severity in ('Critical', 'High'):
            return 3
        elif severity in ('Medium', 'Low'):
            return 2
        return 0


    def get_trasnformed_dict(old_dict, transformation_dict):
        """
            Returns a dictionary with the same values as old_dict, with the correlating key:value in transformation_dict
            :type old_dict: ``dict``
            :param old_dict: Old dictionary to pull values from
            :type transformation_dict: ``dict``
            :param transformation_dict: Transformation dictionary that contains oldkeys:newkeys
            :return Transformed dictionart (according to transformation_dict values)
            :rtype ``dict``
        """
        new_dict = {}
        for k in list(old_dict.keys()):
            if k in transformation_dict:
                new_dict[transformation_dict[k]] = old_dict[k]
        return new_dict


    def extract_transformed_dict_with_split(old_dict, transformation_dict_arr):
        """
            Extracts new values out of old_dict using a json structure of:
            {'Path': 'Path to item', 'NewKey': 'Value of output key', 'Delim': 'Delimiter char', 'Index': Split Array Index}
        """
        new_dict = {}
        for trans_dict in transformation_dict_arr:
            try:
                val = demisto.get(old_dict, trans_dict['Path'])
                if 'split' in dir(val):
                    i = trans_dict['Index']
                    new_dict[trans_dict['NewKey']] = val.split(trans_dict['Delim'])[i]
            except Exception as ex:
                LOG('Error {exception} with: {tdict}'.format(exception=ex, tdict=trans_dict))
        return new_dict


    def get_passed_mins(start_time, end_time_str):
        """
            Returns the time passed in mins
            :param start_time: Start time in datetime
            :param end_time_str: End time in str
            :return: The passed mins in int
        """
        time_delta = start_time - datetime.fromtimestamp(end_time_str)
        return time_delta.seconds / 60


    def handle_response_errors(raw_res: dict, err_msg: str = None):
        """
        Raise exception if raw_res is empty or contains errors
        """
        if not err_msg:
            err_msg = "The server was unable to return a result, please run the command again."
        if not raw_res:
            raise DemistoException(err_msg)
        if raw_res.get('errors'):
            raise DemistoException(raw_res.get('errors'))
        return


    ''' COMMAND SPECIFIC FUNCTIONS '''


    def init_rtr_single_session(host_id: str) -> str:
        """
            Start a session with single host.
            :param host_id: Host agent ID to initialize a RTR session on.
            :return: The session ID to execute the command on
        """
        endpoint_url = '/real-time-response/entities/sessions/v1'
        body = json.dumps({
            'device_id': host_id
        })
        response = http_request('POST', endpoint_url, data=body)
        resources = response.get('resources')
        if resources and isinstance(resources, list) and isinstance(resources[0], dict):
            session_id = resources[0].get('session_id')
            if isinstance(session_id, str):
                return session_id
        raise ValueError('No session id found in the response')


    def init_rtr_batch_session(host_ids: list) -> str:
        """
            Start a session with one or more hosts
            :param host_ids: List of host agent IDâ€™s to initialize a RTR session on.
            :return: The session batch ID to execute the command on
        """
        endpoint_url = '/real-time-response/combined/batch-init-session/v1'
        body = json.dumps({
            'host_ids': host_ids
        })
        response = http_request('POST', endpoint_url, data=body)
        return response.get('batch_id')


    def refresh_session(host_id: str) -> Dict:
        """
            Refresh a session timeout on a single host.
            :param host_id: Host agent ID to run RTR command on.
            :return: Response JSON which contains errors (if exist) and retrieved resources
        """
        endpoint_url = '/real-time-response/entities/refresh-session/v1'

        body = json.dumps({
            'device_id': host_id
        })
        response = http_request('POST', endpoint_url, data=body)
        return response


    def batch_refresh_session(batch_id: str) -> None:
        """
            Batch refresh a RTR session on multiple hosts.
            :param batch_id:  Batch ID to execute the command on.
        """
        demisto.debug('Starting session refresh')
        endpoint_url = '/real-time-response/combined/batch-refresh-session/v1'

        body = json.dumps({
            'batch_id': batch_id
        })
        response = http_request('POST', endpoint_url, data=body)
        demisto.debug(f'Refresh session response: {response}')
        demisto.debug('Finished session refresh')


    def run_batch_read_cmd(batch_id: str, command_type: str, full_command: str) -> Dict:
        """
            Sends RTR command scope with read access
            :param batch_id:  Batch ID to execute the command on.
            :param command_type: Read-only command type we are going to execute, for example: ls or cd.
            :param full_command: Full command string for the command.
            :return: Response JSON which contains errors (if exist) and retrieved resources
        """
        endpoint_url = '/real-time-response/combined/batch-command/v1'

        body = json.dumps({
            'base_command': command_type,
            'batch_id': batch_id,
            'command_string': full_command
        })
        response = http_request('POST', endpoint_url, data=body)
        return response


    def run_batch_write_cmd(batch_id: str, command_type: str, full_command: str) -> Dict:
        """
            Sends RTR command scope with write access
            :param batch_id:  Batch ID to execute the command on.
            :param command_type: Read-only command type we are going to execute, for example: ls or cd.
            :param full_command: Full command string for the command.
            :return: Response JSON which contains errors (if exist) and retrieved resources
        """
        endpoint_url = '/real-time-response/combined/batch-active-responder-command/v1'

        body = json.dumps({
            'base_command': command_type,
            'batch_id': batch_id,
            'command_string': full_command
        })
        response = http_request('POST', endpoint_url, data=body)
        return response


    def run_batch_admin_cmd(batch_id: str, command_type: str, full_command: str, timeout: int = 30) -> Dict:
        """
            Sends RTR command scope with write access
            :param batch_id:  Batch ID to execute the command on.
            :param command_type: Read-only command type we are going to execute, for example: ls or cd.
            :param full_command: Full command string for the command.
            :param timeout: Timeout for how long to wait for the request in seconds.
            :return: Response JSON which contains errors (if exist) and retrieved resources
        """
        endpoint_url = '/real-time-response/combined/batch-admin-command/v1'

        params = {
            'timeout': timeout
        }

        body = json.dumps({
            'base_command': command_type,
            'batch_id': batch_id,
            'command_string': full_command
        })
        response = http_request('POST', endpoint_url, data=body, params=params)
        return response


    def run_batch_get_cmd(host_ids: list, file_path: str, optional_hosts: list = None, timeout: int = None,
                          timeout_duration: str = None) -> Dict:
        """
            Batch executes `get` command across hosts to retrieve files.
            After this call is made `/real-time-response/combined/batch-get-command/v1` is used to query for the results.
          :param host_ids: List of host agent IDâ€™s to run RTR command on.
          :param file_path: Full path to the file that is to be retrieved from each host in the batch.
          :param optional_hosts: List of a subset of hosts we want to run the command on.
                                 If this list is supplied, only these hosts will receive the command.
          :param timeout: Timeout for how long to wait for the request in seconds
          :param timeout_duration: Timeout duration for for how long to wait for the request in duration syntax
          :return: Response JSON which contains errors (if exist) and retrieved resources
        """
        endpoint_url = '/real-time-response/combined/batch-get-command/v1'
        batch_id = init_rtr_batch_session(host_ids)

        body = assign_params(batch_id=batch_id, file_path=file_path, optional_hosts=optional_hosts)
        params = assign_params(timeout=timeout, timeout_duration=timeout_duration)
        response = http_request('POST', endpoint_url, data=json.dumps(body), params=params)
        return response


    def status_get_cmd(request_id: str, timeout: int = None, timeout_duration: str = None) -> Dict:
        """
            Retrieves the status of the specified batch get command. Will return successful files when they are finished processing.
          :param request_id: ID to the request of `get` command.
          :param timeout: Timeout for how long to wait for the request in seconds
          :param timeout_duration: Timeout duration for for how long to wait for the request in duration syntax
          :return: Response JSON which contains errors (if exist) and retrieved resources
        """
        endpoint_url = '/real-time-response/combined/batch-get-command/v1'

        params = assign_params(timeout=timeout, timeout_duration=timeout_duration, batch_get_cmd_req_id=request_id)
        response = http_request('GET', endpoint_url, params=params)
        return response


    def run_single_read_cmd(host_id: str, command_type: str, full_command: str) -> Dict:
        """
            Sends RTR command scope with read access
            :param host_id: Host agent ID to run RTR command on.
            :param command_type: Active-Responder command type we are going to execute, for example: get or cp.
            :param full_command: Full command string for the command.
            :return: Response JSON which contains errors (if exist) and retrieved resources
        """
        endpoint_url = '/real-time-response/entities/command/v1'
        session_id = init_rtr_single_session(host_id)

        body = json.dumps({
            'base_command': command_type,
            'command_string': full_command,
            'session_id': session_id
        })
        response = http_request('POST', endpoint_url, data=body)
        return response


    def run_single_write_cmd(host_id: str, command_type: str, full_command: str) -> Dict:
        """
            Sends RTR command scope with write access
            :param host_id: Host agent ID to run RTR command on.
            :param command_type: Active-Responder command type we are going to execute, for example: get or cp.
            :param full_command: Full command string for the command.
            :return: Response JSON which contains errors (if exist) and retrieved resources
        """
        endpoint_url = '/real-time-response/entities/active-responder-command/v1'
        session_id = init_rtr_single_session(host_id)

        body = json.dumps({
            'base_command': command_type,
            'command_string': full_command,
            'session_id': session_id
        })
        response = http_request('POST', endpoint_url, data=body)
        return response


    def run_single_admin_cmd(host_id: str, command_type: str, full_command: str) -> Dict:
        """
            Sends RTR command scope with admin access
            :param host_id: Host agent ID to run RTR command on.
            :param command_type: Active-Responder command type we are going to execute, for example: get or cp.
            :param full_command: Full command string for the command.
            :return: Response JSON which contains errors (if exist) and retrieved resources
        """
        endpoint_url = '/real-time-response/entities/admin-command/v1'
        session_id = init_rtr_single_session(host_id)

        body = json.dumps({
            'base_command': command_type,
            'command_string': full_command,
            'session_id': session_id
        })
        response = http_request('POST', endpoint_url, data=body)
        return response


    def status_read_cmd(request_id: str, sequence_id: Optional[int]) -> Dict:
        """
            Get status of an executed command with read access on a single host.
            :param request_id: Cloud Request ID of the executed command to query
            :param sequence_id: Sequence ID that we want to retrieve. Command responses are chunked across sequences
        """
        endpoint_url = '/real-time-response/entities/command/v1'

        params = {
            'cloud_request_id': request_id,
            'sequence_id': sequence_id or 0
        }

        response = http_request('GET', endpoint_url, params=params)
        return response


    def status_write_cmd(request_id: str, sequence_id: Optional[int]) -> Dict:
        """
            Get status of an executed command with write access on a single host.
            :param request_id: Cloud Request ID of the executed command to query
            :param sequence_id: Sequence ID that we want to retrieve. Command responses are chunked across sequences
        """
        endpoint_url = '/real-time-response/entities/active-responder-command/v1'

        params = {
            'cloud_request_id': request_id,
            'sequence_id': sequence_id or 0
        }

        response = http_request('GET', endpoint_url, params=params)
        return response


    def status_admin_cmd(request_id: str, sequence_id: Optional[int]) -> Dict:
        """
            Get status of an executed command with admin access on a single host.
            :param request_id: Cloud Request ID of the executed command to query
            :param sequence_id: Sequence ID that we want to retrieve. Command responses are chunked across sequences
        """
        endpoint_url = '/real-time-response/entities/admin-command/v1'

        params = {
            'cloud_request_id': request_id,
            'sequence_id': sequence_id or 0
        }

        response = http_request('GET', endpoint_url, params=params)
        return response


    def list_host_files(host_id: str) -> Dict:
        """
            Get a list of files for the specified RTR session on a host.
            :param host_id: Host agent ID to run RTR command on.
            :return: Response JSON which contains errors (if exist) and retrieved resources
        """
        endpoint_url = '/real-time-response/entities/file/v1'
        session_id = init_rtr_single_session(host_id)

        params = {
            'session_id': session_id
        }
        response = http_request('GET', endpoint_url, params=params)
        return response


    def upload_script(name: str, permission_type: str, content: str, entry_id: str) -> Dict:
        """
            Uploads a script by either given content or file
            :param name: Script name to upload
            :param permission_type: Permissions type of script to upload
            :param content: PowerShell script content
            :param entry_id: Script file to upload
            :return: Response JSON which contains errors (if exist) and how many resources were affected
        """
        endpoint_url = '/real-time-response/entities/scripts/v1'
        body: Dict[str, Tuple[Any, Any]] = {
            'name': (None, name),
            'permission_type': (None, permission_type)
        }
        temp_file = None
        try:
            if content:
                body['content'] = (None, content)
            else:  # entry_id was provided
                file_ = demisto.getFilePath(entry_id)
                file_name = file_.get('name')  # pylint: disable=E1101
                temp_file = open(file_.get('path'), 'rb')  # pylint: disable=E1101
                body['file'] = (file_name, temp_file)

            headers = {
                'Authorization': HEADERS['Authorization'],
                'Accept': 'application/json'
            }

            response = http_request('POST', endpoint_url, files=body, headers=headers)

            return response
        finally:
            if temp_file:
                temp_file.close()


    def get_script(script_id: list) -> Dict:
        """
            Retrieves a script given its ID
            :param script_id: ID of script to get
            :return: Response JSON which contains errors (if exist) and retrieved resource
        """
        endpoint_url = '/real-time-response/entities/scripts/v1'
        params = {
            'ids': script_id
        }
        response = http_request('GET', endpoint_url, params=params)
        return response


    def delete_script(script_id: str) -> Dict:
        """
            Deletes a script given its ID
            :param script_id: ID of script to delete
            :return: Response JSON which contains errors (if exist) and how many resources were affected
        """
        endpoint_url = '/real-time-response/entities/scripts/v1'
        params = {
            'ids': script_id
        }
        response = http_request('DELETE', endpoint_url, params=params)
        return response


    def list_scripts() -> Dict:
        """
            Retrieves list of scripts
            :return: Response JSON which contains errors (if exist) and retrieved resources
        """
        endpoint_url = '/real-time-response/entities/scripts/v1'
        response = http_request('GET', endpoint_url)
        return response


    def get_extracted_file(host_id: str, sha256: str, filename: str = None):
        """
            Get RTR extracted file contents for specified session and sha256.
            :param host_id: The host agent ID to initialize the RTR session on.
            :param sha256: Extracted SHA256
            :param filename: Filename to use for the archive name and the file within the archive.
        """
        endpoint_url = '/real-time-response/entities/extracted-file-contents/v1'
        session_id = init_rtr_single_session(host_id)
        params = {
            'session_id': session_id,
            'sha256': sha256
        }
        if filename:
            params['filename'] = filename

        response = http_request('GET', endpoint_url, params=params, no_json=True)
        return response


    def upload_file(entry_id: str, description: str) -> Tuple:
        """
            Uploads a file given entry ID
            :param entry_id: The entry ID of the file to upload
            :param description: String description of file to upload
            :return: Response JSON which contains errors (if exist) and how many resources were affected and the file name
        """
        endpoint_url = '/real-time-response/entities/put-files/v1'
        temp_file = None
        try:
            file_ = demisto.getFilePath(entry_id)
            file_name = file_.get('name')  # pylint: disable=E1101
            temp_file = open(file_.get('path'), 'rb')  # pylint: disable=E1101
            body = {
                'name': (None, file_name),
                'description': (None, description),
                'file': (file_name, temp_file)
            }
            headers = {
                'Authorization': HEADERS['Authorization'],
                'Accept': 'application/json'
            }
            response = http_request('POST', endpoint_url, files=body, headers=headers)
            return response, file_name
        finally:
            if temp_file:
                temp_file.close()


    def delete_file(file_id: str) -> Dict:
        """
            Delete a put-file based on the ID given
            :param file_id: ID of file to delete
            :return: Response JSON which contains errors (if exist) and how many resources were affected
        """
        endpoint_url = '/real-time-response/entities/put-files/v1'
        params = {
            'ids': file_id
        }
        response = http_request('DELETE', endpoint_url, params=params)
        return response


    def get_file(file_id: list) -> Dict:
        """
            Get put-files based on the ID's given
            :param file_id: ID of file to get
            :return: Response JSON which contains errors (if exist) and retrieved resources
        """
        endpoint_url = '/real-time-response/entities/put-files/v1'
        params = {
            'ids': file_id
        }
        response = http_request('GET', endpoint_url, params=params)
        return response


    def list_files() -> Dict:
        """
            Get a list of put-file ID's that are available to the user for the put command.
            :return: Response JSON which contains errors (if exist) and retrieved resources
        """
        endpoint_url = '/real-time-response/entities/put-files/v1'
        response = http_request('GET', endpoint_url)
        return response


    def get_token(new_token=False):
        """
            Retrieves the token from the server if it's expired and updates the global HEADERS to include it
            :param new_token: If set to True will generate a new token regardless of time passed
            :rtype: ``str``
            :return: Token
        """
        now = datetime.now()
        ctx = demisto.getIntegrationContext()
        if ctx and not new_token:
            passed_mins = get_passed_mins(now, ctx.get('time'))
            if passed_mins >= TOKEN_LIFE_TIME:
                # token expired
                auth_token = get_token_request()
                demisto.setIntegrationContext({'auth_token': auth_token, 'time': date_to_timestamp(now) / 1000})
            else:
                # token hasn't expired
                auth_token = ctx.get('auth_token')
        else:
            # there is no token
            auth_token = get_token_request()
            demisto.setIntegrationContext({'auth_token': auth_token, 'time': date_to_timestamp(now) / 1000})
        return auth_token


    def get_token_request():
        """
            Sends token request
            :rtype ``str``
            :return: Access token
        """
        body = {
            'client_id': CLIENT_ID,
            'client_secret': SECRET
        }
        headers = {
            'Content-Type': 'application/x-www-form-urlencoded'
        }
        token_res = http_request('POST', '/oauth2/token', data=body, headers=headers, safe=True,
                                 get_token_flag=False)
        if not token_res:
            err_msg = 'Authorization Error: User has no authorization to create a token. Please make sure you entered the' \
                      ' credentials correctly.'
            raise Exception(err_msg)
        return token_res.get('access_token')


    def get_detections(last_behavior_time=None, behavior_id=None, filter_arg=None):
        """
            Sends detections request. The function will ignore the arguments passed according to priority:
            filter_arg > behavior_id > last_behavior_time
            :param last_behavior_time: 3rd priority. The last behavior time of results will be greater than this value
            :param behavior_id: 2nd priority. The result will only contain the detections with matching behavior id
            :param filter_arg: 1st priority. The result will be filtered using this argument.
            :return: Response json of the get detection endpoint (IDs of the detections)
        """
        endpoint_url = '/detects/queries/detects/v1'
        params = {
            'sort': 'first_behavior.asc'
        }
        if filter_arg:
            params['filter'] = filter_arg
        elif behavior_id:
            params['filter'] = "behaviors.behavior_id:'{0}'".format(behavior_id)
        elif last_behavior_time:
            params['filter'] = "first_behavior:>'{0}'".format(last_behavior_time)

        response = http_request('GET', endpoint_url, params)
        return response


    def get_fetch_detections(last_created_timestamp=None, filter_arg=None, offset: int = 0):
        """ Sends detection request, based on the created_timestamp field. Used for fetch-incidents
        Args:
            last_created_timestamp: last created timestamp of the results will be greater than this value.
            filter_arg: The result will be filtered using this argument.
        Returns:
            Response json of the get detection endpoint (IDs of the detections)
        """
        endpoint_url = '/detects/queries/detects/v1'
        params = {
            'sort': 'first_behavior.asc',
            'offset': offset,
            'limit': INCIDENTS_PER_FETCH
        }
        if filter_arg:
            params['filter'] = filter_arg

        elif last_created_timestamp:
            params['filter'] = "created_timestamp:>'{0}'".format(last_created_timestamp)

        response = http_request('GET', endpoint_url, params)

        return response


    def get_detections_entities(detections_ids):
        """
            Sends detection entities request
            :param detections_ids: IDs of the requested detections.
            :return: Response json of the get detection entities endpoint (detection objects)
        """
        ids_json = {'ids': detections_ids}
        if detections_ids:
            response = http_request(
                'POST',
                '/detects/entities/summaries/GET/v1',
                data=json.dumps(ids_json)
            )
            return response
        return detections_ids


    def get_incidents_ids(last_created_timestamp=None, filter_arg=None, offset: int = 0):
        get_incidents_endpoint = '/incidents/queries/incidents/v1'
        params = {
            'sort': 'start.asc',
            'offset': offset,
            'limit': INCIDENTS_PER_FETCH
        }
        if filter_arg:
            params['filter'] = filter_arg

        elif last_created_timestamp:
            params['filter'] = "start:>'{0}'".format(last_created_timestamp)

        response = http_request('GET', get_incidents_endpoint, params)

        return response


    def get_incidents_entities(incidents_ids):
        ids_json = {'ids': incidents_ids}
        response = http_request(
            'POST',
            '/incidents/entities/incidents/GET/v1',
            data=json.dumps(ids_json)
        )
        return response


    def upload_ioc(ioc_type, value, policy=None, expiration_days=None,
                   share_level=None, description=None, source=None):
        """
        Create a new IOC (or replace an existing one)
        """
        payload = assign_params(
            type=ioc_type,
            value=value,
            policy=policy,
            share_level=share_level,
            expiration_days=expiration_days,
            source=source,
            description=description,
        )

        return http_request('POST', '/indicators/entities/iocs/v1', json=[payload])


    def update_ioc(ioc_type, value, policy=None, expiration_days=None,
                   share_level=None, description=None, source=None):
        """
        Update an existing IOC
        """
        body = assign_params(
            type=ioc_type,
            value=value,
            policy=policy,
            share_level=share_level,
            expiration_days=expiration_days,
            source=source,
            description=description,
        )
        params = assign_params(
            type=ioc_type,
            value=value
        )

        return http_request('PATCH', '/indicators/entities/iocs/v1', json=body, params=params)


    def search_iocs(types=None, values=None, policies=None, sources=None, expiration_from=None,
                    expiration_to=None, limit=None, share_levels=None, ids=None, sort=None, offset=None):
        """
        :param types: A list of indicator types. Separate multiple types by comma.
        :param values: Comma-separated list of indicator values
        :param policies: Comma-separated list of indicator policies
        :param sources: Comma-separated list of IOC sources
        :param expiration_from: Start of date range to search (YYYY-MM-DD format).
        :param expiration_to: End of date range to search (YYYY-MM-DD format).
        :param share_levels: A list of share levels. Only red is supported.
        :param limit: The maximum number of records to return. The minimum is 1 and the maximum is 500. Default is 100.
        :param sort: The order of the results. Format
        :param offset: The offset to begin the list from
        """
        if not ids:
            payload = assign_params(
                types=argToList(types),
                values=argToList(values),
                policies=argToList(policies),
                sources=argToList(sources),
                share_levels=argToList(share_levels),
                sort=sort,
                offset=offset,
                limit=limit or '50',
            )
            if expiration_from:
                payload['from.expiration_timestamp'] = expiration_from
            if expiration_to:
                payload['to.expiration_timestamp'] = expiration_to

            ids = http_request('GET', '/indicators/queries/iocs/v1', payload).get('resources')
            if not ids:
                return None
        else:
            ids = str(ids)
        payload = {
            'ids': ids
        }
        return http_request('GET', '/indicators/entities/iocs/v1', params=payload)


    def enrich_ioc_dict_with_ids(ioc_dict):
        """
            Enriches the provided ioc_dict with IOC ID
            :param ioc_dict: IOC dict transformed using the SEARCH_IOC_KEY_MAP
            :return: ioc_dict with its ID key:value updated
        """
        for ioc in ioc_dict:
            ioc['ID'] = '{type}:{val}'.format(type=ioc.get('Type'), val=ioc.get('Value'))
        return ioc_dict


    def delete_ioc(ioc_type, value):
        """
        Delete an IOC
        """
        payload = assign_params(
            type=ioc_type,
            value=value
        )
        return http_request('DELETE', '/indicators/entities/iocs/v1', payload)


    def search_custom_iocs(
        types: Optional[Union[list, str]] = None,
        values: Optional[Union[list, str]] = None,
        sources: Optional[Union[list, str]] = None,
        expiration: Optional[str] = None,
        limit: str = '50',
        sort: Optional[str] = None,
        offset: Optional[str] = None,
    ) -> dict:
        """
        :param types: A list of indicator types. Separate multiple types by comma.
        :param values: Comma-separated list of indicator values
        :param sources: Comma-separated list of IOC sources
        :param expiration: The date on which the indicator will become inactive. (YYYY-MM-DD format).
        :param limit: The maximum number of records to return. The minimum is 1 and the maximum is 500. Default is 100.
        :param sort: The order of the results. Format
        :param offset: The offset to begin the list from
        """
        filter_list = []
        if types:
            filter_list.append(f'type:{types}')
        if values:
            filter_list.append(f'value:{values}')
        if sources:
            filter_list.append(f'source:{sources}')
        if expiration:
            filter_list.append(f'expiration:"{expiration}"')

        params = {
            'filter': '+'.join(filter_list),
            'sort': sort,
            'offset': offset,
            'limit': limit,
        }

        return http_request('GET', '/iocs/combined/indicator/v1', params=params)


    def get_custom_ioc(ioc_id: str) -> dict:
        params = {'ids': ioc_id}
        return http_request('GET', '/iocs/entities/indicators/v1', params=params)


    def upload_custom_ioc(
        ioc_type: str,
        value: str,
        action: str,
        platforms: str,
        severity: Optional[str] = None,
        source: Optional[str] = None,
        description: Optional[str] = None,
        expiration: Optional[str] = None,
        applied_globally: Optional[bool] = None,
        host_groups: Optional[List[str]] = None,
    ) -> dict:
        """
        Create a new IOC (or replace an existing one)
        """
        payload = {
            'indicators': [assign_params(
                type=ioc_type,
                value=value,
                action=action,
                platforms=platforms,
                severity=severity,
                source=source,
                description=description,
                expiration=expiration,
                applied_globally=applied_globally,
                host_groups=host_groups,
            )]
        }

        return http_request('POST', '/iocs/entities/indicators/v1', json=payload)


    def update_custom_ioc(
        ioc_id: str,
        action: Optional[str] = None,
        platforms: Optional[str] = None,
        severity: Optional[str] = None,
        source: Optional[str] = None,
        description: Optional[str] = None,
        expiration: Optional[str] = None,
    ) -> dict:
        """
        Update an IOC
        """
        payload = {
            'indicators': [{
                'id': ioc_id,
            } | assign_params(
                action=action,
                platforms=platforms,
                severity=severity,
                source=source,
                description=description,
                expiration=expiration,
            )]
        }

        return http_request('PATCH', '/iocs/entities/indicators/v1', json=payload)


    def delete_custom_ioc(ids: str) -> dict:
        """
        Delete an IOC
        """
        params = {'ids': ids}
        return http_request('DELETE', '/iocs/entities/indicators/v1', params=params)


    def get_ioc_device_count(ioc_type, value):
        """
        Gets the devices that encountered the IOC
        """
        payload = assign_params(
            type=ioc_type,
            value=value
        )
        response = http_request('GET', '/indicators/aggregates/devices-count/v1', payload, status_code=404)
        errors = response.get('errors', [])
        for error in errors:
            if error.get('code') == 404:
                return f'No results found for {ioc_type} - {value}'
        return response


    def get_process_details(ids):
        """
        Get given processes details
        """
        payload = assign_params(ids=ids)
        return http_request('GET', '/processes/entities/processes/v1', payload)


    def get_proccesses_ran_on(ioc_type, value, device_id):
        """
        Get processes ids that ran on the given device_id that encountered the ioc
        """
        payload = assign_params(
            type=ioc_type,
            value=value,
            device_id=device_id
        )
        return http_request('GET', '/indicators/queries/processes/v1', payload)


    def search_device():
        """
            Searches for devices using the argument provided by the command execution. Returns empty
            result of no device was found
            :return: Search device response json
        """
        args = demisto.args()
        input_arg_dict = {
            'device_id': str(args.get('ids', '')).split(','),
            'status': str(args.get('status', '')).split(','),
            'hostname': str(args.get('hostname', '')).split(','),
            'platform_name': str(args.get('platform_name', '')).split(','),
            'site_name': str(args.get('site_name', '')).split(',')
        }
        url_filter = '{}'.format(str(args.get('filter', '')))
        for k, arg in input_arg_dict.items():
            if arg:
                if type(arg) is list:
                    arg_filter = ''
                    for arg_elem in arg:
                        if arg_elem:
                            first_arg = '{filter},{inp_arg}'.format(filter=arg_filter, inp_arg=k) if arg_filter else k
                            arg_filter = "{first}:'{second}'".format(first=first_arg, second=arg_elem)
                    if arg_filter:
                        url_filter = "{url_filter}{arg_filter}".format(url_filter=url_filter + '+' if url_filter else '',
                                                                       arg_filter=arg_filter)
                else:
                    # All args should be a list. this is a fallback
                    url_filter = "{url_filter}+{inp_arg}:'{arg_val}'".format(url_filter=url_filter, inp_arg=k, arg_val=arg)

        raw_res = http_request('GET', '/devices/queries/devices/v1', params={'filter': url_filter})
        device_ids = raw_res.get('resources')
        if not device_ids:
            return None
        return http_request('GET', '/devices/entities/devices/v1', params={'ids': device_ids})

    def search_device_by_mac_address():
        """
            Searches for devices using the argument provided by the command execution. Returns empty
            result of no device was found
            :return: Search device response json
        """
        filter_list=''
        args = demisto.args()
        mac_address_list = args.get('mac_address','')
        mac_address_filter = 'mac_address:' + str(mac_address_list)
        if len(mac_address_list) > 0:
            filter_list = mac_address_filter
        local_ip_list = args.get('local_ip','')
        local_ip_filter = 'local_ip:' + str(local_ip_list)
        if len(local_ip_list) > 0:
            filter_list = local_ip_filter
        if len(mac_address_list) > 0 and len(local_ip_list) > 0:
            filter_list=mac_address_filter + ',' + local_ip_filter
        raw_res = http_request('GET', '/devices/queries/devices/v1',params={'filter':filter_list})

        device_ids = raw_res.get('resources')
        if not device_ids:
            return None
        return http_request('GET', '/devices/entities/devices/v1', params={'ids': device_ids})


    def behavior_to_entry_context(behavior):
        """
            Transforms a behavior to entry context representation
            :param behavior: Behavior dict in the format of crowdstrike's API response
            :return: Behavior in entry context representation
        """
        raw_entry = get_trasnformed_dict(behavior, DETECTIONS_BEHAVIORS_KEY_MAP)
        raw_entry.update(extract_transformed_dict_with_split(behavior, DETECTIONS_BEHAVIORS_SPLIT_KEY_MAP))
        return raw_entry


    def get_username_uuid(username: str):
        """
        Obtain CrowdStrike userâ€™s UUId by email.
        :param username: Username to get UUID of.
        :return: The user UUID
        """
        response = http_request('GET', '/users/queries/user-uuids-by-email/v1', params={'uid': username})
        resources: list = response.get('resources', [])
        if not resources:
            raise ValueError(f'User {username} was not found')
        return resources[0]


    def resolve_detection(ids, status, assigned_to_uuid, show_in_ui, comment):
        """
            Sends a resolve detection request
            :param ids: Single or multiple ids in an array string format
            :param status: New status of the detection
            :param assigned_to_uuid: uuid to assign the detection to
            :param show_in_ui: Boolean flag in string format (true/false)
            :param comment: Optional comment to add to the detection
            :return: Resolve detection response json
        """
        payload = {
            'ids': ids
        }
        if status:
            payload['status'] = status
        if assigned_to_uuid:
            payload['assigned_to_uuid'] = assigned_to_uuid
        if show_in_ui:
            payload['show_in_ui'] = show_in_ui
        if comment:
            payload['comment'] = comment
        # We do this so show_in_ui value won't contain ""
        data = json.dumps(payload).replace('"show_in_ui": "false"', '"show_in_ui": false').replace('"show_in_ui": "true"',
                                                                                                   '"show_in_ui": true')
        return http_request('PATCH', '/detects/entities/detects/v2', data=data)


    def contain_host(ids):
        """
            Contains host(s) with matching ids
            :param ids: IDs of host to contain
            :return: Contain host response json
        """
        payload = {
            'ids': ids
        }
        data = json.dumps(payload)
        params = {
            'action_name': 'contain'
        }
        return http_request('POST', '/devices/entities/devices-actions/v2', data=data, params=params)


    def lift_host_containment(ids):
        """
            Lifts off containment from host(s) with matchind ids
            :param ids: IDs of host to lift off containment from
            :return: Lift off containment response json
        """
        payload = {
            'ids': ids
        }
        data = json.dumps(payload)
        params = {
            'action_name': 'lift_containment'
        }
        return http_request('POST', '/devices/entities/devices-actions/v2', data=data, params=params)


    def timestamp_length_equalization(timestamp1, timestamp2):
        """
            Makes sure the timestamps are of the same length.
        Args:
            timestamp1: First timestamp to compare.
            timestamp2: Second timestamp to compare.
        Returns:
            the two timestamps in the same length (the longer one)
        """
        diff_len = len(str(timestamp1)) - len(str(timestamp2))

        # no difference in length
        if diff_len == 0:
            return int(timestamp1), int(timestamp2)

        # length of timestamp1 > timestamp2
        if diff_len > 0:
            ten_times = pow(10, diff_len)
            timestamp2 = int(timestamp2) * ten_times

        # length of timestamp2 > timestamp1
        else:
            ten_times = pow(10, diff_len * -1)
            timestamp1 = int(timestamp1) * ten_times

        return int(timestamp1), int(timestamp2)


    def change_host_group(is_post: bool,
                          host_group_id: Optional[str] = None,
                          name: Optional[str] = None,
                          group_type: Optional[str] = None,
                          description: Optional[str] = None,
                          assignment_rule: Optional[str] = None) -> Dict:
        method = 'POST' if is_post else 'PATCH'
        data = {'resources': [{
            'id': host_group_id,
            "name": name,
            "description": description,
            "group_type": group_type,
            "assignment_rule": assignment_rule
        }]}
        response = http_request(method=method,
                                url_suffix='/devices/entities/host-groups/v1',
                                json=data)
        return response


    def change_host_group_members(action_name: str,
                                  host_group_id: str,
                                  host_ids: List[str]) -> Dict:
        allowed_actions = {'add-hosts', 'remove-hosts'}
        if action_name not in allowed_actions:
            raise DemistoException(f'CrowdStrike Falcon error: action name should be in {allowed_actions}')
        data = {'action_parameters': [{'name': 'filter',
                                       'value': f"(device_id:{str(host_ids)})"}],
                'ids': [host_group_id]}
        response = http_request(method='POST',
                                url_suffix='/devices/entities/host-group-actions/v1',
                                params={'action_name': action_name},
                                json=data)
        return response


    def host_group_members(filter: Optional[str],
                           host_group_id: Optional[str],
                           limit: Optional[str],
                           offset: Optional[str]):
        params = {'id': host_group_id,
                  'filter': filter,
                  'offset': offset,
                  'limit': limit}
        response = http_request(method='GET',
                                url_suffix='/devices/combined/host-group-members/v1',
                                params=params)
        return response


    def resolve_incident(ids: List[str], status: str):
        if status not in STATUS_TEXT_TO_NUM:
            raise DemistoException(f'CrowdStrike Falcon Error: '
                                   f'Status given is {status} and it is not in {STATUS_TEXT_TO_NUM.keys()}')
        data = {
            "action_parameters": [
                {
                    "name": "update_status",
                    "value": STATUS_TEXT_TO_NUM[status]
                }
            ],
            "ids": ids
        }
        http_request(method='POST',
                     url_suffix='/incidents/entities/incident-actions/v1',
                     json=data)


    def list_host_groups(filter: Optional[str], limit: Optional[str], offset: Optional[str]) -> Dict:
        params = {'filter': filter,
                  'offset': offset,
                  'limit': limit}
        response = http_request(method='GET',
                                url_suffix='/devices/combined/host-groups/v1',
                                params=params)
        return response


    def delete_host_groups(host_group_ids: List[str]) -> Dict:
        params = {'ids': host_group_ids}
        response = http_request(method='DELETE',
                                url_suffix='/devices/entities/host-groups/v1',
                                params=params)
        return response


    ''' COMMANDS FUNCTIONS '''


    def get_fetch_times_and_offset(incident_type):
        last_run = demisto.getLastRun()
        last_fetch_time = last_run.get(f'first_behavior_{incident_type}_time')
        offset = last_run.get(f'{incident_type}_offset', 0)
        if not last_fetch_time:
            last_fetch_time, _ = parse_date_range(FETCH_TIME, date_format='%Y-%m-%dT%H:%M:%SZ')
        prev_fetch = last_fetch_time
        last_fetch_timestamp = int(parse(last_fetch_time).timestamp() * 1000)
        return last_fetch_time, offset, prev_fetch, last_fetch_timestamp


    def fetch_incidents():
        incidents = []  # type:List
        current_fetch_info = demisto.getLastRun()
        fetch_incidents_or_detections = demisto.params().get('fetch_incidents_or_detections')

        if 'Detections' in fetch_incidents_or_detections:
            incident_type = 'detection'
            last_fetch_time, offset, prev_fetch, last_fetch_timestamp = get_fetch_times_and_offset(incident_type)

            fetch_query = demisto.params().get('fetch_query')
            if fetch_query:
                fetch_query = "created_timestamp:>'{time}'+{query}".format(time=last_fetch_time, query=fetch_query)
                detections_ids = demisto.get(get_fetch_detections(filter_arg=fetch_query, offset=offset), 'resources')
            else:
                detections_ids = demisto.get(get_fetch_detections(last_created_timestamp=last_fetch_time, offset=offset),
                                             'resources')

            if detections_ids:
                raw_res = get_detections_entities(detections_ids)

                if "resources" in raw_res:
                    for detection in demisto.get(raw_res, "resources"):
                        detection['incident_type'] = incident_type
                        incident = detection_to_incident(detection)
                        incident_date = incident['occurred']

                        incident_date_timestamp = int(parse(incident_date).timestamp() * 1000)

                        # make sure that the two timestamps are in the same length
                        if len(str(incident_date_timestamp)) != len(str(last_fetch_timestamp)):
                            incident_date_timestamp, last_fetch_timestamp = timestamp_length_equalization(
                                incident_date_timestamp, last_fetch_timestamp)

                        # Update last run and add incident if the incident is newer than last fetch
                        if incident_date_timestamp > last_fetch_timestamp:
                            last_fetch_time = incident_date
                            last_fetch_timestamp = incident_date_timestamp

                        incidents.append(incident)

                if len(incidents) == INCIDENTS_PER_FETCH:
                    current_fetch_info['first_behavior_detection_time'] = prev_fetch
                    current_fetch_info['detection_offset'] = offset + INCIDENTS_PER_FETCH
                else:
                    current_fetch_info['first_behavior_detection_time'] = last_fetch_time
                    current_fetch_info['detection_offset'] = 0

        if 'Incidents' in fetch_incidents_or_detections:
            incident_type = 'incident'

            last_fetch_time, offset, prev_fetch, last_fetch_timestamp = get_fetch_times_and_offset(incident_type)
            last_run = demisto.getLastRun()
            last_incident_fetched = last_run.get('last_fetched_incident')
            new_last_incident_fetched = ''

            fetch_query = demisto.params().get('incidents_fetch_query')

            if fetch_query:
                fetch_query = "start:>'{time}'+{query}".format(time=last_fetch_time, query=fetch_query)
                incidents_ids = demisto.get(get_incidents_ids(filter_arg=fetch_query, offset=offset), 'resources')

            else:
                incidents_ids = demisto.get(get_incidents_ids(last_created_timestamp=last_fetch_time, offset=offset),
                                            'resources')

            if incidents_ids:
                raw_res = get_incidents_entities(incidents_ids)
                if "resources" in raw_res:
                    for incident in demisto.get(raw_res, "resources"):
                        incident['incident_type'] = incident_type
                        incident_to_context = incident_to_incident_context(incident)
                        incident_date = incident_to_context['occurred']

                        incident_date_timestamp = int(parse(incident_date).timestamp() * 1000)

                        # make sure that the two timestamps are in the same length
                        if len(str(incident_date_timestamp)) != len(str(last_fetch_timestamp)):
                            incident_date_timestamp, last_fetch_timestamp = timestamp_length_equalization(
                                incident_date_timestamp, last_fetch_timestamp)

                        # Update last run and add incident if the incident is newer than last fetch
                        if incident_date_timestamp > last_fetch_timestamp:
                            last_fetch_time = incident_date
                            last_fetch_timestamp = incident_date_timestamp
                            new_last_incident_fetched = incident.get('incident_id')

                        if last_incident_fetched != incident.get('incident_id'):
                            incidents.append(incident_to_context)

                if len(incidents) == INCIDENTS_PER_FETCH:
                    current_fetch_info['first_behavior_incident_time'] = prev_fetch
                    current_fetch_info['incident_offset'] = offset + INCIDENTS_PER_FETCH
                    current_fetch_info['last_fetched_incident'] = new_last_incident_fetched
                else:
                    current_fetch_info['first_behavior_incident_time'] = last_fetch_time
                    current_fetch_info['incident_offset'] = 0
                    current_fetch_info['last_fetched_incident'] = new_last_incident_fetched

        demisto.setLastRun(current_fetch_info)
        return incidents


    def upload_ioc_command(ioc_type=None, value=None, policy=None, expiration_days=None,
                           share_level=None, description=None, source=None):
        """
        :param ioc_type: The type of the indicator:
        :param policy :The policy to enact when the value is detected on a host.
        :param share_level: The level at which the indicator will be shared.
        :param expiration_days: This represents the days the indicator should be valid for.
        :param source: The source where this indicator originated.
        :param description: A meaningful description of the indicator.
        :param value: The string representation of the indicator.
        """
        raw_res = upload_ioc(ioc_type, value, policy, expiration_days, share_level, description, source)
        handle_response_errors(raw_res)
        iocs = search_iocs(ids=f"{ioc_type}:{value}").get('resources')
        if not iocs:
            raise DemistoException("Failed to create IOC. Please try again.")
        ec = [get_trasnformed_dict(iocs[0], IOC_KEY_MAP)]
        enrich_ioc_dict_with_ids(ec)
        return create_entry_object(contents=raw_res, ec={'CrowdStrike.IOC(val.ID === obj.ID)': ec},
                                   hr=tableToMarkdown('Custom IOC was created successfully', ec))


    def update_ioc_command(ioc_type=None, value=None, policy=None, expiration_days=None,
                           share_level=None, description=None, source=None):
        """
        :param ioc_type: The type of the indicator:
        :param policy :The policy to enact when the value is detected on a host.
        :param share_level: The level at which the indicator will be shared.
        :param expiration_days: This represents the days the indicator should be valid for.
        :param source: The source where this indicator originated.
        :param description: A meaningful description of the indicator.
        :param value: The string representation of the indicator.
        """
        raw_res = update_ioc(ioc_type, value, policy, expiration_days, share_level, description, source)
        handle_response_errors(raw_res)
        iocs = search_iocs(ids=f"{ioc_type}:{value}").get('resources')
        ec = [get_trasnformed_dict(iocs[0], IOC_KEY_MAP)]
        enrich_ioc_dict_with_ids(ec)
        return create_entry_object(contents=raw_res, ec={'CrowdStrike.IOC(val.ID === obj.ID)': ec},
                                   hr=tableToMarkdown('Custom IOC was created successfully', ec))


    def search_iocs_command(types=None, values=None, policies=None, sources=None, from_expiration_date=None,
                            to_expiration_date=None, share_levels=None, limit=None, sort=None, offset=None):
        """
        :param types: A list of indicator types. Separate multiple types by comma.
        :param values: Comma-separated list of indicator values
        :param policies: Comma-separated list of indicator policies
        :param sources: Comma-separated list of IOC sources
        :param from_expiration_date: Start of date range to search (YYYY-MM-DD format).
        :param to_expiration_date: End of date range to search (YYYY-MM-DD format).
        :param share_levels: A list of share levels. Only red is supported.
        :param limit: The maximum number of records to return. The minimum is 1 and the maximum is 500. Default is 100.
        :param sort: The order of the results. Format
        :param offset: The offset to begin the list from
        """
        raw_res = search_iocs(types=types, values=values, policies=policies, sources=sources, sort=sort, offset=offset,
                              expiration_from=from_expiration_date, expiration_to=to_expiration_date,
                              share_levels=share_levels, limit=limit)
        if not raw_res:
            return create_entry_object(hr='Could not find any Indicators of Compromise.')
        handle_response_errors(raw_res)
        iocs = raw_res.get('resources')
        ec = [get_trasnformed_dict(ioc, IOC_KEY_MAP) for ioc in iocs]
        enrich_ioc_dict_with_ids(ec)
        return create_entry_object(contents=raw_res, ec={'CrowdStrike.IOC(val.ID === obj.ID)': ec},
                                   hr=tableToMarkdown('Indicators of Compromise', ec))


    def get_ioc_command(ioc_type: str, value: str):
        """
        :param ioc_type: The type of the indicator
        :param value: The IOC value to retrieve
        """
        raw_res = search_iocs(ids=f"{ioc_type}:{value}")
        handle_response_errors(raw_res, 'Could not find any Indicators of Compromise.')
        iocs = raw_res.get('resources')
        ec = [get_trasnformed_dict(ioc, IOC_KEY_MAP) for ioc in iocs]
        enrich_ioc_dict_with_ids(ec)
        return create_entry_object(contents=raw_res, ec={'CrowdStrike.IOC(val.ID === obj.ID)': ec},
                                   hr=tableToMarkdown('Indicator of Compromise', ec))


    def delete_ioc_command(ioc_type, value):
        """
        :param ioc_type: The type of the indicator
        :param value: The IOC value to delete
        """
        raw_res = delete_ioc(ioc_type, value)
        handle_response_errors(raw_res, "The server has not confirmed deletion, please manually confirm deletion.")
        ids = f"{ioc_type}:{value}"
        return create_entry_object(contents=raw_res, hr=f"Custom IOC {ids} was successfully deleted.")


    def search_custom_iocs_command(
        types: Optional[Union[list, str]] = None,
        values: Optional[Union[list, str]] = None,
        sources: Optional[Union[list, str]] = None,
        expiration: Optional[str] = None,
        limit: str = '50',
        sort: Optional[str] = None,
        offset: Optional[str] = None,
    ) -> dict:
        """
        :param types: A list of indicator types. Separate multiple types by comma.
        :param values: Comma-separated list of indicator values
        :param sources: Comma-separated list of IOC sources
        :param expiration: The date on which the indicator will become inactive. (YYYY-MM-DD format).
        :param limit: The maximum number of records to return. The minimum is 1 and the maximum is 500. Default is 100.
        :param sort: The order of the results. Format
        :param offset: The offset to begin the list from
        """
        raw_res = search_custom_iocs(
            types=argToList(types),
            values=argToList(values),
            sources=argToList(sources),
            sort=sort,
            offset=offset,
            expiration=expiration,
            limit=limit,
        )
        iocs = raw_res.get('resources')
        if not iocs:
            return create_entry_object(hr='Could not find any Indicators of Compromise.')
        handle_response_errors(raw_res)
        ec = [get_trasnformed_dict(ioc, IOC_KEY_MAP) for ioc in iocs]
        return create_entry_object(
            contents=raw_res,
            ec={'CrowdStrike.IOC(val.ID === obj.ID)': ec},
            hr=tableToMarkdown('Indicators of Compromise', ec),
        )


    def get_custom_ioc_command(
        ioc_type: Optional[str] = None,
        value: Optional[str] = None,
        ioc_id: Optional[str] = None,
    ) -> dict:
        """
        :param ioc_type: IOC type
        :param value: IOC value
        :param ioc_id: IOC ID
        """

        if not ioc_id and not (ioc_type and value):
            raise ValueError('Either ioc_id or ioc_type and value must be provided.')

        if ioc_id:
            raw_res = get_custom_ioc(ioc_id)
        else:
            raw_res = search_custom_iocs(
                types=argToList(ioc_type),
                values=argToList(value),
            )

        iocs = raw_res.get('resources')
        handle_response_errors(raw_res)
        if not iocs:
            return create_entry_object(hr='Could not find any Indicators of Compromise.')
        ec = [get_trasnformed_dict(ioc, IOC_KEY_MAP) for ioc in iocs]
        return create_entry_object(
            contents=raw_res,
            ec={'CrowdStrike.IOC(val.ID === obj.ID)': ec},
            hr=tableToMarkdown('Indicator of Compromise', ec),
        )


    def upload_custom_ioc_command(
        ioc_type: str,
        value: str,
        action: str,
        platforms: str,
        severity: Optional[str] = None,
        source: Optional[str] = None,
        description: Optional[str] = None,
        expiration: Optional[str] = None,
        applied_globally: Optional[bool] = None,
        host_groups: Optional[List[str]] = None,
    ) -> dict:
        """
        :param ioc_type: The type of the indicator.
        :param value: The string representation of the indicator.
        :param action: Action to take when a host observes the custom IOC.
        :param platforms: The platforms that the indicator applies to.
        :param severity: The severity level to apply to this indicator.
        :param source: The source where this indicator originated.
        :param description: A meaningful description of the indicator.
        :param expiration: The date on which the indicator will become inactive.
        :param applied_globally: Whether the indicator is applied globally.
        :param host_groups: List of host group IDs that the indicator applies to.
        """
        if action in {'prevent', 'detect'} and not severity:
            raise ValueError(f'Severity is required for action {action}.')
        raw_res = upload_custom_ioc(
            ioc_type,
            value,
            action,
            argToList(platforms),
            severity,
            source,
            description,
            expiration,
            argToBoolean(applied_globally) if applied_globally else None,
            argToList(host_groups),
        )
        handle_response_errors(raw_res)
        iocs = raw_res.get('resources', [])
        ec = [get_trasnformed_dict(iocs[0], IOC_KEY_MAP)]
        return create_entry_object(
            contents=raw_res,
            ec={'CrowdStrike.IOC(val.ID === obj.ID)': ec},
            hr=tableToMarkdown('Custom IOC was created successfully', ec),
        )


    def update_custom_ioc_command(
        ioc_id: str,
        action: Optional[str] = None,
        platforms: Optional[str] = None,
        severity: Optional[str] = None,
        source: Optional[str] = None,
        description: Optional[str] = None,
        expiration: Optional[str] = None,
    ) -> dict:
        """
        :param ioc_id: The ID of the indicator to update.
        :param action: Action to take when a host observes the custom IOC.
        :param platforms: The platforms that the indicator applies to.
        :param severity: The severity level to apply to this indicator.
        :param source: The source where this indicator originated.
        :param description: A meaningful description of the indicator.
        :param expiration: The date on which the indicator will become inactive.
        """

        raw_res = update_custom_ioc(
            ioc_id,
            action,
            argToList(platforms),
            severity,
            source,
            description,
            expiration,
        )
        handle_response_errors(raw_res)
        iocs = raw_res.get('resources', [])
        ec = [get_trasnformed_dict(iocs[0], IOC_KEY_MAP)]
        return create_entry_object(
            contents=raw_res,
            ec={'CrowdStrike.IOC(val.ID === obj.ID)': ec},
            hr=tableToMarkdown('Custom IOC was updated successfully', ec),
        )


    def delete_custom_ioc_command(ioc_id: str) -> dict:
        """
        :param ioc_id: The ID of indicator to delete.
        """
        raw_res = delete_custom_ioc(ioc_id)
        handle_response_errors(raw_res, "The server has not confirmed deletion, please manually confirm deletion.")
        return create_entry_object(contents=raw_res, hr=f"Custom IOC {ioc_id} was successfully deleted.")


    def get_ioc_device_count_command(ioc_type: str, value: str):
        """
        :param ioc_type: The type of the indicator
        :param value: The IOC value
        """
        raw_res = get_ioc_device_count(ioc_type, value)
        if 'No results found for' in raw_res:
            return raw_res
        else:
            handle_response_errors(raw_res)
            device_count_res = raw_res.get('resources')
            ioc_id = f"{ioc_type}:{value}"
            if not device_count_res:
                return create_entry_object(raw_res, hr=f"Could not find any devices the IOC **{ioc_id}** was detected in.")
            context = [get_trasnformed_dict(device_count, IOC_DEVICE_COUNT_MAP) for device_count in device_count_res]
            hr = f'Indicator of Compromise **{ioc_id}** device count: **{device_count_res[0].get("device_count")}**'
            return create_entry_object(contents=raw_res, ec={'CrowdStrike.IOC(val.ID === obj.ID)': context}, hr=hr)


    def get_process_details_command(ids: str):
        """
        :param ids: proccess ids
        """
        ids = argToList(ids)
        raw_res = get_process_details(ids)
        handle_response_errors(raw_res)
        proc = raw_res.get('resources')
        if not proc:
            return create_entry_object(raw_res, hr="Could not find any searched processes.")
        proc_hr_ids = str(ids)[1:-1].replace('\'', '')
        title = f"Details for process{'es' if len(ids) > 1 else ''}: {proc_hr_ids}."
        return create_entry_object(contents=raw_res, hr=tableToMarkdown(title, proc),
                                   ec={'CrowdStrike.Process(val.process_id === obj.process_id)': proc})


    def get_proccesses_ran_on_command(ioc_type, value, device_id):
        """
        :param device_id: Device id the IOC ran on
        :param ioc_type: The type of the indicator
        :param value: The IOC value
        """
        raw_res = get_proccesses_ran_on(ioc_type, value, device_id)
        handle_response_errors(raw_res)
        proc_ids = raw_res.get('resources')
        ioc_id = f"{ioc_type}:{value}"
        if not proc_ids:
            return create_entry_object(raw_res, hr=f"Could not find any processes associated with the IOC **{ioc_id}**.")
        context = {'ID': ioc_id, 'Type': ioc_type, 'Value': value, 'Process': {'DeviceID': device_id, 'ID': proc_ids}}
        hr = tableToMarkdown(f"Processes with custom IOC {ioc_id} on device {device_id}.", proc_ids, headers="Process ID")
        return create_entry_object(contents=raw_res, hr=hr, ec={'CrowdStrike.IOC(val.ID === obj.ID)': context})


    def search_device_command():
        """
            Searches for a device
            :return: EntryObject of search device command
        """
        raw_res = search_device()
        if not raw_res:
            return create_entry_object(hr='Could not find any devices.')
        devices = raw_res.get('resources')

        command_results = []
        for single_device in devices:
            status, is_isolated = generate_status_fields(single_device.get('status'))
            endpoint = Common.Endpoint(
                id=single_device.get('device_id'),
                hostname=single_device.get('hostname'),
                ip_address=single_device.get('local_ip'),
                os=single_device.get('platform_name'),
                os_version=single_device.get('os_version'),
                status=status,
                is_isolated=is_isolated,
                mac_address=single_device.get('mac_address'),
                vendor=INTEGRATION_NAME)

            entry = get_trasnformed_dict(single_device, SEARCH_DEVICE_KEY_MAP)
            headers = ['ID', 'Hostname', 'OS', 'MacAddress', 'LocalIP', 'ExternalIP', 'FirstSeen', 'LastSeen', 'Status']

            command_results.append(CommandResults(
                outputs_prefix='CrowdStrike.Device',
                outputs_key_field='ID',
                outputs=entry,
                readable_output=tableToMarkdown('Devices', entry, headers=headers, headerTransform=pascalToSpace),
                raw_response=raw_res,
                indicator=endpoint,
            ))

        return command_results

    def search_device_by_mac_command():
        """
            Searches for a device
            :return: EntryObject of search device command
        """
        raw_res = search_device_by_mac_address()
        if not raw_res:
            return create_entry_object(hr='Could not find any devices.')
        devices = raw_res.get('resources')
        command_results = []
        for single_device in devices:
            status, is_isolated = generate_status_fields(single_device.get('status'))
            endpoint = get_trasnformed_dict(single_device, ENDPOINT_MAP)
            endpoint.update({
                    'Vendor':INTEGRATION_NAME,
                    'GroupName ':single_device.get('groups'),
                    'IsIsIsolated':False if status == 'Online' else True,
                    'OSType': single_device.get('platform_name'),
                    'OperationalStatus': status
                })
            entry = get_trasnformed_dict(single_device, SEARCH_DEVICE_KEY_MAP)
            headers = ['ID', 'Hostname', 'OS', 'MacAddress', 'LocalIP', 'ExternalIP', 'FirstSeen', 'LastSeen', 'Status']

            command_results.append(CommandResults(
                outputs_prefix='CrowdStrike.Device',
                outputs_key_field='ID',
                outputs=endpoint,
                readable_output=tableToMarkdown('Devices', entry, headers=headers, headerTransform=pascalToSpace),
                raw_response=raw_res
            ))

        return command_results


    def search_device_by_ip(raw_res, ip_address):
        devices = raw_res.get('resources')
        filtered_devices = []
        for single_device in devices:
            if single_device.get('local_ip') == ip_address:
                filtered_devices.append(single_device)

        if filtered_devices:
            raw_res['resources'] = filtered_devices
        else:
            raw_res = None
        return raw_res


    def generate_status_fields(endpoint_status):
        status = ''
        is_isolated = ''

        if endpoint_status.lower() == 'normal':
            status = 'Online'
        elif endpoint_status == 'containment_pending':
            is_isolated = 'Pending isolation'
        elif endpoint_status == 'contained':
            is_isolated = 'Yes'
        elif endpoint_status == 'lift_containment_pending':
            is_isolated = 'Pending unisolation'
        else:
            raise DemistoException(f'Error: Unknown endpoint status was given: {endpoint_status}')
        return status, is_isolated


    def generate_endpoint_by_contex_standard(devices):
        standard_endpoints = []
        for single_device in devices:
            status, is_isolated = generate_status_fields(single_device.get('status'))
            endpoint = Common.Endpoint(
                id=single_device.get('device_id'),
                hostname=single_device.get('hostname'),
                ip_address=single_device.get('local_ip'),
                os=single_device.get('platform_name'),
                os_version=single_device.get('os_version'),
                status=status,
                is_isolated=is_isolated,
                mac_address=single_device.get('mac_address'),
                vendor=INTEGRATION_NAME)
            standard_endpoints.append(endpoint)
        return standard_endpoints


    def get_endpoint_command():
        args = demisto.args()
        if 'id' in args.keys():
            args['ids'] = args.get('id', '')

        # handles the search by id or by hostname
        raw_res = search_device()

        if ip := args.get('ip'):
            # there is no option to filter by ip in an api call, therefore we would filter the devices in the code
            raw_res = search_device_by_ip(raw_res, ip)

        if not ip and not args.get('id') and not args.get('hostname'):
            # in order not to return all the devices
            return create_entry_object(hr='Please add a filter argument - ip, hostname or id.')

        if not raw_res:
            return create_entry_object(hr='Could not find any devices.')
        devices = raw_res.get('resources')

        standard_endpoints = generate_endpoint_by_contex_standard(devices)

        command_results = []
        for endpoint in standard_endpoints:
            endpoint_context = endpoint.to_context().get(Common.Endpoint.CONTEXT_PATH)
            hr = tableToMarkdown('CrowdStrike Falcon Endpoint', endpoint_context)

            command_results.append(CommandResults(
                readable_output=hr,
                raw_response=raw_res,
                indicator=endpoint
            ))
        return command_results


    def get_behavior_command():
        """
            Gets a behavior by ID
            :return: EntryObject of get behavior command
        """
        behavior_id = demisto.args().get('behavior_id')
        detections_ids = demisto.get(get_detections(behavior_id=behavior_id), 'resources')
        raw_res = get_detections_entities(detections_ids)
        entries = []
        if "resources" in raw_res:
            for resource in demisto.get(raw_res, "resources"):
                for behavior in demisto.get(resource, 'behaviors'):
                    entries.append(behavior_to_entry_context(behavior))
        hr = tableToMarkdown('Behavior ID: {}'.format(behavior_id), entries, headerTransform=pascalToSpace)
        # no dt since behavior vary by more than their ID
        ec = {'CrowdStrike.Behavior': entries}
        return create_entry_object(contents=raw_res, ec=ec, hr=hr)


    def search_detections_command():
        """
            Searches for a detection
            :return: EntryObject of search detections command
        """
        d_args = demisto.args()
        detections_ids = argToList(d_args.get('ids'))
        if not detections_ids:
            filter_arg = d_args.get('filter')
            if not filter_arg:
                return_error('Command Error: Please provide at least one argument.')
            detections_ids = get_detections(filter_arg=filter_arg).get('resources')
        raw_res = get_detections_entities(detections_ids)
        entries = []
        headers = ['ID', 'Status', 'System', 'ProcessStartTime', 'CustomerID', 'MaxSeverity']
        if "resources" in raw_res:
            for detection in demisto.get(raw_res, "resources"):
                detection_entry = {}
                for path, new_key in DETECTIONS_BASE_KEY_MAP.items():
                    detection_entry[new_key] = demisto.get(detection, path)
                behaviors = []
                for behavior in demisto.get(detection, 'behaviors'):
                    behaviors.append(behavior_to_entry_context(behavior))
                detection_entry['Behavior'] = behaviors
                entries.append(detection_entry)
        hr = tableToMarkdown('Detections Found:', entries, headers=headers, removeNull=True, headerTransform=pascalToSpace)
        ec = {'CrowdStrike.Detection(val.ID === obj.ID)': entries}
        return create_entry_object(contents=raw_res, ec=ec, hr=hr)


    def resolve_detection_command():
        """
            Resolves single or multiple detections
            :return: EntryObject of resolve detection command
        """
        args = demisto.args()
        ids = argToList(args.get('ids'))
        username = args.get('username')
        assigned_to_uuid = args.get('assigned_to_uuid')
        comment = args.get('comment')
        if username and assigned_to_uuid:
            raise ValueError('Only one of the arguments assigned_to_uuid or username should be provided, not both.')
        if username:
            assigned_to_uuid = get_username_uuid(username)

        status = args.get('status')
        show_in_ui = args.get('show_in_ui')
        if not (username or assigned_to_uuid or comment or status or show_in_ui):
            raise DemistoException("Please provide at least one argument to resolve the detection with.")
        raw_res = resolve_detection(ids, status, assigned_to_uuid, show_in_ui, comment)
        args.pop('ids')
        hr = "Detection {0} updated\n".format(str(ids)[1:-1])
        hr += 'With the following values:\n'
        for k, arg in args.items():
            hr += '\t{name}:{val}\n'.format(name=k, val=arg)
        return create_entry_object(contents=raw_res, hr=hr)


    def contain_host_command():
        """
            Contains hosts with user arg ids
            :return: EntryObject of contain host command
        """
        ids = argToList(demisto.args().get('ids'))
        raw_res = contain_host(ids)
        hr = "Host {} contained".format(str(ids)[1:-1])
        return create_entry_object(contents=raw_res, hr=hr)


    def lift_host_containment_command():
        """
            Lifts containment off a host
            :return: EntryObject of lift host containment
        """
        ids = argToList(demisto.args().get('ids'))
        raw_res = lift_host_containment(ids)
        hr = "Containment has been lift off host {}".format(str(ids)[1:-1])
        return create_entry_object(contents=raw_res, hr=hr)


    def run_command():
        args = demisto.args()
        host_ids = argToList(args.get('host_ids'))
        command_type = args.get('command_type')
        full_command = args.get('full_command')
        scope = args.get('scope', 'read')
        target = args.get('target', 'batch')

        output = []

        if target == 'batch':
            batch_id = init_rtr_batch_session(host_ids)
            timer = Timer(300, batch_refresh_session, kwargs={'batch_id': batch_id})
            timer.start()
            try:
                if scope == 'read':
                    response = run_batch_read_cmd(batch_id, command_type, full_command)
                elif scope == 'write':
                    response = run_batch_write_cmd(batch_id, command_type, full_command)
                else:  # scope = admin
                    response = run_batch_admin_cmd(batch_id, command_type, full_command)
            finally:
                timer.cancel()

            resources: dict = response.get('combined', {}).get('resources', {})

            for _, resource in resources.items():
                errors = resource.get('errors', [])
                if errors:
                    error_message = errors[0].get('message', '')
                    if not error_message:
                        error_message = f'Could not run command\n{errors}'
                    return_error(error_message)
                output.append({
                    'HostID': resource.get('aid'),
                    'SessionID': resource.get('session_id'),
                    'Stdout': resource.get('stdout'),
                    'Stderr': resource.get('stderr'),
                    'BaseCommand': resource.get('base_command'),
                    'Command': full_command
                })

            human_readable = tableToMarkdown(f'Command {full_command} results', output, removeNull=True)
            entry_context_batch = {
                'CrowdStrike': {
                    'Command': output
                }
            }
            return create_entry_object(contents=response, ec=entry_context_batch, hr=human_readable)
        else:  # target = 'single'
            responses = []
            for host_id in host_ids:
                if scope == 'read':
                    response1 = run_single_read_cmd(host_id, command_type, full_command)
                elif scope == 'write':
                    response1 = run_single_write_cmd(host_id, command_type, full_command)
                else:  # scope = admin
                    response1 = run_single_admin_cmd(host_id, command_type, full_command)
                responses.append(response1)

                for resource in response1.get('resources', []):
                    errors = resource.get('errors', [])
                    if errors:
                        error_message = errors[0].get('message', '')
                        if not error_message:
                            error_message = f'Could not run command\n{errors}'
                        return_error(error_message)
                    output.append({
                        'HostID': host_id,
                        'TaskID': resource.get('cloud_request_id'),
                        'SessionID': resource.get('session_id'),
                        'BaseCommand': command_type,
                        'Command': full_command,
                        'Complete': False,
                        'NextSequenceID': 0
                    })

            human_readable = tableToMarkdown(f'Command {full_command} results', output, removeNull=True)
            entry_context_single = {
                'CrowdStrike.Command(val.TaskID === obj.TaskID)': output
            }
            return create_entry_object(contents=responses, ec=entry_context_single, hr=human_readable)


    def upload_script_command():
        args = demisto.args()
        name = args.get('name')
        permission_type = args.get('permission_type', 'private')
        content = args.get('content')
        entry_id = args.get('entry_id')

        if content and entry_id:
            raise ValueError('Only one of the arguments entry_id or content should be provided, not both.')
        elif not content and not entry_id:
            raise ValueError('One of the arguments entry_id or content must be provided, none given.')

        response = upload_script(name, permission_type, content, entry_id)

        return create_entry_object(contents=response, hr='The script was uploaded successfully')


    def get_script_command():
        script_id = argToList(demisto.args().get('script_id'))

        response = get_script(script_id)

        resources: list = response.get('resources', [])
        if resources and isinstance(resources, list):
            resource = resources[0]
            script = {
                'ID': resource.get('id'),
                'CreatedBy': resource.get('created_by'),
                'CreatedTime': resource.get('created_timestamp'),
                'Description': resource.get('description'),
                'ModifiedBy': resource.get('modified_by'),
                'ModifiedTime': resource.get('modified_timestamp'),
                'Name': resource.get('name'),
                'Permission': resource.get('permission_type'),
                'SHA256': resource.get('sha256'),
                'RunAttemptCount': resource.get('run_attempt_count'),
                'RunSuccessCount': resource.get('run_success_count'),
                'WriteAccess': resource.get('write_access')
            }

            human_readable = tableToMarkdown(f'CrowdStrike Falcon script {script_id}', script)

            entry_context = {
                'CrowdStrike.Script(val.ID === obj.ID)': script
            }

            script_content = resource.get('content')
            if script_content:
                demisto.results(
                    fileResult(
                        f"{resource.get('name', 'script')}.ps1",
                        script_content
                    )
                )

            return create_entry_object(contents=response, ec=entry_context, hr=human_readable)
        else:
            return 'No script found.'


    def delete_script_command():
        script_id = demisto.args().get('script_id')

        response = delete_script(script_id)

        return create_entry_object(contents=response, hr=f'Script {script_id} was deleted successfully')


    def list_scripts_command():
        response = list_scripts()

        resources: list = response.get('resources', [])

        scripts = []

        for resource in resources:
            scripts.append({
                'ID': resource.get('id'),
                'CreatedBy': resource.get('created_by'),
                'CreatedTime': resource.get('created_timestamp'),
                'Description': resource.get('description'),
                'ModifiedBy': resource.get('modified_by'),
                'ModifiedTime': resource.get('modified_timestamp'),
                'Name': resource.get('name'),
                'Permission': resource.get('permission_type'),
                'SHA256': resource.get('sha256'),
                'RunAttemptCount': resource.get('run_attempt_count'),
                'RunSuccessCount': resource.get('run_success_count'),
                'Platform': resource.get('platform'),
                'WriteAccess': resource.get('write_access')
            })

        human_readable = tableToMarkdown('CrowdStrike Falcon scripts', scripts)

        entry_context = {
            'CrowdStrike.Script(val.ID === obj.ID)': scripts
        }

        return create_entry_object(contents=response, ec=entry_context, hr=human_readable)


    def upload_file_command():
        entry_id = demisto.args().get('entry_id')
        description = demisto.args().get('description', 'File uploaded from Demisto')

        response, file_name = upload_file(entry_id, description)

        return create_entry_object(contents=response, hr='File was uploaded successfully')


    def delete_file_command():
        file_id = demisto.args().get('file_id')

        response = delete_file(file_id)

        return create_entry_object(contents=response, hr=f'File {file_id} was deleted successfully')


    def get_file_command():
        file_id = argToList(demisto.args().get('file_id'))

        response = get_file(file_id)

        resources: list = response.get('resources', [])
        if resources and isinstance(resources, list):
            # will always be a list of one resource
            resource = resources[0]
            file_ = {
                'ID': resource.get('id'),
                'CreatedBy': resource.get('created_by'),
                'CreatedTime': resource.get('created_timestamp'),
                'Description': resource.get('description'),
                'Type': resource.get('file_type'),
                'ModifiedBy': resource.get('modified_by'),
                'ModifiedTime': resource.get('modified_timestamp'),
                'Name': resource.get('name'),
                'Permission': resource.get('permission_type'),
                'SHA256': resource.get('sha256'),
            }
            file_standard_context = {
                'Type': resource.get('file_type'),
                'Name': resource.get('name'),
                'SHA256': resource.get('sha256'),
                'Size': resource.get('size'),
            }

            human_readable = tableToMarkdown(f'CrowdStrike Falcon file {file_id}', file_)

            entry_context = {
                'CrowdStrike.File(val.ID === obj.ID)': file_,
                outputPaths['file']: file_standard_context
            }

            file_content = resource.get('content')
            if file_content:
                demisto.results(
                    fileResult(
                        resource.get('name'),
                        file_content
                    )
                )

            return create_entry_object(contents=response, ec=entry_context, hr=human_readable)
        else:
            return 'No file found.'


    def list_files_command():
        response = list_files()

        resources: list = response.get('resources', [])

        files_output = []
        file_standard_context = []

        for resource in resources:
            files_output.append({
                'ID': resource.get('id'),
                'CreatedBy': resource.get('created_by'),
                'CreatedTime': resource.get('created_timestamp'),
                'Description': resource.get('description'),
                'Type': resource.get('file_type'),
                'ModifiedBy': resource.get('modified_by'),
                'ModifiedTime': resource.get('modified_timestamp'),
                'Name': resource.get('name'),
                'Permission': resource.get('permission_type'),
                'SHA256': resource.get('sha256'),
            })
            file_standard_context.append({
                'Type': resource.get('file_type'),
                'Name': resource.get('name'),
                'SHA256': resource.get('sha256'),
                'Size': resource.get('size'),
            })

        human_readable = tableToMarkdown('CrowdStrike Falcon files', files_output)

        entry_context = {
            'CrowdStrike.File(val.ID === obj.ID)': files_output,
            outputPaths['file']: file_standard_context
        }

        return create_entry_object(contents=response, ec=entry_context, hr=human_readable)


    def run_script_command():
        args = demisto.args()
        script_name = args.get('script_name')
        raw = args.get('raw')
        host_ids = argToList(args.get('host_ids'))
        try:
            timeout = int(args.get('timeout', 30))
        except ValueError as e:
            demisto.error(str(e))
            raise ValueError('Timeout argument should be an integer, for example: 30')

        if script_name and raw:
            raise ValueError('Only one of the arguments script_name or raw should be provided, not both.')
        elif not script_name and not raw:
            raise ValueError('One of the arguments script_name or raw must be provided, none given.')
        elif script_name:
            full_command = f'runscript -CloudFile={script_name}'
        elif raw:
            full_command = f'runscript -Raw=```{raw}```'
        full_command += f' -Timeout={timeout}'

        command_type = 'runscript'

        batch_id = init_rtr_batch_session(host_ids)
        timer = Timer(300, batch_refresh_session, kwargs={'batch_id': batch_id})
        timer.start()
        try:
            response = run_batch_admin_cmd(batch_id, command_type, full_command, timeout)
        finally:
            timer.cancel()

        resources: dict = response.get('combined', {}).get('resources', {})

        output = []

        for _, resource in resources.items():
            errors = resource.get('errors', [])
            if errors:
                error_message = errors[0].get('message', '')
                if not error_message:
                    error_message = f'Could not run command\n{errors}'
                return_error(error_message)
            full_command = full_command.replace('`', '')
            output.append({
                'HostID': resource.get('aid'),
                'SessionID': resource.get('session_id'),
                'Stdout': resource.get('stdout'),
                'Stderr': resource.get('stderr'),
                'BaseCommand': resource.get('base_command'),
                'Command': full_command
            })

        human_readable = tableToMarkdown(f'Command {full_command} results', output)
        entry_context = {
            'CrowdStrike': {
                'Command': output
            }
        }

        return create_entry_object(contents=response, ec=entry_context, hr=human_readable)


    def run_get_command():
        args = demisto.args()
        host_ids = argToList(args.get('host_ids'))
        file_path = args.get('file_path')
        optional_hosts = argToList(args.get('optional_hosts'))
        timeout = args.get('timeout')
        timeout_duration = args.get('timeout_duration')

        timeout = timeout and int(timeout)
        response = run_batch_get_cmd(host_ids, file_path, optional_hosts, timeout, timeout_duration)

        resources: dict = response.get('combined', {}).get('resources', {})

        output = []

        for _, resource in resources.items():
            errors = resource.get('errors', [])
            if errors:
                error_message = errors[0].get('message', '')
                if not error_message:
                    error_message = f'Could not get command\n{errors}'
                return_error(error_message)
            output.append({
                'HostID': resource.get('aid'),
                'Stdout': resource.get('stdout'),
                'Stderr': resource.get('stderr'),
                'BaseCommand': resource.get('base_command'),
                'TaskID': resource.get('task_id'),
                'GetRequestID': response.get('batch_get_cmd_req_id'),
                'Complete': resource.get('complete') or False,
                'FilePath': file_path
            })

        human_readable = tableToMarkdown(f'Get command has requested for a file {file_path}', output)
        entry_context = {
            'CrowdStrike.Command(val.TaskID === obj.TaskID)': output
        }

        return create_entry_object(contents=response, ec=entry_context, hr=human_readable)


    def status_get_command():
        args = demisto.args()
        request_ids = argToList(args.get('request_ids'))
        timeout = args.get('timeout')
        timeout_duration = args.get('timeout_duration')

        timeout = timeout and int(timeout)

        responses = []
        files_output = []
        file_standard_context = []

        for request_id in request_ids:
            response = status_get_cmd(request_id, timeout, timeout_duration)
            responses.append(response)

            resources: dict = response.get('resources', {})

            for _, resource in resources.items():
                errors = resource.get('errors', [])
                if errors:
                    error_message = errors[0].get('message', '')
                    if not error_message:
                        error_message = f'Could not get command\n{errors}'
                    return_error(error_message)
                files_output.append({
                    'ID': resource.get('id'),
                    'TaskID': resource.get('cloud_request_id'),
                    'CreatedAt': resource.get('created_at'),
                    'DeletedAt': resource.get('deleted_at'),
                    'UpdatedAt': resource.get('updated_at'),
                    'Name': resource.get('name'),
                    'Size': resource.get('size'),
                    'SHA256': resource.get('sha256')
                })
                file_standard_context.append({
                    'Name': resource.get('name'),
                    'SHA256': resource.get('sha256'),
                    'Size': resource.get('size'),
                })

        human_readable = tableToMarkdown('CrowdStrike Falcon files', files_output)
        entry_context = {
            'CrowdStrike.File(val.ID === obj.ID || val.TaskID === obj.TaskID)': files_output,
            outputPaths['file']: file_standard_context
        }
        if len(responses) == 1:
            return create_entry_object(contents=responses[0], ec=entry_context, hr=human_readable)
        else:
            return create_entry_object(contents=response, ec=entry_context, hr=human_readable)


    def status_command():
        args = demisto.args()
        request_id = args.get('request_id')
        sequence_id = args.get('sequence_id')
        scope = args.get('scope', 'read')

        sequence_id = None if sequence_id is None else int(sequence_id)

        if scope == 'read':
            response = status_read_cmd(request_id, sequence_id)
        elif scope == 'write':
            response = status_write_cmd(request_id, sequence_id)
        else:  # scope = admin
            response = status_admin_cmd(request_id, sequence_id)

        resources: list = response.get('resources', [])

        output = []

        for resource in resources:
            errors = resource.get('errors', [])
            if errors:
                error_message = errors[0].get('message', '')
                if not error_message:
                    error_message = f'Could not run command\n{errors}'
                return_error(error_message)

            sequence_id = int(resource.get('sequence_id', 0))
            output.append({
                'Complete': resource.get('complete') or False,
                'Stdout': resource.get('stdout'),
                'Stderr': resource.get('stderr'),
                'BaseCommand': resource.get('base_command'),
                'TaskID': resource.get('task_id'),
                'SequenceID': sequence_id,
                'NextSequenceID': sequence_id + 1
            })

        human_readable = tableToMarkdown('Command status results', output, removeNull=True)
        entry_context = {
            'CrowdStrike.Command(val.TaskID === obj.TaskID)': output
        }

        return create_entry_object(contents=response, ec=entry_context, hr=human_readable)


    def get_extracted_file_command():
        args = demisto.args()
        host_id = args.get('host_id')
        sha256 = args.get('sha256')
        filename = args.get('filename')

        response = get_extracted_file(host_id, sha256, filename)

        # save an extracted file
        content_type = response.headers.get('Content-Type', '').lower()
        if content_type == 'application/x-7z-compressed':
            content_disposition = response.headers.get('Content-Disposition', '').lower()
            if content_disposition:
                filename = email.message_from_string(f'Content-Disposition: {content_disposition}\n\n').get_filename()

            if not filename:
                sha256 = sha256 or hashlib.sha256(response.content).hexdigest()
                filename = sha256.lower() + '.7z'

            return fileResult(filename, response.content)

        return_error('An extracted file is missing in the response')


    def list_host_files_command():
        args = demisto.args()
        host_id = args.get('host_id')

        response = list_host_files(host_id)
        resources: list = response.get('resources', [])

        files_output = []
        file_standard_context = []
        command_output = []

        for resource in resources:
            errors = resource.get('errors', [])
            if errors:
                error_message = errors[0].get('message', '')
                if not error_message:
                    error_message = f'Could not run command\n{errors}'
                return_error(error_message)
            command_output.append({
                'HostID': host_id,
                'TaskID': resource.get('cloud_request_id'),
                'SessionID': resource.get('session_id')
            })
            files_output.append({
                'ID': resource.get('id'),
                'CreatedAt': resource.get('created_at'),
                'DeletedAt': resource.get('deleted_at'),
                'UpdatedAt': resource.get('updated_at'),
                'Name': resource.get('name'),
                'SHA256': resource.get('sha256'),
                'Size': resource.get('size'),
                'Stdout': resource.get('stdout'),
                'Stderr': resource.get('stderr')
            })
            file_standard_context.append({
                'Name': resource.get('name'),
                'SHA256': resource.get('sha256'),
                'Size': resource.get('size'),
            })

        if files_output:
            human_readable = tableToMarkdown('CrowdStrike Falcon files', files_output)
        else:
            human_readable = 'No result found'

        entry_context = {
            'CrowdStrike.Command(val.TaskID === obj.TaskID)': command_output,
            'CrowdStrike.File(val.ID === obj.ID)': files_output,
            outputPaths['file']: file_standard_context
        }

        return create_entry_object(contents=response, ec=entry_context, hr=human_readable)


    def refresh_session_command():
        args = demisto.args()
        host_id = args.get('host_id')

        response = refresh_session(host_id)
        resources: list = response.get('resources', [])

        session_id = None
        for resource in resources:
            errors = resource.get('errors', [])
            if errors:
                error_message = errors[0].get('message', '')
                if not error_message:
                    error_message = f'Could not run command\n{errors}'
                return_error(error_message)
            session_id = resource.get('session_id')

        return create_entry_object(contents=response, hr=f'CrowdStrike Session Refreshed: {session_id}')


    def build_error_message(raw_res):
        if raw_res.get('errors'):
            error_data = raw_res.get('errors')[0]
        else:
            error_data = {"code": 'None', "message": 'something got wrong, please try again'}
        error_code = error_data.get('code')
        error_message = error_data.get('message')
        return f'Error: error code: {error_code}, error_message: {error_message}.'


    def validate_response(raw_res):
        return 'resources' in raw_res.keys()


    def get_indicator_device_id():
        args = demisto.args()
        ioc_type = args.get('type')
        ioc_value = args.get('value')
        params = assign_params(
            type=ioc_type,
            value=ioc_value
        )
        raw_res = http_request('GET', '/indicators/queries/devices/v1', params=params, status_code=404)
        errors = raw_res.get('errors', [])
        for error in errors:
            if error.get('code') == 404:
                return f'No results found for {ioc_type} - {ioc_value}'
        context_output = ''
        if validate_response(raw_res):
            context_output = raw_res.get('resources')
        else:
            error_message = build_error_message(raw_res)
            return_error(error_message)
        ioc_id = f"{ioc_type}:{ioc_value}"
        readable_output = tableToMarkdown(f"Devices that encountered the IOC {ioc_id}", context_output, headers='Device ID')
        return CommandResults(
            readable_output=readable_output,
            outputs_prefix='CrowdStrike.DeviceID',
            outputs_key_field='DeviceID',
            outputs=context_output,
            raw_response=raw_res
        )


    def detections_to_human_readable(detections):
        detections_readable_outputs = []
        for detection in detections:
            readable_output = assign_params(status=detection.get('status'),
                                            max_severity=detection.get('max_severity_displayname'),
                                            detection_id=detection.get('detection_id'),
                                            created_time=detection.get('created_timestamp'))
            detections_readable_outputs.append(readable_output)
        headers = ['detection_id', 'created_time', 'status', 'max_severity']
        human_readable = tableToMarkdown('CrowdStrike Detections', detections_readable_outputs, headers, removeNull=True)
        return human_readable


    def list_detection_summaries_command():
        fetch_query = demisto.args().get('fetch_query')

        if fetch_query:
            fetch_query = "{query}".format(query=fetch_query)
            detections_ids = demisto.get(get_fetch_detections(filter_arg=fetch_query), 'resources')
        else:
            detections_ids = demisto.get(get_fetch_detections(), 'resources')
        detections_response_data = get_detections_entities(detections_ids)
        detections = [resource for resource in detections_response_data.get('resources')]
        detections_human_readable = detections_to_human_readable(detections)

        return CommandResults(
            readable_output=detections_human_readable,
            outputs_prefix='CrowdStrike.Detections',
            outputs_key_field='detection_id',
            outputs=detections
        )


    def incidents_to_human_readable(incidents):
        incidents_readable_outputs = []
        for incident in incidents:
            readable_output = assign_params(description=incident.get('description'), state=incident.get('state'),
                                            name=incident.get('name'), tags=incident.get('tags'),
                                            incident_id=incident.get('incident_id'), created_time=incident.get('created'),
                                            status=STATUS_NUM_TO_TEXT.get(incident.get('status')))
            incidents_readable_outputs.append(readable_output)
        headers = ['incident_id', 'created_time', 'name', 'description', 'status', 'state', 'tags']
        human_readable = tableToMarkdown('CrowdStrike Incidents', incidents_readable_outputs, headers, removeNull=True)
        return human_readable


    def list_incident_summaries_command():
        fetch_query = demisto.args().get('fetch_query')

        if fetch_query:
            fetch_query = "{query}".format(query=fetch_query)
            incidents_ids = get_incidents_ids(filter_arg=fetch_query)
        else:
            incidents_ids = get_incidents_ids()
        handle_response_errors(incidents_ids)
        ids = incidents_ids.get('resources')
        if not ids:
            return CommandResults(readable_output='No incidents were found.')
        incidents_response_data = get_incidents_entities(ids)
        incidents = [resource for resource in incidents_response_data.get('resources')]
        incidents_human_readable = incidents_to_human_readable(incidents)
        return CommandResults(
            readable_output=incidents_human_readable,
            outputs_prefix='CrowdStrike.Incidents',
            outputs_key_field='incident_id',
            outputs=incidents
        )


    def create_host_group_command(name: str,
                                  group_type: str = None,
                                  description: str = None,
                                  assignment_rule: str = None) -> CommandResults:
        response = change_host_group(is_post=True,
                                     name=name,
                                     group_type=group_type,
                                     description=description,
                                     assignment_rule=assignment_rule)
        host_groups = response.get('resources')
        return CommandResults(outputs_prefix='CrowdStrike.HostGroup',
                              outputs_key_field='id',
                              outputs=host_groups,
                              readable_output=tableToMarkdown('Host Groups', host_groups, headers=HOST_GROUP_HEADERS),
                              raw_response=response)


    def update_host_group_command(host_group_id: str,
                                  name: Optional[str] = None,
                                  description: Optional[str] = None,
                                  assignment_rule: Optional[str] = None) -> CommandResults:
        response = change_host_group(is_post=False,
                                     host_group_id=host_group_id,
                                     name=name,
                                     description=description,
                                     assignment_rule=assignment_rule)
        host_groups = response.get('resources')
        return CommandResults(outputs_prefix='CrowdStrike.HostGroup',
                              outputs_key_field='id',
                              outputs=host_groups,
                              readable_output=tableToMarkdown('Host Groups', host_groups, headers=HOST_GROUP_HEADERS),
                              raw_response=response)


    def list_host_group_members_command(host_group_id: Optional[str] = None,
                                        filter: Optional[str] = None,
                                        offset: Optional[str] = None,
                                        limit: Optional[str] = None) -> CommandResults:
        response = host_group_members(filter, host_group_id, limit, offset)
        devices = response.get('resources')
        if not devices:
            return CommandResults(readable_output='No hosts are found',
                                  raw_response=response)
        headers = list(SEARCH_DEVICE_KEY_MAP.values())
        outputs = [get_trasnformed_dict(single_device, SEARCH_DEVICE_KEY_MAP) for single_device in devices]
        return CommandResults(
            outputs_prefix='CrowdStrike.Device',
            outputs_key_field='ID',
            outputs=outputs,
            readable_output=tableToMarkdown('Devices', outputs, headers=headers, headerTransform=pascalToSpace),
            raw_response=response
        )


    def add_host_group_members_command(host_group_id: str, host_ids: List[str]) -> CommandResults:
        response = change_host_group_members(action_name='add-hosts',
                                             host_group_id=host_group_id,
                                             host_ids=host_ids)
        host_groups = response.get('resources')
        return CommandResults(outputs_prefix='CrowdStrike.HostGroup',
                              outputs_key_field='id',
                              outputs=host_groups,
                              readable_output=tableToMarkdown('Host Groups', host_groups, headers=HOST_GROUP_HEADERS),
                              raw_response=response)


    def remove_host_group_members_command(host_group_id: str, host_ids: List[str]) -> CommandResults:
        response = change_host_group_members(action_name='remove-hosts',
                                             host_group_id=host_group_id,
                                             host_ids=host_ids)
        host_groups = response.get('resources')
        return CommandResults(outputs_prefix='CrowdStrike.HostGroup',
                              outputs_key_field='id',
                              outputs=host_groups,
                              readable_output=tableToMarkdown('Host Groups', host_groups, headers=HOST_GROUP_HEADERS),
                              raw_response=response)


    def resolve_incident_command(ids: List[str], status: str):
        resolve_incident(ids, status)
        readable = '\n'.join([f'{incident_id} changed successfully to {status}' for incident_id in ids])
        return CommandResults(readable_output=readable)


    def list_host_groups_command(filter: Optional[str] = None, offset: Optional[str] = None, limit: Optional[str] = None) \
            -> CommandResults:
        response = list_host_groups(filter, limit, offset)
        host_groups = response.get('resources')
        return CommandResults(outputs_prefix='CrowdStrike.HostGroup',
                              outputs_key_field='id',
                              outputs=host_groups,
                              readable_output=tableToMarkdown('Host Groups', host_groups, headers=HOST_GROUP_HEADERS),
                              raw_response=response)


    def delete_host_groups_command(host_group_ids: List[str]) -> CommandResults:
        response = delete_host_groups(host_group_ids)
        deleted_ids = response.get('resources')
        readable = '\n'.join([f'Host groups {host_group_id} deleted successfully' for host_group_id in deleted_ids]) \
            if deleted_ids else f'Host groups {host_group_ids} are not deleted'
        return CommandResults(readable_output=readable,
                              raw_response=response)


    def test_module():
        try:
            get_token(new_token=True)
        except ValueError:
            return 'Connection Error: The URL or The API key you entered is probably incorrect, please try again.'
        if demisto.params().get('isFetch'):
            try:
                fetch_incidents()
            except ValueError:
                return 'Error: Something is wrong with the filters you entered for the fetch incident, please try again.'
        return 'ok'


    ''' COMMANDS MANAGER / SWITCH PANEL '''

    LOG('Command being called is {}'.format(demisto.command()))


    def main():
        command = demisto.command()
        args = demisto.args()
        try:
            if command == 'test-module':
                result = test_module()
                return_results(result)
            elif command == 'fetch-incidents':
                demisto.incidents(fetch_incidents())

            elif command in ('cs-device-ran-on', 'cs-falcon-device-ran-on'):
                return_results(get_indicator_device_id())
            elif demisto.command() == 'cs-falcon-search-device':
                return_results(search_device_command())
            elif demisto.command() == 'cs-falcon-search-devices-by-mac':
                return_results(search_device_by_mac_command())
            elif command == 'cs-falcon-get-behavior':
                demisto.results(get_behavior_command())
            elif command == 'cs-falcon-search-detection':
                demisto.results(search_detections_command())
            elif command == 'cs-falcon-resolve-detection':
                demisto.results(resolve_detection_command())
            elif command == 'cs-falcon-contain-host':
                demisto.results(contain_host_command())
            elif command == 'cs-falcon-lift-host-containment':
                demisto.results(lift_host_containment_command())
            elif command == 'cs-falcon-run-command':
                demisto.results(run_command())
            elif command == 'cs-falcon-upload-script':
                demisto.results(upload_script_command())
            elif command == 'cs-falcon-get-script':
                demisto.results(get_script_command())
            elif command == 'cs-falcon-delete-script':
                demisto.results(delete_script_command())
            elif command == 'cs-falcon-list-scripts':
                demisto.results(list_scripts_command())
            elif command == 'cs-falcon-upload-file':
                demisto.results(upload_file_command())
            elif command == 'cs-falcon-delete-file':
                demisto.results(delete_file_command())
            elif command == 'cs-falcon-get-file':
                demisto.results(get_file_command())
            elif command == 'cs-falcon-list-files':
                demisto.results(list_files_command())
            elif command == 'cs-falcon-run-script':
                demisto.results(run_script_command())
            elif command == 'cs-falcon-run-get-command':
                demisto.results(run_get_command())
            elif command == 'cs-falcon-status-get-command':
                demisto.results(status_get_command())
            elif command == 'cs-falcon-status-command':
                demisto.results(status_command())
            elif command == 'cs-falcon-get-extracted-file':
                demisto.results(get_extracted_file_command())
            elif command == 'cs-falcon-list-host-files':
                demisto.results(list_host_files_command())
            elif command == 'cs-falcon-refresh-session':
                demisto.results(refresh_session_command())
            elif command == 'cs-falcon-list-detection-summaries':
                return_results(list_detection_summaries_command())
            elif command == 'cs-falcon-list-incident-summaries':
                return_results(list_incident_summaries_command())
            elif command == 'cs-falcon-search-iocs':
                return_results(search_iocs_command(**args))
            elif command == 'cs-falcon-get-ioc':
                return_results(get_ioc_command(ioc_type=args.get('type'), value=args.get('value')))
            elif command == 'cs-falcon-upload-ioc':
                return_results(upload_ioc_command(**args))
            elif command == 'cs-falcon-update-ioc':
                return_results(update_ioc_command(**args))
            elif command == 'cs-falcon-delete-ioc':
                return_results(delete_ioc_command(ioc_type=args.get('type'), value=args.get('value')))
            elif command == 'cs-falcon-search-custom-iocs':
                return_results(search_custom_iocs_command(**args))
            elif command == 'cs-falcon-get-custom-ioc':
                return_results(get_custom_ioc_command(
                    ioc_type=args.get('type'), value=args.get('value'), ioc_id=args.get('ioc_id')))
            elif command == 'cs-falcon-upload-custom-ioc':
                return_results(upload_custom_ioc_command(**args))
            elif command == 'cs-falcon-update-custom-ioc':
                return_results(update_custom_ioc_command(**args))
            elif command == 'cs-falcon-delete-custom-ioc':
                return_results(delete_custom_ioc_command(ioc_id=args.get('ioc_id')))
            elif command == 'cs-falcon-device-count-ioc':
                return_results(get_ioc_device_count_command(ioc_type=args.get('type'), value=args.get('value')))
            elif command == 'cs-falcon-process-details':
                return_results(get_process_details_command(**args))
            elif command == 'cs-falcon-processes-ran-on':
                return_results(
                    get_proccesses_ran_on_command(
                        ioc_type=args.get('type'),
                        value=args.get('value'),
                        device_id=args.get('device_id')
                    )
                )
            elif command == 'endpoint':
                return_results(get_endpoint_command())
            elif command == 'cs-falcon-create-host-group':
                return_results(create_host_group_command(**args))
            elif command == 'cs-falcon-update-host-group':
                return_results(update_host_group_command(**args))
            elif command == 'cs-falcon-list-host-groups':
                return_results(list_host_groups_command(**args))
            elif command == 'cs-falcon-delete-host-groups':
                return_results(delete_host_groups_command(host_group_ids=argToList(args.get('host_group_id'))))
            elif command == 'cs-falcon-list-host-group-members':
                return_results(list_host_group_members_command(**args))
            elif command == 'cs-falcon-add-host-group-members':
                return_results(add_host_group_members_command(host_group_id=args.get('host_group_id'),
                                                              host_ids=argToList(args.get('host_ids'))))
            elif command == 'cs-falcon-remove-host-group-members':
                return_results(remove_host_group_members_command(host_group_id=args.get('host_group_id'),
                                                                 host_ids=argToList(args.get('host_ids'))))
            elif command == 'cs-falcon-resolve-incident':
                return_results(resolve_incident_command(status=args.get('status'),
                                                        ids=argToList(args.get('ids'))))
            else:
                raise NotImplementedError(f'CrowdStrike Falcon error: '
                                          f'command {command} is not implemented')
        except Exception as e:
            return_error(str(e))


    if __name__ in ('__main__', 'builtin', 'builtins'):
        main()

    register_module_line('PANW IoT 3rd Party Integration - CrowdstrikeFalcon', 'end', __line__())
  subtype: python3
  type: python
sourcemoduleid: CrowdstrikeFalcon
