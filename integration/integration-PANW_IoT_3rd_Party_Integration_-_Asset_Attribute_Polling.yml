category: Network Security
commonfields:
  id: PANW IoT 3rd Party Integration - Asset Attribute Polling
  version: -1
configuration:
- additionalinfo: select supported protocols on this instance
  display: Protocol
  name: Mode
  options:
  - All
  - BACnet
  - CIP Ethernet/IP
  - CodeSysV3
  - FANUC Focas
  - IEC 61850 MMS
  - Mitsubishi MELSOFT TCP
  - Modbus
  - Omron FINS
  - Siemens-S7
  - Siemens-S7-Comm-Plus
  - SNMPv1
  - SNMPv2
  - SNMPv3
  - UPnP
  - WinRM
  required: true
  type: 15
- additionalinfo: 'Single port example: 161 or                                  Comma
    separated ports example: 161,162,163'
  display: ""
  name: Port
  required: false
  type: 0
- additionalinfo: IP address for performing connection test only
  display: Connection Test IP
  name: connection_test_ip
  required: false
  type: 0
- additionalinfo: Required if using SNMPv2 Polling
  display: ""
  name: SNMP Community String
  required: false
  type: 4
- additionalinfo: Required if using SNMPv3 Polling
  display: ""
  name: SNMP Username
  required: false
  type: 0
- additionalinfo: Required if using SNMPv3 Polling
  display: ""
  name: SNMP Security Level
  options:
  - noAuthNoPriv
  - authNoPriv
  - authPriv
  required: false
  type: 15
- additionalinfo: Required if using SNMPv3 Polling
  display: ""
  name: SNMP Authentication Protocol
  options:
  - MD5
  - SHA
  required: false
  type: 15
- additionalinfo: Required if using SNMPv3 Polling
  display: ""
  name: SNMP Authentication Password
  required: false
  type: 4
- additionalinfo: Required if using SNMPv3 Polling
  display: ""
  name: SNMP Privacy Protocol
  options:
  - DES
  - AES
  required: false
  type: 15
- additionalinfo: Required if using SNMPv3 Polling
  display: ""
  name: SNMP Privacy Password
  required: false
  type: 4
- additionalinfo: Required if using WinRM Polling
  display: ""
  name: WinRM Username
  required: false
  type: 0
- additionalinfo: Required if using WinRM Polling
  display: ""
  name: WinRM Password
  required: false
  type: 4
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: Learn more asset attributes with Asset Attribute Polling by using native
  protocols to poll specific assets, based on IP address, for their metadata.
detaileddescription: |2-

  Each Asset Attribute Polling instance is configured to poll using a specific protocol (or all protocols). The Job configuration includes defining IP addresses to poll and a polling interval.

  The following port values are the default ports used when polling via a given protocol. If the Port field is empty, XSOAR uses these default port numbers when probing a protocol:
  - **BACnet**: UDP port 47808
  - **CIP Ethernet/IP**: TCP port 44818, UDP port 44818
  - **CodeSysV3**: UDP port 1740
  - **FANUC Focas**: TCP port 8193
  - **IEC 61850 MMS**: TCP port 102
  - **Mitsubishi MELSOFT TCP**: TCP port 5562
  - **Modbus**: TCP port 502
  - **Omron FINS**: UDP port 9600
  - **Siemens-S7**: TCP port 102
  - **Siemens-S7-Comm-Plus**: TCP port 102
  - **SNMPv1, SNMPv2, SNMPv3**: UDP port 161
  - **UPnP**: UDP port 1900
  - **WinRM**: TCP port 5985
  - **All**: Depends on port scan results (XSOAR first does a port scan to learn which of the default ports listed above are open and active and then uses them when probing.)

  To poll on a different port from the default, enter a new number in the Port field. If you enter multiple numbers, separate them with commas. Enter only numbers from 1 to 65535 without letters or special characters. For example, "333" is valid but "TCP333" is not and will be ignored. If an entry is invalid, XSOAR ignores it and uses the default port number. It also ignores anything entered in the Port field and uses default numbers when "All" is selected.
display: PANW IoT 3rd Party Integration - Asset Attribute Polling
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAABGdBTUEAALGPC/xhBQAADNlJREFUeAHtWgtwVNUZPufefeUdoqBUYnY3m5CQClR8YalSh9aiYqCVzuALaJVqO/XB1KqjYzO2+ADro2MZtXUyPLRaRE1ttU61ZIoWBwkgIRaS3ewGH6Ahj40J2WT33tPvv8m53F13SQJi1d47k5zXf/7/nO87/zn/OQlj9mcjYCNgI2AjYCNgI2AjYCNgI2AjYCNgI2AjYCNgI2AjYCNgI2AjYCNgI2AjYCNgI2AjYCPwf4oAH828o5eW3ci5aM2vC76UTr5rfqBG5cpr+S80v5Gu/YtQF/D66oUQ5w+Nhb8Ragt/6/MaV8Dr3SEEmz5s+2+wfcnnZVsZyVBXdeBmnekP64w911MdmJcq310duJfp4learr/Ss6B8Vmq7Xc6MwNTS0gnlfv+sQIn/R+Xl5adkljz6liMSTOQyIR4k9Vj9rlSSiVzU32aYFyLXJnn0RJSXlM7tS2gfaZq+WTD9SX1AP3X0vUcv6cgkaiVXyhgkc06efBnIPtck97CAJHnuF3m7lsP9KqYBb+AcRdFzNJ07PTmerWkJTkeuBGPIk5VKwUWVrLOmXAgoF2WoG9V5XFbi/z50/dLQwVnDlYsX/3xd7ZrbGWdXIUCYiLOrEW2vFJ5YtLKhoSEubS1cuFDdsW3bRWj/AeqmYIsJQL6fcR7EfvPyJOZ9pD5SH5PyI6VlPt95QmfXwO5UwZiXCdaCuGMXE45Hg23BHdb+M2bMcPZ0dV0qNDEfspWMi1IueC9S2FbqCk4Y93vrWK19M+cTf0Sc8IlsF0ypCUVCf6cyMOcBv/8aYHsRxjWVMZ4PW42Qedvpca3cs2dPB8lVVVW54v39OboQczH2dxL9Cf+ngqwjkUtKOOe3F9YF7xMLq1zdgwPPwbp5LkMZbPJrC18MPkmyo/kCXv/1Quirh2X3Q/9mTOiHqX05Z1sUl+vS5ubmg3Re6QPxesFEIFVOljGWVkeW5yw5+UxBFpHV3dH5KOZxLfp+Cg/OeAKT/m0w0mocRZV+f9mgLl6DfMYtFUqaVI975t69ew3C0gVZtEVrTHtZjjc15Qq/KhgOr6/wVngTLPY0FvLMVBkqY3wHFaYsa24LvRAIBNwiLs5VmH6RzsU2h+IOJZ3BoyXXMPTn3XHOxIfSaCq5oma2I1pdWjvGwAseO0QuiB6UuimlCYLU+ygP4GBXqJQ3P86jmO0BWYZn+RP9A4/IcqY02tF1B5QvQ7tJrtU2FpEDC/DWMq//OtKRPW5cBImH8vJDx04sgo9lGbartMFBY6yybqQUNntIj/yB/EBNTY2SjlzImjsZxneixrWny73lFcFgcMDhYINc5fB8NYqRR0yCx0IubRnR+YHVAP0nNHAMKslzDXK3v/+0LtiSMQdenO9TFX52S7jVwxzqGdAdluBgMkuxSqdggoJx5Q9DhPI7XQr3hiLhwlAkMpFz5W4pj3bs5AuTF4LZyFiF318Ocu8wqzhvge3pZNvhUGfBtrmAMedVsD2etl54TS3G8B52q1u401EcbIucAPsnYUzmghK6WGTqHU1GqN8jPeZPOLxhfe3a66yeC7sbVbdrPHDJUzijBYdQCJ9gHp3FH6Ps3lDozebW1tdpe6fdziD4KMk1VnQmckHGQjIIAGXgNaorlKLw5c3h8FYiMRQKNQDEmww9Q78UpmnnUjY7P/d3npycEtwpV8RV9RCuG3PougGD50t5kOJqbGgoleXUNC7EbPJQWQ9yfwrb75BtAgq2jW2Z2iGXC9vnUF51O1dM8pb4Q+HwA+6EOxHw+b5b6vNdy5l+NrUPf+O+7vOdJAtHkwquz7H061I9rqVEGnlqSyTyOI6tZ2Q75jprtne2R5ZlqhxXcqWVMZCsulz1shulKG+ylrFgjOBO07R47NChGwIl3pCIJz7GdeMfdN3ARE2CqR8CjowgI2gZfnwwLOjOrKx/JdlS1VTb36D2oqKixAdtbbeVen1tMdG3H976Kgw9AW8zFoDUgX00o20pM0Jq2BuS4Q3yTJd9BOf1Mo9U/VDZd5qlbGQVuHBxaqUsYyUbARWVAZzclkfnuVKJmQoVW7bbLGbI5OTk9FubHA7HAMpC1mFvzqazKdbb9wpAXYUGv2wbDogo6h7lx3OkIOaawHaekGVKYTtpLIiQsykoa99/oF7Xxa8BihlooT+2btZk7X+seczHMj7cEFI+2Euq03XFlJeiSkFdcLnC+UOyQqafKbmc9XOuzit8sfl1qT9TGu2I4hpw+IvFYrQqMZehD5P+z1Nr1y5A6QJZh7NvpUNVzhz/tZPzscXfbtaPkIHH7ZIitJ0/VfvUZFmmVMTj06xlprDG6MGuqyB7lqzHNlmDc3gGnYucKffI+rGmqkPA15K/pPExcRo5mVWC6yxpfO4ctzkfKWcoTSX5f0UuDUqIxAp4STbl6Uzhmp4CmrITQpatix0qPGHcnXtbW7dt2bKlX9eSt2jSk+lTFbbV2iZ44n66S1Id0txEQr/b2o7D+m2M0LQNnNpbwuG7cSZup3NR5+w8q/yR8tzBeqztCEbN46LS5yuhNoQCh8cnmLfMV3qj7FNWUlYJe3S1Mz4wH2pqauqUZZmaAQaRHK0O0F74Md1zSeCYt+UxeK4cENILogc7mgMlvh3vi7bpCG4myTZM4t/BSLAed+dKjE5WZ3d3dNThoWITxluJn6tlw0gpAqrNuB/XoU81ySKdF+s71FJa4mvEEXA6qiaaOrjy+J7W1mbY/gCCRjXkx8Pu8wiw3oQ3Tcd16nJTfoSMxnlzkohg92Is38EoSnDPngYCq1w5rgdifX1LMdWTSRb6H8LYrsSu0amL+DdRbziC0cbVXyTpGy4kbQtEciZyDXlcfAEynYlMXoXMaHlYoZkcHbnUfT/gOwV6L7GSi+Uc5dz5MxJws6wXsFUfpLzxCTYXZ+JK4L4UcnhNGv3n4bjqWcE2zlVxMTQcJpfxBk9OlgEgIuhn4bmHX5wEmz8UC4grkvSMMAR4fDvm8JwUw2LJo4WGOZAn42Esvow8EngvsdoD8jMgh4VwmFy6nuFa9KLUZU2TCJYNUJAUUB2uZwra1kQXlF4dxT33OJDLnKpyIez9U9pEqmO+b6gu5+ktkZadVN8UaTqA6BAk8N1SDiAM4qR+xpOTfQbySduflEmX7g6HP+IOdSrO7hXo126VAbgf0l339LPOOBtg91IbItkwQJ4HMltMWc5i8Kpah9t1JkhLCtRMmTQZxe28nsac2gRdm6B/E9UHI5FXcb5PgdzzGE+fRVaHzC68eF0YirTeZKlPyqJP+g/b9YO4Ytyc2mpMQLAr4Mp4ohRXprZjIKMOqKhvylMlc3jcp9BLlfFEJxITmZM1YbWnJYwW4hS//1Sd8/GaojTSOUg6J0+enJc1kGU8cJSdWfbJhg0bNDpTnX1O40iK58QTkjCSt350d40J1efwOFrkM6e1XebJNuz4dF0vLCgowHV76J0cjyH5uYlcw3HmL5nfg4hft9rW8/X4rl27rESxGX5/QTfnAVXXE568vGBqu7RJt4d169b5US6YMGHCuxRzyLZMaUaCqUMqycOr8/LCvwQ3CBjr3r5+TRLJYySXbGQimNrs79gRMIOsdKpk4EWebCWXZDlWJkheDJJRgicfBbnpbH6Z6+hZFF6f39jY2AWvLdq9e3fXNDxv0pychYW9rKvLGefceAsoKi7ubG9vz0ef7o0bNxZUVFT0tLzdkrczsrN75syZWZ2dnQ562KCbRKf6Xj71xy5xiNoGBwd5Xkeevt+930ky9I8DRVpxT7q/nh3RgyXY3dVlqxDCbSXPlXUyJU+O7lj/GA76Z0dzz5X9ZPpV8mB6J2cJbQdi0fNwQD6Bs30Oynj8EC8Jpm7gTJuGAJLOy+1CUa7nutiM59Ef65r+DBzkCjzoL8Bz55+w+/8GVyQ8nKhr0QcPZewGtA8iRrhL6LyMK6IIwdgcnM3LWSKBgIt/G3oP4D18icRVpmmDLNko08K6llvSkUvt5MmIvJcdDbnUfxI7tZYe0OXPokWLDlD9l/YTYhvAX22OH09vuHu46I/vCJjuh0ftdHC+vLW1dR8a3tU0cStE3gKpt4BUPAQpF+DhaTXIxH/LDL9F45UI+hDwsxjpxd+tF+O3QMyxHXLbcV3qha6TKC4w7Q5njrhFpwofj/LwtmIMnPQjkDgeZj4XnW63u3dA1/+qcv4WHi4uy83NjfdGo1vwty9tsL9/NgbxPAjZ5lZVI8hSmLpGV/SLXar64GBCu8ednf06j/G3YnrfXbgnqW63Y1U8kRiPPg+jbzHH0ymPx/fBrW5lQimlP3LAQ4sRZMZBMv5BAZbsz0bARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBGwEbARuCzROC/A75cYaeLqTEAAAAASUVORK5CYII=
name: PANW IoT 3rd Party Integration - Asset Attribute Polling
script:
  commands:
  - arguments:
    - description: ip or subnet to probe
      name: ip
      required: true
    - description: protocol to probe
      name: proto
      required: true
    - description: optional port for protocol to probe
      name: port
    description: 'OT probing for fetches device info for device specified by protocol,
      ip, port '
    name: fetch-device-info-command
    outputs:
    - contextPath: Device_Polling.DeviceInfo
      description: List of device info
  - arguments: []
    name: test-command
  - arguments: []
    name: get-instance-port
  - arguments: []
    name: get-instance-protocol
  dockerimage: demisto/panw-iot:1.0.0.79918
  runonce: true
  script: |
    register_module_line('PANW IoT 3rd Party Integration - Asset Attribute Polling', 'start', __line__())


    ''' IMPORTS '''

    import datetime
    import struct
    import socket
    import time
    from binascii import unhexlify
    import snap7
    from pysnmp.hlapi import *
    import winrm
    from urllib.parse import urlparse


    ''' CONSTANTS '''
    default_protocols = {'BACnet': 47808,
                         'CIP Ethernet/IP': 44818,
                         'CodeSysV3': 1740,
                         'FANUC Focas': 8193,
                         'IEC 61850 MMS': 102,
                         'Mitsubishi MELSOFT TCP': 5562,
                         'Mitsubishi MELSOFT UDP': 5560,
                         'Modbus': 502,
                         'Omron FINS': 9600,
                         'SNMPv1': 161,
                         'SNMPv2': 161,
                         'SNMPv3': 161,
                         'Siemens-S7': 102,
                         'Siemens-S7-Comm-Plus': 102,
                         'UPnP': 1900,
                         'WinRM': 5985,
                         'All': 0}
    req_attributes = ['vendor', 'model']
    cip_vendor_id_mapping = {
        0: "Reserved",
        1: "Rockwell Automation/Allen-Bradley",
        2: "Namco Controls Corp.",
        3: "Honeywell Inc.",
        4: "Parker Hannifin Corp. (Veriflo Division)",
        5: "Rockwell Automation/Reliance Elec.",
        6: "Reserved",
        7: "SMC Corporation",
        8: "Molex Incorporated",
        9: "Western Reserve Controls Corp.",
        10: "Advanced Micro Controls Inc. (AMCI)",
        11: "ASCO Pneumatic Controls",
        12: "Banner Engineering Corp.",
        13: "Belden Wire & Cable Company",
        14: "Cooper Interconnect",
        15: "Reserved",
        16: "Daniel Woodhead Co. (Woodhead Connectivity)",
        17: "Dearborn Group Inc.",
        18: "Reserved",
        19: "Helm Instrument Company",
        20: "Huron Net Works",
        21: "Lumberg Inc.",
        22: "Online Development Inc.(Automation Value)",
        23: "Vorne Industries Inc.",
        24: "ODVA Special Reserve",
        25: "Reserved",
        26: "Festo Corporation",
        27: "Reserved",
        28: "Reserved",
        29: "Reserved",
        30: "Unico Inc.",
        31: "Ross Controls",
        32: "Reserved",
        33: "Reserved",
        34: "Hohner Corp.",
        35: "Micro Mo Electronics Inc.",
        36: "MKS Instruments Inc.",
        37: "Yaskawa Electric America formerly Magnetek Drives",
        38: "Reserved",
        39: "AVG Automation (Uticor)",
        40: "Wago Corporation",
        41: "Kinetics (Unit Instruments)",
        42: "IMI Norgren Limited",
        43: "BALLUFF Inc.",
        44: "Yaskawa Electric America Inc.",
        45: "Eurotherm Controls Inc",
        46: "ABB Industrial Systems",
        47: "Omron Corporation",
        48: "TURCk Inc.",
        49: "Grayhill Inc.",
        50: "Real Time Automation (C&ID)",
        51: "Reserved",
        52: "Numatics Inc.",
        53: "Lutze Inc.",
        54: "Reserved",
        55: "Reserved",
        56: "Softing GmbH",
        57: "Pepperl + Fuchs",
        58: "Spectrum Controls Inc.",
        59: "D.I.P. Inc. MKS Inst.",
        60: "Applied Motion Products Inc.",
        61: "Sencon Inc.",
        62: "High Country Tek",
        63: "SWAC Automation Consult GmbH",
        64: "Clippard Instrument Laboratory",
        65: "Reserved",
        66: "Reserved",
        67: "Reserved",
        68: "Eaton Electrical",
        69: "Reserved",
        70: "Reserved",
        71: "Toshiba International Corp.",
        72: "Control Technology Incorporated",
        73: "TCS (NZ) Ltd.",
        74: "HitachiLtd.",
        75: "ABB Robotics Products AB",
        76: "NKE Corporation",
        77: "Rockwell Software Inc.",
        78: "Escort Memory Systems (A Datalogic Group Co.)",
        79: "Berk-Tek",
        80: "Industrial Devices Corporation",
        81: "IXXAT Automation GmbH",
        82: "Mitsubishi Electric Automation Inc.",
        83: "OPTO-22",
        84: "Reserved",
        85: "Reserved",
        86: "Horner Electric",
        87: "Burkert Werke GmbH & Co. KG",
        88: "Industrial Indexing Systems, Inc.",
        89: "Industrial Indexing Systems Inc.",
        90: "HMS Industrial Networks AB",
        91: "Robicon",
        92: "Helix Technology (Granville-Phillips)",
        93: "Arlington Laboratory",
        94: "Advantech Co. Ltd.",
        95: "Square D Company",
        96: "Digital Electronics Corp.",
        97: "Danfoss",
        98: "Reserved",
        99: "Reserved",
        100: "Bosch Rexroth Corporation: Pneumatics",
        101: "Applied Materials Inc.",
        102: "Showa Electric Wire & Cable Co.",
        103: "Pacific Scientific (API Controls Inc.)",
        104: "Sharp Manufacturing Systems Corp.",
        105: "Olflex Wire & Cable Inc.",
        106: "Reserved",
        107: "Unitrode",
        108: "Beckhoff Automation GmbH",
        109: "National Instruments",
        110: "Mykrolis Corporations (Millipore)",
        111: "International Motion Controls Corp.",
        112: "Reserved",
        113: "SEG Kempen GmbH",
        114: "Reserved",
        115: "Reserved",
        116: "MTS Systems Corp.",
        117: "Krones Inc",
        118: "Reserved",
        119: "EXOR Electronic R & D",
        120: "SIEI S.p.A.",
        121: "KUKA Roboter GmbH",
        122: "Reserved",
        123: "SEC (Samsung Electronics Co.Ltd)",
        124: "Binary Electronics Ltd",
        125: "Flexible Machine Controls",
        126: "Reserved",
        127: "ABB Inc. (Entrelec)",
        128: "MAC Valves Inc.",
        129: "Auma Actuators Inc",
        130: "Toyoda Machine WorksLtd",
        131: "Reserved",
        132: "Reserved",
        133: "Balogh T.A.G.: Corporation",
        134: "TR Systemtechnik GmbH",
        135: "UNIPULSE Corporation",
        136: "Reserved",
        137: "Reserved",
        138: "Conxall Corporation Inc.",
        139: "Reserved",
        140: "Reserved",
        141: "Kuramo Electric Co.Ltd.",
        142: "Creative Micro Designs",
        143: "GE Industrial Systems",
        144: "Leybold Vacuum GmbH",
        145: "Siemens Energy & Automation/Drives",
        146: "Kodensha Ltd",
        147: "Motion Engineering Inc.",
        148: "Honda Engineering Co.Ltd",
        149: "EIM Valve Controls",
        150: "Melec Inc.",
        151: "Sony Manufacturing Systems Corporation",
        152: "North American Mfg.",
        153: "WATLOW",
        154: "Japan Radio Co.Ltd",
        155: "NADEX Co.Ltd",
        156: "Ametek Automation & Process Technologies",
        157: "FACTS, Inc.",
        158: "KVASER AB",
        159: "IDEC IZUMI Corporation",
        160: "Mitsubishi Heavy Industries Ltd",
        161: "Mitsubishi Electric Corporation",
        162: "Horiba-STEC Inc.",
        163: "esd electronic system design gmbh",
        164: "DAIHEN Corporation",
        165: "Tyco Valves & Controls/Keystone",
        166: "EBARA Corporation",
        167: "Reserved",
        168: "Reserved",
        169: "Hokuyo Electric Co. Ltd",
        170: "Pyramid Solutions Inc.",
        171: "Denso Wave Incorporated",
        172: "HLS Hard-Line Solutions Inc",
        173: "Caterpillar Inc.",
        174: "PDL Electronics Ltd.",
        175: "Reserved",
        176: "Red Lion Controls",
        177: "ANELVA Corporation",
        178: "Toyo Denki Seizo KK",
        179: "Sanyo Denki Co.Ltd",
        180: "Advanced Energy Japan K.K. (Aera Japan)",
        181: "Pilz GmbH & Co",
        182: "Marsh Bellofram-Bellofram PCD Division",
        183: "Reserved",
        184: "M-SYSTEM Co. Ltd",
        185: "Nissin Electric Co.Ltd",
        186: "Hitachi Metals Ltd.",
        187: "Oriental Motor Company",
        188: "A&D Co.Ltd",
        189: "Phasetronics Inc.",
        190: "Cummins Engine Company",
        191: "Deltron Inc.",
        192: "Geneer Corporation",
        193: "Anatol Automation Inc.",
        194: "Reserved",
        195: "Reserved",
        196: "Medar Inc.",
        197: "Comdel Inc.",
        198: "Advanced Energy Industries Inc",
        199: "Reserved",
        200: "DAIDEN Co.Ltd",
        201: "CKD Corporation",
        202: "Toyo Electric Corporation",
        203: "Reserved",
        204: "AuCom Electronics Ltd",
        205: "Shinko Electric Co.Ltd",
        206: "Vector Informatik GmbH",
        207: "Reserved",
        208: "Moog Inc.",
        209: "Contemporary Controls",
        210: "Tokyo Sokki Kenkyujo Co.Ltd",
        211: "Schenck-AccuRate Inc.",
        212: "The Oilgear Company",
        213: "Reserved",
        214: "ASM Japan K.K.",
        215: "HIRATA Corp.",
        216: "SUNX Limited",
        217: "Meidensha Corp.",
        218: "NIDEC SANKYO CORPORATION (Sankyo Seiki Mfg. Co.Ltd)",
        219: "KAMRO Corp.",
        220: "Nippon System Development Co.Ltd",
        221: "EBARA Technologies Inc.",
        222: "Reserved",
        223: "Reserved",
        224: "SG Co.Ltd",
        225: "Vaasa Institute of Technology",
        226: "MKS Instruments (ENI Technology)",
        227: "Tateyama System Laboratory Co.Ltd.",
        228: "QLOG Corporation",
        229: "Matric Limited Inc.",
        230: "NSD Corporation",
        231: "Reserved",
        232: "Sumitomo Wiring SystemsLtd",
        233: "Group 3 Technology Ltd",
        234: "CTI Cryogenics",
        235: "POLSYS CORP",
        236: "Ampere Inc.",
        237: "Reserved",
        238: "Simplatroll Ltd",
        239: "Reserved",
        240: "Reserved",
        241: "Leading Edge Design",
        242: "Humphrey Products",
        243: "Schneider Automation Inc.",
        244: "Westlock Controls Corp.",
        245: "Nihon Weidmuller Co.Ltd",
        246: "Brooks Instrument (Div. of Emerson)",
        247: "Reserved",
        248: " Moeller GmbH",
        249: "Varian Vacuum Products",
        250: "Yokogawa Electric Corporation",
        251: "Electrical Design Daiyu Co.Ltd",
        252: "Omron Software Co.Ltd",
        253: "BOC Edwards",
        254: "Control Technology Corporation",
        255: "Bosch Rexroth",
        256: "Turck",
        257: "Control Techniques PLC",
        258: "Hardy Instruments Inc.",
        259: "LS Industrial Systems",
        260: "E.O.A. Systems Inc.",
        261: "Reserved",
        262: "New Cosmos Electric Co.Ltd.",
        263: "Sense Eletronica LTDA",
        264: "Xycom Inc.",
        265: "Baldor Electric",
        266: "Reserved",
        267: "Patlite Corporation",
        268: "Reserved",
        269: "Mogami Wire & Cable Corporation",
        270: "Welding Technology Corporation (WTC)",
        271: "Reserved",
        272: "Deutschmann Automation GmbH",
        273: "ICP Panel-Tec Inc.",
        274: "Bray Controls USA",
        275: "Reserved",
        276: "Status Technologies",
        277: "Trio Motion Technology Ltd",
        278: "Sherrex Systems Ltd",
        279: "Adept Technology Inc.",
        280: "Spang Power Electronics",
        281: "Reserved",
        282: "Acrosser Technology Co.Ltd",
        283: "Hilscher GmbH",
        284: "IMAX Corporation",
        285: "Electronic Innovation Inc. (Falter Engineering)",
        286: "Netlogic Inc.",
        287: "Bosch Rexroth Corporation: Indramat",
        288: "Reserved",
        289: "Reserved",
        290: "Murata  Machinery Ltd.",
        291: "MTT Company Ltd.",
        292: "Kanematsu Semiconductor Corp.",
        293: "Takebishi Electric Sales Co.",
        294: "Tokyo Electron Device Ltd",
        295: "PFU Limited",
        296: "Hakko Automation Co.Ltd.",
        297: "Advanet Inc.",
        298: "Tokyo Electron Software Technologies Ltd.",
        299: "Reserved",
        300: "Shinagawa Electric Wire Co.Ltd.",
        301: "Yokogawa M&C Corporation",
        302: "KONAN Electric Co.Ltd.",
        303: "Binar Elektronik AB",
        304: "Furukawa Electric Co.",
        305: "Cooper Energy Services",
        306: "Schleicher GmbH & Co.",
        307: "Hirose Electric Co.Ltd",
        308: "Western Servo Design Inc.",
        309: "Prosoft Technology",
        310: "Reserved",
        311: "Towa Shoko Co.Ltd",
        312: "Kyopal Co.Ltd",
        313: "Extron Co.",
        314: "Wieland Electric GmbH",
        315: "SEW Eurodrive GmbH",
        316: "Aera Corporation",
        317: "STA Reutlingen",
        318: "Reserved",
        319: "Fuji Electric Co.Ltd.",
        320: "Reserved",
        321: "Reserved",
        322: "ifm efector: inc.",
        323: "Reserved",
        324: "IDEACOD-Hohner Automation S.A.",
        325: "CommScope Inc.",
        326: "GE Fanuc Automation North America Inc.",
        327: "Matsushita Electric Industrial Co.Ltd",
        328: "Okaya Electronics Corporation",
        329: "KASHIYAMA IndustriesLtd",
        330: "JVC",
        331: "Interface Corporation",
        332: "Grape Systems Inc.",
        333: "Reserved",
        334: "KEBA AG",
        335: "Toshiba IT & Control Systems Corporation",
        336: "Sanyo Machine WorksLtd.",
        337: "Vansco Electronics Ltd.",
        338: "Dart Container Corp.",
        339: "Livingston & Co. Inc.",
        340: "Alfa Laval LKM as",
        341: "BF ENTRON Ltd. (British Federal)",
        342: "Bekaert Engineering NV",
        343: "Ferran  Scientific Inc.",
        344: "KEBA AG",
        345: "Endress + Hauser",
        346: "Lincoln Electric Company",
        347: "ABB ALSTOM Power UK Ltd. (EGT)",
        348: "Berger Lahr GmbH",
        349: "Reserved",
        350: "Federal Signal Corp.",
        351: "Kawasaki Robotics (USA) Inc.",
        352: "Bently Nevada Corporation",
        353: "Reserved",
        354: "FRABA Posital GmbH",
        355: "Elsag Bailey Inc.",
        356: "Fanuc Robotics America",
        357: "Reserved",
        358: "Surface Combustion Inc.",
        359: "Reserved",
        360: "AILES Electronics Ind. Co.Ltd.",
        361: "Wonderware Corporation",
        362: "Particle Measuring Systems Inc.",
        363: "Reserved",
        364: "Reserved",
        365: "BITS Co.Ltd",
        366: "Japan Aviation Electronics Industry Ltd",
        367: "Keyence Corporation",
        368: "Kuroda Precision Industries Ltd.",
        369: "Mitsubishi Electric Semiconductor Application",
        370: "Nippon Seisen CableLtd.",
        371: "Omron ASO Co.Ltd",
        372: "Seiko Seiki Co.Ltd.",
        373: "Sumitomo Heavy IndustriesLtd.",
        374: "Tango Computer Service Corporation",
        375: "Technology Service Inc.",
        376: "Toshiba Information Systems (Japan) Corporation",
        377: "TOSHIBA Schneider Inverter Corporation",
        378: "Toyooki Kogyo Co.Ltd.",
        379: "XEBEC",
        380: "Madison Cable Corporation",
        381: "Hitati Engineering & Services Co.Ltd",
        382: "TEM-TECH Lab Co.Ltd",
        383: "International Laboratory Corporation",
        384: "Dyadic Systems Co.Ltd.",
        385: "SETO Electronics Industry Co.Ltd",
        386: "Tokyo Electron Kyushu Limited",
        387: "KEI System Co.Ltd",
        388: "Reserved",
        389: "Asahi Engineering Co.Ltd",
        390: "Contrex Inc.",
        391: "Paradigm Controls Ltd.",
        392: "Reserved",
        393: "Ohm Electric Co.Ltd.",
        394: "RKC Instrument Inc.",
        395: "Suzuki Motor Corporation",
        396: "Custom Servo Motors Inc.",
        397: "PACE Control Systems",
        398: "Selectron Systems AG",
        399: "Reserved",
        400: "LINTEC Co.Ltd.",
        401: "Hitachi Cable Ltd.",
        402: "BUSWARE Direct",
        403: "Eaton Electric B.V. (former Holec Holland N.V.)",
        404: "VAT Vakuumventile AG",
        405: "Scientific Technologies Incorporated",
        406: "Alfa Instrumentos Eletronicos Ltda",
        407: "TWK Elektronik GmbH",
        408: "ABB Welding Systems AB",
        409: "BYSTRONIC Maschinen AG",
        410: "Kimura Electric Co.Ltd",
        411: "Nissei Plastic Industrial Co.Ltd",
        412: "Reserved",
        413: "Kistler-Morse Corporation",
        414: "Proteous Industries Inc.",
        415: "IDC Corporation",
        416: "Nordson Corporation",
        417: "Rapistan Systems",
        418: "LP-Elektronik GmbH",
        419: "GERBI & FASE S.p.A.(Fase Saldatura)",
        420: "Phoenix Digital Corporation",
        421: "Z-World Engineering",
        422: "Honda R&D Co.Ltd.",
        423: "Bionics Instrument Co.Ltd.",
        424: "Teknic Inc.",
        425: "R.Stahl Inc.",
        426: "Reserved",
        427: "Ryco Graphic Manufacturing Inc.",
        428: "Giddings & Lewis Inc.",
        429: "Koganei Corporation",
        430: "Reserved",
        431: "Nichigoh Communication Electric Wire Co.Ltd.",
        432: "Reserved",
        433: "Fujikura Ltd.",
        434: "AD Link Technology Inc.",
        435: "StoneL Corporation",
        436: "Computer Optical Products Inc.",
        437: "CONOS Inc.",
        438: "Erhardt + Leimer GmbH",
        439: "UNIQUE Co. Ltd",
        440: "Roboticsware Inc.",
        441: "Nachi Fujikoshi Corporation",
        442: "Hengstler GmbH",
        443: "Vacon Plc",
        444: "SUNNY GIKEN Inc.",
        445: "Lenze Drive Systems GmbH",
        446: "CD Systems B.V.",
        447: "FMT/Aircraft Gate Support Systems AB",
        448: "Axiomatic Technologies Corp",
        449: "Embedded System Products Inc.",
        450: "Reserved",
        451: "Mencom Corporation",
        452: "Kollmorgen",
        453: "Matsushita Welding Systems Co.Ltd.",
        454: "Dengensha Mfg. Co. Ltd.",
        455: "Quinn Systems Ltd.",
        456: "Tellima Technology Ltd",
        457: "MDT: Software",
        458: "Taiwan Keiso Co.Ltd",
        459: "Pinnacle Systems",
        460: "Ascom Hasler Mailing Sys",
        461: "INSTRUMAR Limited",
        462: "Reserved",
        463: "Navistar International Transportation Corp",
        464: "Huettinger Elektronik GmbH + Co. KG",
        465: "OCM Technology Inc.",
        466: "Professional Supply Inc.",
        467: "Control Solutions",
        468: "Baumer IVO GmbH & Co. KG",
        469: "Worcester Controls Corporation",
        470: "Pyramid Technical Consultants Inc.",
        471: "Eilersen Electric A/S",
        472: "Apollo Fire Detectors Limited",
        473: "Avtron Manufacturing Inc.",
        474: "Reserved",
        475: "Tokyo Keiso Co.Ltd.",
        476: "Daishowa Swiki Co.Ltd.",
        477: "Kojima Instruments Inc.",
        478: "Shimadzu Corporation",
        479: "Tatsuta Electric Wire & Cable Co.Ltd.",
        480: "MECS Corporation",
        481: "Tahara Electric",
        482: "Koyo Electronics",
        483: "Clever Devices",
        484: "GCD Hardware & Software GmbH",
        485: "Reserved",
        486: "Miller Electric Mfg Co.",
        487: "GEA Tuchenhagen GmbH",
        488: "Riken Keiki Co.: LTD",
        489: "Keisokugiken Corporation",
        490: "Fuji Machine Mfg. Co.Ltd",
        491: "Reserved",
        492: "Nidec-Shimpo Corp.",
        493: "UTEC Corporation",
        494: "Sanyo Electric Co. Ltd.",
        495: "Reserved",
        496: "Reserved",
        497: "Okano Electric Wire Co. Ltd",
        498: "Shimaden Co. Ltd.",
        499: "Teddington Controls Ltd",
        500: "Reserved",
        501: "VIPA GmbH",
        502: "Warwick Manufacturing Group",
        503: "Danaher Controls",
        504: "Reserved",
        505: "Reserved",
        506: "American Science & Engineering",
        507: "Accutron Controls International Inc.",
        508: "Norcott Technologies Ltd",
        509: "TB Woods Inc",
        510: "Proportion-Air Inc.",
        511: "SICK Stegmann GmbH",
        512: "Reserved",
        513: "Edwards Signaling",
        514: "Sumitomo Metal IndustriesLtd",
        515: "Cosmo Instruments Co.Ltd.",
        516: "Denshosha Co.Ltd.",
        517: "Kaijo Corp.",
        518: "Michiproducts Co.Ltd.",
        519: "Miura Corporation",
        520: "TG Information Network Co.Ltd.",
        521: "Fujikin  Inc.",
        522: "Estic Corp.",
        523: "GS Hydraulic Sales",
        524: "Leuze Electronic GmbH & Co. KG",
        525: "MTE Limited",
        526: "Hyde Park Electronics Inc.",
        527: "Pfeiffer Vacuum GmbH",
        528: "Cyberlogic Technologies",
        529: "OKUMA Corporation FA Systems Division",
        530: "Reserved",
        531: "Hitachi Kokusai Electric Co.Ltd.",
        532: "SHINKO TECHNOS Co.Ltd.",
        533: "Itoh Electric Co.Ltd.",
        534: "Colorado Flow Tech Inc.",
        535: "Love Controls Division/Dwyer Inst.",
        536: "Alstom Drives and Controls",
        537: "The Foxboro Company",
        538: "Tescom Corporation",
        539: "Reserved",
        540: "Atlas Copco Controls UK",
        541: "Reserved",
        542: "Autojet Technologies",
        543: "Prima Electronics S.p.A.",
        544: "PMA GmbH",
        545: "Shimafuji Electric Co.Ltd",
        546: "Oki Electric Industry Co.Ltd",
        547: "Kyushu Matsushita Electric Co.Ltd",
        548: "Nihon Electric Wire & Cable Co.Ltd",
        549: "Tsuken Electric Ind Co.Ltd",
        550: "Tamadic Co.",
        551: "MAATEL SA",
        552: "OKUMA America",
        553: "Control Techniques PLC-NA",
        554: "TPC Wire & Cable",
        555: "ATI Industrial Automation",
        556: "Microcontrol (Australia) Pty Ltd",
        557: "Serra Soldadura: S.A.",
        558: "Southwest Research Institute",
        559: "Cabinplant International",
        560: "Sartorius Mechatronics T&H GmbH",
        561: "Comau S.p.A. Robotics & Final Assembly Division",
        562: "Phoenix Contact",
        563: "Yokogawa MAT Corporation",
        564: "asahi sangyo co.: ltd.",
        565: "Reserved",
        566: "Akita Myotoku Ltd.",
        567: "OBARA Corp.",
        568: "Suetron Electronic GmbH",
        569: "Reserved",
        570: "Serck Controls Limited",
        571: "Fairchild Industrial Products Company",
        572: "ARO S.A.",
        573: "M2C GmbH",
        574: "Shin Caterpillar Mitsubishi Ltd.",
        575: "Santest Co.Ltd.",
        576: "Cosmotechs Co.Ltd.",
        577: "Hitachi Electric Systems",
        578: "Smartscan Ltd",
        579: "Woodhead Software & Electronics France",
        580: "Athena Controls Inc.",
        581: "Syron Engineering & Manufacturing Inc.",
        582: "Asahi Optical Co.Ltd.",
        583: "Sansha Electric Mfg. Co.Ltd.",
        584: "Nikki Denso Co.Ltd.",
        585: "Star Micronics: Co.Ltd.",
        586: "Ecotecnia Socirtat Corp.",
        587: "AC Technology Corp.",
        588: "West Instruments Limited",
        589: "NTI Limited",
        590: "Delta Computer Systems Inc.",
        591: "FANUC Ltd.",
        592: "Hearn-Gu Lee",
        593: "ABB Automation Products",
        594: "Orion Machinery Co.Ltd.",
        595: "Reserved",
        596: "Wire-Pro Inc.",
        597: "Beijing Huakong Technology Co. Ltd.",
        598: "Yokoyama Shokai Co.Ltd.",
        599: "Toyogiken Co.Ltd.",
        600: "Coester Equipamentos Eletronicos Ltda.",
        601: "Kawasaki Heavy Industries, Ltd.",
        602: "Electroplating Engineers of Japan Ltd.",
        603: "ROBOX S.p.A.",
        604: "Spraying Systems Company",
        605: "Benshaw Inc.",
        606: "ZPA-DP A.S.",
        607: "Wired Rite Systems",
        608: "Tandis Research Inc.",
        609: "SSD Drives GmbH",
        610: "ULVAC Japan Ltd.",
        611: "DYNAX Corporation",
        612: "Nor-Cal Products Inc.",
        613: "Aros Electronics AB",
        614: "Jun-Tech Co.Ltd.",
        615: "HAN-MI Co. Ltd.",
        616: "uniNtech (formerly SungGi Internet)",
        617: "Hae Pyung Electronics Reserch Institute",
        618: "Milwaukee Electronics",
        619: "OBERG Industries",
        620: "Parker Hannifin/Compumotor Division",
        621: "TECHNO DIGITAL CORPORATION",
        622: "Network Supply Co.Ltd.",
        623: "Union Electronics Co.Ltd.",
        624: "Tritronics Services PM Ltd.",
        625: "Rockwell Automation-Sprecher+Schuh",
        626: "Matsushita Electric Industrial Co.Ltd/Motor Co.",
        627: "Rolls-Royce Energy Systems Inc.",
        628: "JEONGIL INTERCOM CO.: LTD",
        629: "Interroll Corp.",
        630: "Hubbell Wiring Device-Kellems (Delaware)",
        631: "Intelligent Motion Systems",
        632: "Reserved",
        633: "INFICON AG",
        634: "Hirschmann Inc.",
        635: "The Siemon Company",
        636: "YAMAHA Motor Co. Ltd.",
        637: "aska corporation",
        638: "Woodhead Connectivity",
        639: "Trimble AB",
        640: "Murrelektronik GmbH",
        641: "Creatrix Labs Inc.",
        642: "TopWorx",
        643: "Kumho Industrial Co.Ltd.",
        644: "Wind River Systems Inc.",
        645: "Bihl & Wiedemann GmbH",
        646: "Harmonic Drive Systems Inc.",
        647: "Rikei Corporation",
        648: "BL AutotecLtd.",
        649: "Hana Information & Technology Co.Ltd.",
        650: "Seoil Electric Co.Ltd.",
        651: "Fife Corporation",
        652: "Shanghai Electrical Apparatus Research Institute",
        653: "Detector Electronics",
        654: "Parasense Development Centre",
        655: "Reserved",
        656: "Reserved",
        657: "Six Tau S.p.A.",
        658: "Aucos GmbH",
        659: "Rotork Controls",
        660: "Automationdirect.com",
        661: "Thermo BLH",
        662: "System ControlsLtd.",
        663: "Univer S.p.A.",
        664: "MKS-Tenta Technology",
        665: "Lika Electronic SNC",
        666: "Mettler-Toledo Inc.",
        667: "DXL USA Inc.",
        668: "Rockwell Automation/Entek IRD Intl.",
        669: "Nippon Otis Elevator Company",
        670: "Sinano Electric: Co.Ltd.",
        671: "Sony Manufacturing Systems",
        672: "Reserved",
        673: "Contec Co.Ltd.",
        674: "Automated Solutions",
        675: "Controlweigh",
        676: "Reserved",
        677: "Fincor Electronics",
        678: "Cognex Corporation",
        679: "Qualiflow",
        680: "Weidmuller Inc.",
        681: "Morinaga Milk Industry Co.Ltd.",
        682: "Takagi Industrial Co.Ltd.",
        683: "Wittenstein AG",
        684: "Sena Technologies Inc.",
        685: "Reserved",
        686: "APV Products Unna",
        687: "Creator Teknisk Utvedkling AB",
        688: "Reserved",
        689: "Mibu Denki Industrial Co.Ltd.",
        690: "Takamastsu Machineer Section",
        691: "Startco Engineering Ltd.",
        692: "Reserved",
        693: "Holjeron",
        694: "ALCATEL High Vacuum Technology",
        695: "Taesan LCD Co.Ltd.",
        696: "POSCON",
        697: "VMIC",
        698: "Matsushita Electric WorksLtd.",
        699: "IAI Corporation",
        700: "Horst GmbH",
        701: "MicroControl GmbH & Co.",
        702: "Leine & Linde AB",
        703: "Reserved",
        704: "EC Elettronica Srl",
        705: "VIT Software HB",
        706: "Bronkhorst High-Tech B.V.",
        707: "Optex Co.Ltd.",
        708: "Yosio Electronic Co.",
        709: "Terasaki Electric Co.Ltd.",
        710: "Sodick Co.Ltd.",
        711: "MTS Systems Corporation-Automation Division",
        712: "Mesa Systemtechnik",
        713: "SHIN HO SYSTEM Co.Ltd.",
        714: "Goyo Electronics CoLtd.",
        715: "Loreme",
        716: "SAB Brockskes GmbH & Co. KG",
        717: "Trumpf Laser GmbH + Co. KG",
        718: "Niigata Electronic Instruments Co.Ltd.",
        719: "Yokogawa Digital Computer Corporation",
        720: "O.N. Electronic Co.Ltd.",
        721: "Industrial Control  Communication Inc.",
        722: "ABB Inc.",
        723: "ElectroWave USA Inc.",
        724: "Industrial Network Controls: LLC",
        725: "KDT Systems Co.Ltd.",
        726: "SEFA Technology Inc.",
        727: "Nippon POP Rivets and Fasteners Ltd.",
        728: "Yamato Scale Co.Ltd.",
        729: "Zener Electric",
        730: "GSE Scale Systems",
        731: "ISAS (Integrated Switchgear & Sys. Pty Ltd)",
        732: "Beta LaserMike Limited",
        733: "TOEI Electric Co.Ltd.",
        734: "Hakko Electronics Co.Ltd",
        735: "Reserved",
        736: "RFID Inc.",
        737: "Adwin Corporation",
        738: "Osaka VacuumLtd.",
        739: "A-Kyung Motion Inc.",
        740: "Camozzi S.P. A.",
        741: "Crevis Co.: LTD",
        742: "Rice Lake Weighing Systems",
        743: "Linux Network Services",
        744: "KEB Antriebstechnik GmbH",
        745: "Hagiwara Electric Co.Ltd.",
        746: "Glass Inc. International",
        747: "Reserved",
        748: "DVT Corporation",
        749: "Woodward Governor",
        750: "Mosaic Systems Inc.",
        751: "Laserline GmbH",
        752: "COM-TEC Inc.",
        753: "Weed Instrument",
        754: "Prof-face European Technology Center",
        755: "Fuji Automation Co.Ltd.",
        756: "Matsutame Co.Ltd.",
        757: "Hitachi Via MechanicsLtd.",
        758: "Dainippon Screen Mfg. Co. Ltd.",
        759: "FLS Automation A/S",
        760: "ABB Stotz Kontakt GmbH",
        761: "Technical Marine Service",
        762: "Advanced Automation Associates Inc.",
        763: "Baumer Ident GmbH",
        764: "Tsubakimoto Chain Co.",
        765: "Reserved",
        766: "Furukawa Co.Ltd.",
        767: "Active Power",
        768: "CSIRO Mining Automation",
        769: "Matrix Integrated Systems",
        770: "Digitronic Automationsanlagen GmbH",
        771: "SICK STEGMANN Inc.",
        772: "TAE-Antriebstechnik GmbH",
        773: "Electronic Solutions",
        774: "Rocon L.L.C.",
        775: "Dijitized Communications Inc.",
        776: "Asahi Organic Chemicals Industry Co.Ltd.",
        777: "Hodensha",
        778: "Harting Inc. NA",
        779: "Kubler GmbH",
        780: "Yamatake Corporation",
        781: "JEOL",
        782: "Yamatake Industrial Systems Co.Ltd.",
        783: "HAEHNE Elektronische Messgerate GmbH",
        784: "Ci Technologies Pty Ltd (for Pelamos Industries)",
        785: "N. SCHLUMBERGER & CIE",
        786: "Teijin Seiki Co.Ltd.",
        787: "DAIKIN IndustriesLtd",
        788: "RyuSyo Industrial Co.Ltd.",
        789: "SAGINOMIYA SEISAKUSHO: INC.",
        790: "Seishin Engineering Co.Ltd.",
        791: "Japan Support System Ltd.",
        792: "Decsys",
        793: "Metronix Messgerate u. Elektronik GmbH",
        794: "ROPEX Industrie - Elektronik GmbH",
        795: "Vaccon Company Inc.",
        796: "Siemens Energy & Automation Inc.",
        797: "Ten X Technology Inc.",
        798: "Tyco Electronics",
        799: "Delta Power Electronics Center",
        800: "Denker",
        801: "Autonics Corporation",
        802: "JFE Electronic Engineering Pty. Ltd.",
        803: "Reserved",
        804: "Electro-Sensors Inc.",
        805: "Digi International Inc.",
        806: "Texas Instruments",
        807: "ADTEC Plasma Technology Co.Ltd",
        808: "SICK AG",
        809: "Ethernet Peripherals Inc.",
        810: "Animatics Corporation",
        811: "Reserved",
        812: "Process Control Corporation",
        813: "SystemV. Inc.",
        814: "Danaher Motion SRL",
        815: "SHINKAWA Sensor Technology Inc.",
        816: "Tesch GmbH & Co. KG",
        817: "Reserved",
        818: "Trend Controls Systems Ltd.",
        819: "Guangzhou ZHIYUAN Electronic Co.Ltd.",
        820: "Mykrolis Corporation",
        821: "Bethlehem Steel Corporation",
        822: "KK ICP",
        823: "Takemoto Denki Corporation",
        824: "The Montalvo Corporation",
        825: "Reserved",
        826: "LEONI Special Cables GmbH",
        827: "Reserved",
        828: "ONO SOKKI CO.,LTD.",
        829: "Rockwell Samsung Automation",
        830: "SHINDENGEN ELECTRIC MFG. CO. LTD",
        831: "Origin Electric Co. Ltd.",
        832: "Quest Technical Solutions Inc.",
        833: "LS CableLtd.",
        834: "Enercon-Nord Electronic GmbH",
        835: "Northwire Inc.",
        836: "Engel Elektroantriebe GmbH",
        837: "The Stanley Works",
        838: "Celesco Transducer Products Inc.",
        839: "Chugoku Electric Wire and Cable Co.",
        840: "Kongsberg Simrad AS",
        841: "Panduit Corporation",
        842: "Spellman High Voltage Electronics Corp.",
        843: "Kokusai Electric Alpha Co.Ltd.",
        844: "Brooks Automation Inc.",
        845: "ANYWIRE CORPORATION",
        846: "Honda Electronics Co. Ltd",
        847: "REO Elektronik AG",
        848: "Fusion UV Systems Inc.",
        849: "ASI Advanced Semiconductor Instruments GmbH",
        850: "Datalogic Inc.",
        851: "SoftPLC Corporation",
        852: "Dynisco Instruments LLC",
        853: "WEG Industrias SA",
        854: "Frontline Test Equipment Inc.",
        855: "Tamagawa Seiki Co.Ltd.",
        856: "Multi Computing Co.Ltd.",
        857: "RVSI",
        858: "Commercial Timesharing Inc.",
        859: "Tennessee Rand Automation LLC",
        860: "Wacogiken Co.Ltd",
        861: "Reflex Integration Inc.",
        862: "Siemens AG: A&D PI Flow Instruments",
        863: "G. Bachmann Electronic GmbH",
        864: "NT International",
        865: "Schweitzer Engineering Laboratories",
        866: "ATR Industrie-Elektronik GmbH Co.",
        867: "PLASMATECH Co.Ltd",
        868: "Reserved",
        869: "GEMU GmbH & Co. KG",
        870: "Alcorn McBride Inc.",
        871: "MORI SEIKI CO.: LTD",
        872: "NodeTech Systems Ltd",
        873: "Emhart Teknologies",
        874: "Cervis Inc.",
        875: "FieldServer Technologies (Div Sierra Monitor Corp)",
        876: "NEDAP Power Supplies",
        877: "Nippon Sanso Corporation",
        878: "Mitomi Giken Co.Ltd.",
        879: "PULS GmbH",
        880: "Reserved",
        881: "Japan Control Engineering Ltd",
        882: "Embedded Systems Korea (Former Zues Emtek Co Ltd.)",
        883: "Automa SRL",
        884: "Harms+Wende GmbH & Co KG",
        885: "SAE-STAHL GmbH",
        886: "Microwave Data Systems",
        887: "Bernecker + Rainer Industrie-Elektronik GmbH",
        888: "Hiprom Technologies",
        889: "Reserved",
        890: "Nitta Corporation",
        891: "Kontron Modular Computers GmbH",
        892: "Marlin Controls",
        893: "ELCIS s.r.l.",
        894: "Acromag Inc.",
        895: "Avery Weigh-Tronix",
        896: "Reserved",
        897: "Reserved",
        898: "Reserved",
        899: "Practicon Ltd",
        900: "Schunk GmbH & Co. KG",
        901: "MYNAH Technologies",
        902: "Defontaine Groupe",
        903: "Emerson Process Management Power & Water Solutions",
        904: "F.A. Elec",
        905: "Hottinger Baldwin Messtechnik GmbH",
        906: "Coreco Imaging Inc.",
        907: "London Electronics Ltd.",
        908: "HSD SpA",
        909: "Comtrol Corporation",
        910: "TEAM: S.A. (Tecnica Electronica de Automatismo Y Medida)",
        911: "MAN B&W Diesel Ltd. Regulateurs Europa",
        912: "Reserved",
        913: "Reserved",
        914: "Micro Motion Inc.",
        915: "Eckelmann AG",
        916: "Hanyoung Nux",
        917: "Ransburg Industrial Finishing KK",
        918: "Kun Hung Electric Co. Ltd.",
        919: "Brimos wegbebakening b.v.",
        920: "Nitto Seiki Co.Ltd",
        921: "PPT Vision Inc.",
        922: "Yamazaki Machinery Works",
        923: "SCHMIDT Technology GmbH",
        924: "Parker Hannifin SpA (SBC Division)",
        925: "HIMA Paul Hildebrandt GmbH",
        926: "RivaTek Inc.",
        927: "Misumi Corporation",
        928: "GE Multilin",
        929: "Measurement Computing Corporation",
        930: "Jetter AG",
        931: "Tokyo Electronics Systems Corporation",
        932: "Togami Electric Mfg. Co.Ltd.",
        933: "HK Systems",
        934: "CDA Systems Ltd.",
        935: "Aerotech Inc.",
        936: "JVL Industrie Elektronik A/S",
        937: "NovaTech Process Solutions LLC",
        938: "Reserved",
        939: "Cisco Systems",
        940: "Grid Connect",
        941: "ITW Automotive Finishing",
        942: "HanYang System",
        943: "ABB K.K. Technical Center",
        944: "Taiyo Electric Wire & Cable Co.Ltd.",
        945: "Reserved",
        946: "SEREN IPS INC",
        947: "Belden CDT Electronics Division",
        948: "ControlNet International",
        949: "Gefran S.P.A.",
        950: "Jokab Safety AB",
        951: "SUMITA OPTICAL GLASS: INC.",
        952: "Biffi Italia srl",
        953: "Beck IPC GmbH",
        954: "Copley Controls Corporation",
        955: "Fagor Automation S. Coop.",
        956: "DARCOM",
        957: "Frick Controls (div. of York International)",
        958: "SymCom Inc.",
        959: "Infranor",
        960: "Kyosan CableLtd.",
        961: "Varian Vacuum Technologies",
        962: "Messung Systems",
        963: "Xantrex Technology Inc.",
        964: "StarThis Inc.",
        965: "Chiyoda Co.Ltd.",
        966: "Flowserve Corporation",
        967: "Spyder Controls Corp.",
        968: "IBA AG",
        969: "SHIMOHIRA ELECTRIC MFG.CO.,LTD",
        970: "Reserved",
        971: "Siemens L&A",
        972: "Micro Innovations AG",
        973: "Switchgear & Instrumentation",
        974: "PRE-TECH CO.: LTD.",
        975: "National Semiconductor",
        976: "Invensys Process Systems",
        977: "Ametek HDR Power Systems",
        978: "Reserved",
        979: "TETRA-K Corporation",
        980: "C & M Corporation",
        981: "Siempelkamp Maschinen",
        982: "Reserved",
        983: "Daifuku America Corporation",
        984: "Electro-Matic Products Inc.",
        985: "BUSSAN MICROELECTRONICS CORP.",
        986: "ELAU AG",
        987: "Hetronic USA",
        988: "NIIGATA POWER SYSTEMS Co.Ltd.",
        989: "Software Horizons Inc.",
        990: "B3 Systems Inc.",
        991: "Moxa Networking Co.Ltd.",
        992: "Reserved",
        993: "S4 Integration",
        994: "Elettro Stemi S.R.L.",
        995: "AquaSensors",
        996: "Ifak System GmbH",
        997: "SANKEI MANUFACTURING Co.,LTD.",
        998: "Emerson Network Power Co.Ltd.",
        999: "Fairmount Automation Inc.",
        1000: "Bird Electronic Corporation",
        1001: "Nabtesco Corporation",
        1002: "AGM Electronics Inc.",
        1003: "ARCX Inc.",
        1004: "DELTA I/O Co.",
        1005: "Chun IL Electric Ind. Co.",
        1006: "N-Tron",
        1007: "Nippon Pneumatics/Fludics System CO.,LTD.",
        1008: "DDK Ltd.",
        1009: "Seiko Epson Corporation",
        1010: "Halstrup-Walcher GmbH",
        1011: "ITT",
        1012: "Ground Fault Systems bv",
        1013: "Scolari Engineering S.p.A.",
        1014: "Vialis Traffic bv",
        1015: "Weidmueller Interface GmbH & Co. KG",
        1016: "Shanghai Sibotech Automation Co. Ltd",
        1017: "AEG Power Supply Systems GmbH",
        1018: "Komatsu Electronics Inc.",
        1019: "Souriau",
        1020: "Baumuller Chicago Corp.",
        1021: "J. Schmalz GmbH",
        1022: "SEN Corporation",
        1023: "Korenix Technology Co. Ltd",
        1024: "Cooper Power Tools",
        1025: "INNOBIS",
        1026: "Shinho System",
        1027: "Xm Services Ltd.",
        1028: "KVC Co.Ltd.",
        1029: "Sanyu Seiki Co.Ltd.",
        1030: "TuxPLC",
        1031: "Northern Network Solutions",
        1032: "Converteam GmbH",
        1033: "Symbol Technologies",
        1034: "S-TEAM Lab",
        1035: "Maguire Products Inc.",
        1036: "AC&T",
        1037: "MITSUBISHI HEAVY INDUSTRIES: LTD. KOBE SHIPYARD & MACHINERY WORKS",
        1038: "Hurletron Inc.",
        1039: "Chunichi Denshi Co.Ltd",
        1040: "Cardinal Scale Mfg. Co.",
        1041: "BTR NETCOM via RIA Connect Inc.",
        1042: "Base2",
        1043: "ASRC Aerospace",
        1044: "Beijing Stone Automation",
        1045: "Changshu Switchgear Manufacture Ltd.",
        1046: "METRONIX Corp.",
        1047: "WIT",
        1048: "ORMEC Systems Corp.",
        1049: "ASATech (China) Inc.",
        1050: "Controlled Systems Limited",
        1051: "Mitsubishi Heavy Ind. Digital System Co.Ltd. (M.H.I.)",
        1052: "Electrogrip",
        1053: "TDS Automation",
        1054: "T&C Power Conversion Inc.",
        1055: "Robostar Co.Ltd",
        1056: "Scancon A/S",
        1057: "Haas Automation Inc.",
        1058: "Eshed Technology",
        1059: "Delta Electronic Inc.",
        1060: "Innovasic Semiconductor",
        1061: "SoftDEL Systems Limited",
        1062: "FiberFin Inc.",
        1063: "Nicollet Technologies Corp.",
        1064: "B.F. Systems",
        1065: "Empire Wire and Supply LLC",
        1066: "ENDO KOGYO CO., LTD",
        1067: "Elmo Motion Control LTD",
        1068: "Reserved",
        1069: "Asahi Keiki Co.Ltd.",
        1070: "Joy Mining Machinery",
        1071: "MPM Engineering Ltd",
        1072: "Wolke Inks & Printers GmbH",
        1073: "Mitsubishi Electric Engineering Co.Ltd.",
        1074: "COMET AG",
        1075: "Real Time Objects & Systems: LLC",
        1076: "MISCO Refractometer",
        1077: "JT Engineering Inc.",
        1078: "Automated Packing Systems",
        1079: "Niobrara R&D Corp.",
        1080: "Garmin Ltd.",
        1081: "Japan Mobile Platform Co.Ltd",
        1082: "Advosol Inc.",
        1083: "ABB Global Services Limited",
        1084: "Sciemetric Instruments Inc.",
        1085: "Tata Elxsi Ltd.",
        1086: "TPC Mechatronics: Co.Ltd.",
        1087: "Cooper Bussmann",
        1088: "Trinite Automatisering B.V.",
        1089: "Peek Traffic B.V.",
        1090: "Acrison Inc",
        1091: "Applied Robotics Inc.",
        1092: "FireBus Systems Inc.",
        1093: "Beijing Sevenstar Huachuang Electronics",
        1094: "Magnetek",
        1095: "Microscan",
        1096: "Air Water Inc.",
        1097: "Sensopart Industriesensorik GmbH",
        1098: "Tiefenbach Control Systems GmbH",
        1099: "INOXPA S.A",
        1100: "Zurich University of Applied Sciences",
        1101: "Ethernet Direct",
        1102: "GSI-Micro-E Systems",
        1103: "S-Net Automation Co.Ltd.",
        1104: "Power Electronics S.L.",
        1105: "Renesas Technology Corp.",
        1106: "NSWCCD-SSES",
        1107: "Porter Engineering Ltd.",
        1108: "Meggitt Airdynamics Inc.",
        1109: "Inductive Automation",
        1110: "Neural ID",
        1111: "EEPod LLC",
        1112: "Hitachi Industrial Equipment Systems Co.Ltd.",
        1113: "Salem Automation",
        1114: "port GmbH",
        1115: "B & PLUS",
        1116: "Graco Inc.",
        1117: "Altera Corporation",
        1118: "Technology Brewing Corporation",
        1121: "CSE Servelec",
        1124: "Fluke Networks",
        1125: "Tetra Pak Packaging Solutions SPA",
        1126: "Racine Federated Inc.",
        1127: "Pureron Japan Co.Ltd.",
        1130: "Brother IndustriesLtd.",
        1132: "Leroy Automation",
        1134: "THK CO.: LTD.",
        1137: "TR-Electronic GmbH",
        1138: "ASCON S.p.A.",
        1139: "Toledo do Brasil Industria de Balancas Ltda.",
        1140: "Bucyrus DBT Europe GmbH",
        1141: "Emerson Process Management Valve Automation",
        1142: "Alstom Transport",
        1144: "Matrox Electronic Systems",
        1145: "Littelfuse",
        1146: "PLASMART Inc.",
        1147: "Miyachi Corporation",
        1150: "Promess Incorporated",
        1151: "COPA-DATA GmbH",
        1152: "Precision Engine Controls Corporation",
        1153: "Alga Automacao e controle LTDA",
        1154: "U.I. Lapp GmbH",
        1155: "ICES",
        1156: "Philips Lighting bv",
        1157: "Aseptomag AG",
        1158: "ARC Informatique",
        1159: "Hesmor GmbH",
        1160: "Kobe SteelLtd.",
        1161: "FLIR Systems",
        1162: "Simcon A/S",
        1163: "COPALP",
        1164: "Zypcom Inc.",
        1165: "Swagelok",
        1166: "Elspec",
        1167: "ITT Water & Wastewater AB",
        1168: "Kunbus GmbH Industrial Communication",
        1170: "Performance Controls Inc.",
        1171: "ACS Motion ControlLtd.",
        1173: "IStar Technology Limited",
        1174: "Alicat Scientific Inc.",
        1176: "ADFweb.com SRL",
        1177: "Tata Consultancy Services Limited",
        1178: "CXR Ltd.",
        1179: "Vishay Nobel AB",
        1181: "SolaHD",
        1182: "Endress+Hauser",
        1183: "Bartec GmbH",
        1185: "AccuSentry Inc.",
        1186: "Exlar Corporation",
        1187: "ILS Technology",
        1188: "Control Concepts Inc.",
        1190: "Procon Engineering Limited",
        1191: "Hermary Opto Electronics Inc.",
        1192: "Q-Lambda",
        1194: "VAMP Ltd",
        1195: "FlexLink",
        1196: "Office FA.com Co.Ltd.",
        1197: "SPMC (Changzhou) Co. Ltd.",
        1198: "Anton Paar GmbH",
        1199: "Zhuzhou CSR Times Electric Co.Ltd.",
        1200: "DeStaCo",
        1201: "Synrad Inc",
        1202: "Bonfiglioli Vectron GmbH",
        1203: "Pivotal Systems",
        1204: "TKSCT",
        1205: "Randy Nuernberger",
        1206: "CENTRALP",
        1207: "Tengen Group",
        1208: "OES Inc.",
        1209: "Actel Corporation",
        1210: "Monaghan Engineering Inc.",
        1211: "wenglor sensoric gmbh",
        1212: "HSA Systems",
        1213: "MK Precision Co.Ltd.",
        1214: "Tappan Wire and Cable",
        1215: "Heinzmann GmbH & Co. KG",
        1216: "Process Automation International Ltd.",
        1217: "Secure Crossing",
        1218: "SMA Railway Technology GmbH",
        1219: "FMS Force Measuring Systems AG",
        1220: "ABT Endustri Enerji Sistemleri Sanayi Tic. Ltd. Sti.",
        1221: "MagneMotion Inc.",
        1222: "STS Co.Ltd.",
        1223: "MERAK SIC: SA",
        1224: "ABOUNDI Inc.",
        1225: "Rosemount Inc.",
        1226: "GEA FES Inc.",
        1227: "TMG Technologie und Engineering GmbH",
        1228: "embeX GmbH",
        1229: "GH Electrotermia: S.A.",
        1230: "Tolomatic",
        1231: "Dukane",
        1232: "Elco (Tian Jin) Electronics Co.Ltd.",
        1233: "Jacobs Automation",
        1234: "Noda Radio Frequency Technologies Co.Ltd.",
        1235: "MSC Tuttlingen GmbH",
        1236: "Hitachi Cable Manchester",
        1237: "ACOREL SAS",
        1238: "Global Engineering Solutions Co.Ltd.",
        1239: "ALTE Transportation: S.L.",
        1240: "Penko Engineering B.V.",
        1241: "Z-Tec Automation Systems Inc.",
        1242: "ENTRON Controls LLC",
        1243: "Johannes Huebner Fabrik Elektrischer Maschinen GmbH",
        1244: "RF IDeas, Inc.",
        1245: "Pentronic AB",
        1246: "SCA Schucker GmbH & Co. KG",
        1247: "TDK-Lambda",
        1248: "Reserved",
        1249: "Reserved",
        1250: "Altronic LLC",
        1251: "Siemens AG",
        1252: "Liebherr Transportation Systems GmbH & Co KG",
        1253: "Reserved",
        1254: "SKF USA Inc.",
        1255: "Reserved",
        1256: "LMI Technologies",
        1257: "Reserved",
        1258: "Reserved",
        1259: "EN Technologies Inc.",
        1260: "Reserved",
        1261: "CEPHALOS Automatisierung mbH",
        1262: "Atronix Engineering, Inc.",
        1263: "Monode Marking Products, Inc.",
        1264: "Reserved",
        1265: "Quabbin Wire & Cable Co., Inc.",
        1266: "GPSat Systems Australia",
        1267: "Reserved",
        1268: "Reserved",
        1269: "Tri-Tronics Co., Inc.",
        1270: "Rovema GmbH",
        1271: "Reserved",
        1272: "IEP GmbH",
        1273: "Reserved",
        1274: "Reserved",
        1275: "Reserved",
        1276: "Reserved",
        1277: "Control Chief Corporation",
        1278: "Reserved",
        1279: "Reserved",
        1280: "Jacktek Systems Inc.",
        1281: "Reserved",
        1282: "PRIMES GmbH",
        1283: "Branson Ultrasonics",
        1284: "DEIF A/S",
        1285: "3S-Smart Software Solutions GmbH",
        1286: "Reserved",
        1287: "Smarteye Corporation",
        1288: "Toshiba Machine",
        1289: "eWON",
        1290: "OFS",
        1291: "KROHNE",
        1292: "Reserved",
        1293: "General Cable Industries, Inc.",
        1294: "Reserved",
        1295: "Kistler Instrumente AG",
        1296: "YJS Co., Ltd.",
        1297: "Reserved",
        1298: "Reserved",
        1299: "Reserved",
        1300: "Reserved",
        1301: "Xylem Analytics Germany GmbH",
        1302: "Lenord, Bauer & Co. GmbH",
        1303: "Carlo Gavazzi Controls",
        1304: "Faiveley Transport",
        1305: "Reserved",
        1306: "vMonitor",
        1307: "Kepware Technologies",
        1308: "duagon AG",
        1309: "Reserved",
        1310: "Xylem Water Solutions",
        1311: "Automation Professionals, LLC",
        1312: "Reserved",
        1313: "CEIA SpA",
        1314: "Marine Technologies LLC",
        1315: "Alphagate Automatisierungstechnik GmbH",
        1316: "Mecco Partners, LLC",
        1317: "LAP GmbH Laser Applikationen",
        1318: "ABB S.p.A. - SACE Division",
        1319: "ABB S.p.A. - SACE Division",
        1320: "Reserved",
        1321: "Reserved",
        1322: "Thermo Ramsey Inc.",
        1323: "Helmholz GmbH & Co. KG",
        1324: "EUCHNER GmbH + Co. KG",
        1325: "AMK GmbH & Co. KG",
        1326: "Badger Meter",
        1327: "Reserved",
        1328: "Fisher-Rosemount Systems, Inc.",
        1329: "LJU Automatisierungstechnik GmbH",
        1330: "Fairbanks Scales, Inc.",
        1331: "Imperx, Inc.",
        1332: "FRONIUS International GmbH",
        1333: "Hoffman Enclosures",
        1334: "Elecsys Corporation",
        1335: "Bedrock Automation",
        1336: "RACO Manufacturing and Engineering",
        1337: "Hein Lanz Industrial Tech.",
        1338: "Synopsys, Inc. (formerly Codenomicon)",
        1339: "Reserved",
        1340: "Reserved",
        1341: "Sensirion AG",
        1342: "SIKO GmbH",
        1343: "Reserved",
        1344: "GRUNDFOS",
        1345: "Reserved",
        1346: "Beijer Electronics Products AB",
        1347: "Reserved",
        1348: "AIMCO",
        1349: "Reserved",
        1350: "Coval Vacuum Managers",
        1351: "Powell Industries",
        1352: "Reserved",
        1353: "IPDisplays",
        1354: "SCAIME SAS",
        1355: "Metal Work SpA",
        1356: "Telsonic AG",
        1357: "Reserved",
        1358: "Hauch & Bach ApS",
        1359: "Pago AG",
        1360: "ULTIMATE Europe Transportation Equipment GmbH",
        1361: "Reserved",
        1362: "Enovation Controls",
        1363: "Lake Cable LLC",
        1364: "Reserved",
        1365: "Reserved",
        1366: "Reserved",
        1367: "Laird",
        1368: "Nanotec Electronic GmbH & Co. KG",
        1369: "SAMWON ACT Co., Ltd.",
        1370: "Aparian Inc.",
        1371: "Cosys Inc.",
        1372: "Insight Automation Inc.",
        1373: "Reserved",
        1374: "FASTECH",
        1375: "K.A. Schmersal GmbH & Co. KG",
        1376: "Reserved",
        1377: "Chromalox",
        1378: "SEIDENSHA ELECTRONICS CO., LTD",
        1379: "Reserved",
        1380: "Don Electronics Ltd",
        1381: "burster gmbh & co kg",
        1382: "Unitronics (1989) (RG) LTD",
        1383: "OEM Technology Solutions",
        1384: "Allied Motion",
        1385: "Mitron Oy",
        1386: "Dengensha TOA",
        1387: "Systec Systemtechnik und Industrieautomation GmbH",
        1388: "Reserved",
        1389: "Jenny Science AG",
        1390: "Baumer Optronic GmbH",
        1391: "Invertek Drives Ltd",
        1392: "High Grade Controls Corporation",
        1393: "Reserved",
        1394: "Ishida Europe Limited",
        1395: "Reserved",
        1396: "Actia Systems",
        1397: "Reserved",
        1398: "Beijing Tiandi-Marco Electro-Hydraulic Control System Co., Ltd.",
        1399: "Universal Robots A/S",
        1400: "Reserved",
        1401: "Dialight",
        1402: "E-T-A Elektrotechnische Apparate GmbH",
        1403: "Kemppi Oy",
        1404: "Tianjin Geneuo Technology Co., Ltd.",
        1405: "ORing Industrial Networking Corp.",
        1406: "Benchmark Electronics",
        1407: "Reserved",
        1408: "ELAP S.R.L.",
        1409: "Applied Mining Technologies",
        1410: "KITZ SCT Corporation",
        1411: "VTEX Corporation",
        1412: "ESYSE GmbH Embedded Systems Engineering",
        1413: "Automation Controls",
        1414: "Reserved",
        1415: "Cincinnati Test Systems",
        1416: "Reserved",
        1417: "Zumbach Electronics Corp.",
        1418: "Emerson Process Management",
        1419: "CCS Inc.",
        1420: "Videojet, Inc.",
        1421: "Zebra Technologies",
        1422: "Anritsu Infivis",
        1423: "Dimetix AG",
        1424: "General Measure (China)",
        1425: "Fortress Interlocks",
        1426: "Reserved",
        1427: "Task Force Tips",
        1428: "SERVO-ROBOT INC.",
        1429: "Flow Devices and Systems, Inc.",
        1430: "nLIGHT, Inc.",
        1431: "Microchip Technology Inc.",
        1432: "DENT Instruments",
        1433: "CMC Industrial Electronics Ltd.",
        1434: "Accutron Instruments Inc.",
        1435: "Kaeser Kompressoren SE",
        1436: "Optoelectronics",
        1437: "Coherix, Inc.",
        1438: "FLSmidth A/S",
        1439: "Kyland Corporation",
        1440: "Cole-Parmer Instrument Company",
        1441: "Wachendorff Automation GmbH & Co., KG",
        1442: "SMAC Moving Coil Actuators",
        1443: "Reserved",
        1444: "PushCorp, Inc.",
        1445: "Fluke Process Instruments GmbH",
        1446: "Mini Motor srl",
        1447: "I-CON Industry Tech.",
        1448: "Grace Engineered Products, Inc.",
        1449: "Zaxis Inc.",
        1450: "Lumasense Technologies",
        1451: "Domino Printing",
        1452: "LightMachinery Inc",
        1453: "DEUTA-WERKE GmbH",
        1454: "Altus Sistemas de Automação S.A.",
        1455: "Criterion NDT",
        1456: "InterTech Development Company",
        1457: "Action Labs, Incorporated",
        1458: "Perle Systems Limited",
        1459: "Utthunga Technologies Pvt Ltd.",
        1460: "Dong IL Vision, Co., Ltd.",
        1461: "Wipotec Wiege-und Positioniersysteme GmbH",
        1462: "Atos spa",
        1463: "Solartron Metrology LTD",
        1464: "Willowglen Systems Inc.",
        1465: "Analog Devices",
        1466: "Power Electronics International, Inc.",
        1467: "Reserved",
        1468: "Campbell Wrapper Corporatio",
        1469: "Herkules-Resotec Elektronik GmbH",
        1470: "aignep spa",
        1471: "SHANGHAI CARGOA M.&E.EQUIPMENT CO.LTD",
        1472: "PMV Automation AB",
        1473: "K-Patents Oy",
        1474: "Dynatronix",
        1475: "Atop Technologies",
        1476: "Bitronics, LLC.",
        1477: "Delta Tau Data Systems",
        1478: "WITZ Corporation",
        1479: "AUTOSOL",
        1480: "ADB Safegate",
        1481: "VersaBuilt, Inc",
        1482: "Visual Technologies, Inc.",
        1483: "Artis GmbH",
        1484: "Reliance Electric Limited",
        1485: "Vanderlande",
        1486: "Packet Power",
        1487: "ima-tec gmbh",
        1488: "Vision Automation A/S",
        1489: "PROCENTEC BV",
        1490: "HETRONIK GmbH",
        1491: "Lanmark Controls Inc.",
        1492: "profichip GmbH",
        1493: "flexlog GmbH",
        1494: "YUCHANGTECH",
        1495: "Dynapower Company",
        1496: "TAKIKAWA ENGINEERING",
        1497: "Ingersoll Rand",
        1498: "ASA-RT s.r.l",
        1499: "Trumpf Laser- und Systemtectechnik Gmbh",
        1500: "SYNTEC TECHNOLOGY CORPORATION COMPANY",
        1501: "Rinstrum",
        1502: "Symbotic LLC",
        1503: "GE Healthcare Life Sciences",
        1504: "BlueBotics SA",
        1505: "Dynapar Corporation",
        1506: "Blum-Novotest",
        1507: "CIMON",
        1508: "Dalian SeaSky Automation Co., ltd",
        1509: "Rethink Robotics, Inc.",
        1510: "Ingeteam",
        1511: "TOSEI ENGINEERING CORP.",
        1512: "SAMSON AG",
        1513: "TGW Mechanics GmbH",
    }
    cip_device_type_mapping = {
        0: "Generic Device (deprecated)",
        1: "Control Station (deprecated)",
        2: "AC Drive Device",
        3: "Motor Overload",
        4: "Limit Switch",
        5: "Inductive Proximity Switch",
        6: "Photoelectric Sensor",
        7: "General Purpose Discrete I/O",
        8: "Encoder (deprecated)",
        9: "Resolver",
        10: "General Purpose Analog I/O (deprecated)",
        12: "Communications Adapter",
        13: "Barcode Scanner (deprecated)",
        14: "Programmable Logic Controller",
        16: "Position Controller",
        17: "Weigh Scale (deprecated)",
        18: "Message Display (deprecated)",
        19: "DC Drive",
        20: "Servo Drives (deprecated)",
        21: "Contactor",
        22: "Motor Starter",
        23: "Softstart Starter",
        24: "Human-Machine Interface",
        25: "Pneumatic Valve(s) (deprecated)",
        26: "Mass Flow Controller",
        27: "Pneumatic Valve(s)",
        28: "Vacuum Pressure Gauge",
        29: "Process Control Value",
        30: "Residual Gas Analyzer",
        31: "DC Power Generator",
        32: "RF Power Generator",
        33: "Turbomolecular Vacuum Pump",
        34: "Encoder",
        35: "Safety Discrete I/O Device",
        36: "Fluid Flow Controller",
        37: "CIP Motion Drive",
        38: "CompoNet Repeater",
        39: "Mass Flow Controller Enhanced",
        40: "CIP Modbus Device",
        41: "CIP Modbus Translator",
        42: "Safety Analog I/O Device",
        43: "Generic Device (keyable)",
        44: "Managed Ethernet Switch",
        50: "ControlNet Physical Layer Component",
        59: "ControlNet Physical Layer Component",
        100: "In-Sight 2000 Series",
        150: "PowerFlex 525",
        773: "DataMan Series Reader"
    }
    modbus_object_id_mapping = {
        0: "vendor",
        1: "productCode",
        2: "firmwareVer",
        3: "vendorURL",
        4: "hostname",
        5: "model",
    }
    s7_requests = {
        'COTP1':  unhexlify('0300001611e00000001400c1020100c2020102c0010a'),
        'COTP2':  unhexlify('0300001611e00000000500c1020100c2020200c0010a'),
        'ROSCTR_Setup': unhexlify('0300001902f08032010000000000080000f0000001000101e0'),
        'first_SZL_Request': unhexlify('0300002102f080320700000000000800080001120411440100ff09000400110001'),
        'second_SZL_Request': unhexlify('0300002102f080320700000000000800080001120411440100ff090004001c0001')
    }
    s7_comm_plus_requests = {
        'COTP': unhexlify('030000231ee00000006100c1020600c20f53494d415449432d524f4f542d4553c0010a'),
        'Create_Object': unhexlify('030000f102f080720100e231000004ca0000000100000120360000011d00040000000000a1000000d3821f0000a3816900151553657276657253657373696f6e5f31433943333831a38221001535302e302e302e303a30496e74656c2852292045746865726e657420436f6e6e656374696f6e20493231392d4c4d2e54435049502e31a38228001500a38229001500a3822a0015194445534b544f502d3537524a3133475f353433333234363430a3822b000401a3822c001201c9c381a3822d001500a1000000d3817f0000a38169001515537562736372697074696f6e436f6e7461696e6572a2a20000000072010000')
    }
    mms_requests = {
        'COTP': unhexlify('0300001611e00000000100c0010dc2020001c1020001'),
        'mms_initiate_req': unhexlify('030000bb02f0800db20506130100160102140200023302000134020001c19c318199a003800101a28191810400000001820400000001a423300f0201010604520100013004060251013010020103060528ca220201300406025101615e305c020101a0576055a107060528ca220203a20706052901876701a30302010ca606060429018767a70302010cbe2f282d020103a028a826800300fde881010582010583010aa416800101810305f100820c03ee1c00000408000079ef18'),
        'mms_confirmed_req': unhexlify('0300001b02f08001000100610e300c020103a007a0050201018200'),
    }
    fanuc_focus_requests = {
        'connect_req': unhexlify('a0a0a0a00001010100020002'),
        'sysinfo_req': unhexlify('a0a0a0a000012101001e0001001c0001000100180000000000000000000000000000000000000000'),
        'close_connection_req': unhexlify('a0a0a0a0000102010000'),
    }

    DOT = '.'
    SNMP_SYS_DESC_OID  = '1.3.6.1.2.1.1.1'
    # SNMP_IF_PHYS_ADDRESS_OID = '1.3.6.1.2.1.2.2.1.6'
    SNMP_SYS_NAME_OID = '1.3.6.1.2.1.1.5'
    SNMP_MAC_IP_PAIR_OID = '1.3.6.1.2.1.4.22.1.2'
    SNMP_COMMUNITY = demisto.params().get('SNMP Community String')
    SNMP_USERNAME = demisto.params().get('SNMP Username')
    SNMP_SECURITY_LEVEL = demisto.params().get('SNMP Security Level')
    SNMP_AUTH_PROTOCOL = demisto.params().get('SNMP Authentication Protocol')
    SNMP_AUTH_PASSWORD = demisto.params().get('SNMP Authentication Password')
    SNMP_PRIVACY_PROTOCOL = demisto.params().get('SNMP Privacy Protocol')
    SNMP_PRIVACY_PASSWORD = demisto.params().get('SNMP Privacy Password')

    WINRM_USERNAME = demisto.params().get('WinRM Username')
    WINRM_PASSWORD = demisto.params().get('WinRM Password')
    WINRM_GET_SOFTWARE = "wmic product get vendor,name,version /format:csv"
    WINRM_GET_SYSTEMINFO = "systeminfo"
    WINRM_GET_IP_MAC = 'ipconfig /all | findstr "IPv4 Physical"'
    WINRM_GET_HOTFIX_ID = 'wmic qfe get hotfixid'

    ''' HELPERS '''

    def is_valid_ipv4_address(address):
        try:
            socket.inet_pton(socket.AF_INET, address)
        except AttributeError:  # no inet_pton here, sorry
            try:
                socket.inet_aton(address)
            except socket.error:
                return False
            return address.count('.') == 3
        except socket.error:  # not a valid address
            return False

        return True

    def tcp_socket(req_payload, server_address_port):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            sock.connect(server_address_port)
            sock.sendall(req_payload)
            msg = sock.recv(4096)
            return msg, None
        except socket.error as e:
            return None, "TCP socket error: " + str(e)
        except Exception as e:
            demisto.debug("IP address, port: " + str(server_address_port))
            demisto.debug("Error fetching data over TCP : " + str(e))
            return None, str(e)


    def udp_socket(req_payload, server_address_port):
        try:
            bufferSize = 4096
            UDPClientSocket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)
            UDPClientSocket.settimeout(10)
            UDPClientSocket.sendto(req_payload, server_address_port)
            msgFromServer = UDPClientSocket.recvfrom(bufferSize)
            msg = msgFromServer[0]
            return msg, None
        except socket.error as e:
            return None, "UDP socket error: " + str(e)
        except Exception as e:
            demisto.debug("IP address, port: " + str(server_address_port))
            demisto.debug("Error fetching data over UDP : " + str(e))
            return None, str(e)


    def getDefaultPort(port, mode):
        if not port:
            default_port = default_protocols[mode]
            return default_port
        else:
            try:
                portval = int(port)
                return portval
            except ValueError:
                raise Exception("Enter the valid port")


    def send_receive_socket(sock, query, query_type=''):
        try:
            sock.sendall(query)
            data = sock.recv(4096)
            return data, None
        except Exception as e:
            demisto.debug("Error fetching query: " + str(query_type.replace('_', ' ')) + ":" + str(e))
            return None, str(e)


    ''' BACNET MODE PROBE '''
    """
    bacnet.py: Parse BACnet responses from hex data.
    """
    __author__ = "Oliver Gasser"
    __copyright__ = "Copyright 2016"
    __license__ = "GPL 3"
    __maintainer__ = "Oliver Gasser"
    __email__ = "gasser@net.in.tum.de"


    class BacnetResponse:
        """
        Class for handling BACnet Complex-ACK responses.

        """

        TYPE_COMPLEX_ACK_PDU = 0x03

        # Context specific tags
        TAG_NUM_OBJECT_ID = 0
        TAG_NUM_ERROR = 5
        TAG_NUM_OPENING = 6
        TAG_NUM_CLOSING = 7

        # Application specific tags
        TAG_NUM_NULL = 0
        TAG_NUM_UINT = 2
        TAG_NUM_CHAR_STRING = 7
        TAG_NUM_ENUMERATED = 9
        TAG_NUM_DATE = 10
        TAG_NUM_TIME = 11

        PROP_ID_OBJECT_ID = -1

        ENCODING_UTF8 = 0
        ENCODING_DBCS = 1 # Not available on Linux
        ENCODING_JISX0208 = 2
        ENCODING_UCS2 = 4
        ENCODING_LATIN1 = 5

        # Initializes a bacnet reponse by parsing the UDP payload
        def __init__(self, data):
            self.bvlc_transport = None    # 0x81
            self.bvlc_npdu = None         # 0x0a
            self.bvlc_len = None

            self.npdu_version = None      # 0x01
            self.npdu_ctrl = None

            self.npdu_dnet = None
            self.npdu_dlen = None
            self.npdu_dadr = None

            self.npdu_snet = None
            self.npdu_slen = None
            self.npdu_sadr = None

            self.npdu_hop_count = None

            self.apdu_type = None
            self.apdu_seg = None
            self.apdu_invoke_id = None
            self.apdu_confirmed_service_choice = None

            # Derived from Object ID
            self.object_type = None
            self.instance = None
            self.properties = None

            # Parse header fields
            data_bin = bytearray.fromhex(data)
            curr_byte = 0

            self.bvlc_transport = data_bin[curr_byte]
            self.bvlc_npdu = data_bin[curr_byte+1]
            self.bvlc_len = self.parse_uint(data_bin, curr_byte+2, 2)

            if len(data_bin) <= 6:
                return

            curr_byte += 4 # 4

            self.npdu_version = data_bin[curr_byte]
            self.npdu_ctrl = data_bin[curr_byte+1]

            curr_byte += 2 # 6

            if self.ctrl_dnet_present():
                if curr_byte + 3 + 1 >= len(data_bin):
                    return
                self.npdu_dnet = self.parse_uint(data_bin, curr_byte, 2)
                self.npdu_dlen = data_bin[curr_byte+2]
                # Check for valid MAC destination address length
                if self.npdu_dlen in [1, 2, 3, 6, 7]:
                    self.npdu_dadr = self.parse_adr(data_bin, curr_byte+3, self.npdu_dlen)

                curr_byte += 2+1+self.npdu_dlen

            if self.ctrl_snet_present():
                if curr_byte + 3 >= len(data_bin):
                    return
                self.npdu_snet = self.parse_uint(data_bin, curr_byte, 2)
                self.npdu_slen = data_bin[curr_byte+2]
                # Check for valid MAC source address length
                if self.npdu_slen in [1, 2, 3, 6]:
                    self.npdu_sadr = self.parse_adr(data_bin, curr_byte+3, self.npdu_slen)

                curr_byte += 2+1+self.npdu_slen

            if self.ctrl_dnet_present():
                if curr_byte + 1 >= len(data_bin):
                    return
                self.npdu_hop_count = data_bin[curr_byte]

                curr_byte += 1


            if len(data_bin) < curr_byte + 4:
                return


            self.apdu_type = (data_bin[curr_byte] & 0xf0) >> 4

            if self.apdu_type == self.TYPE_COMPLEX_ACK_PDU:
                self.parse_complex_ack_pdu(data_bin, curr_byte)


        def parse_complex_ack_pdu(self, data_bin, curr_byte):
            self.apdu_seg = (data_bin[curr_byte] & 0x0c) >> 2

            if self.seg_segmented():
                self.apdu_seq_nr = data_bin[curr_byte+1]
                self.apdu_window_size = data_bin[curr_byte+2]
                curr_byte += 2

            self.apdu_invoke_id = data_bin[curr_byte+1]
            self.apdu_confirmed_service_choice = data_bin[curr_byte+2]

            curr_byte += 3

            self.properties = dict()
            open_tag_prop_id = None

            # Read all tags and their content
            while curr_byte < self.bvlc_len:
                prop_id, val, curr_byte, open_tag_prop_id = self.parse_tag_content(data_bin, curr_byte, open_tag_prop_id, open_tag_prop_id is not None)

                # Object ID
                if prop_id == self.PROP_ID_OBJECT_ID and val:
                    self.object_type = (val & 0xffc00000) >> 22
                    self.instance = val & 0x003fffff
                elif prop_id is not None:
                    # Element with this property ID is already present -> create list
                    if prop_id in self.properties:
                        temp = self.properties[prop_id]
                        if not type(temp) is list:
                            self.properties[prop_id] = list()
                            self.properties[prop_id].append(temp)
                        self.properties[prop_id].append(val)
                    else:
                        self.properties[prop_id] = val

        # Returns the parsed tag and the updated curr_byte
        def parse_tag(self, data_bin, curr_byte):
            tag = Tag(data_bin, curr_byte)
            curr_byte += 1

            if not hasattr(tag, "context_spec"):
                return (None, curr_byte)

            # Check for extended data length
            if not tag.context_spec:
                if tag.len_val_type == 5:
                    tag.len_val_type = data_bin[curr_byte]
                    curr_byte += 1

                if tag.len_val_type == 254:
                    tag.len_val_type = self.parse_uint(data_bin, curr_byte, 2)
                    curr_byte += 2
                elif tag.len_val_type == 255:
                    tag.len_val_type = self.parse_uint(data_bin, curr_byte, 4)
                    curr_byte += 4

            return (tag, curr_byte)

        # Returns (property ID, value, curr_byte)
        def parse_tag_content(self, data_bin, curr_byte, prop_id=None, tag_is_open=False):

            if tag_is_open:
                tag_open_prop_id = prop_id
            else:
                tag_open_prop_id = None

            error = False

            prop_content = None

            tag, curr_byte = self.parse_tag(data_bin, curr_byte)

            # Skip opening and closing tags
            while tag and tag.context_spec and (tag.len_val_type == self.TAG_NUM_OPENING or tag.len_val_type == self.TAG_NUM_CLOSING):
                # All tags belong to same property ID if enclosed within open/close tag
                if prop_id:
                    if tag.len_val_type == self.TAG_NUM_OPENING:
                        tag_open_prop_id = prop_id
                    elif tag.len_val_type == self.TAG_NUM_CLOSING:
                        tag_open_prop_id = None

                if curr_byte >= self.bvlc_len:
                    return (None, None, curr_byte, None)
                if tag.number == self.TAG_NUM_ERROR:
                    error = True
                tag, curr_byte = self.parse_tag(data_bin, curr_byte)

            if not tag:
                return (None, None, curr_byte, None)

            # Object ID
            if tag.context_spec and tag.number == self.TAG_NUM_OBJECT_ID:
                prop_id = self.PROP_ID_OBJECT_ID

                if tag.len_val_type != 4:
                    #print("WARN: Object ID with length " + str(tag.len_val_type) + " found: " + str(tag))
                    demisto.debug('WARN: Object ID with length %s found: %s' % (str(tag.len_val_type) , str(tag)))
                else:
                    prop_content = self.parse_uint(data_bin, curr_byte, 4)

            # Tag for property information
            elif tag.context_spec:
                if tag.len_val_type < 1 or tag.len_val_type > 4:
                    demisto.debug('WARN: Tag length/value/type with length %s found: %s' % (str(tag.len_val_type) , str(tag)))
                    #print("WARN: Tag length/value/type with length " + str(tag.len_val_type) + " found: " + str(tag))
                else:
                    prop_id = self.parse_uint(data_bin, curr_byte, tag.len_val_type)
                    return self.parse_tag_content(data_bin, curr_byte+tag.len_val_type, prop_id)

            # Application specific tag = content
            elif not tag.context_spec:
                try:
                    if not prop_id:
                        #print("WARN: No property ID set for application specific tag: " + str(tag))
                        demisto.debug('WARN: No property ID set for application specific tag: %s' % (str(tag)))
                    elif tag.number == self.TAG_NUM_DATE:
                        prop_content = self.parse_date(data_bin, curr_byte)
                    elif tag.number == self.TAG_NUM_TIME:
                        prop_content = self.parse_time(data_bin, curr_byte)
                    elif tag.number == self.TAG_NUM_CHAR_STRING:
                        prop_content = self.parse_char_string(data_bin, curr_byte, tag.len_val_type)
                    elif tag.number == self.TAG_NUM_UINT:
                        prop_content = self.parse_uint(data_bin, curr_byte, tag.len_val_type)
                    elif tag.number == self.TAG_NUM_ENUMERATED and error:
                        prop_content, curr_byte = self.parse_error(data_bin, curr_byte, tag.len_val_type)
                    elif tag.number == self.TAG_NUM_NULL:
                        prop_content = None
                    elif tag.number == self.TAG_NUM_ENUMERATED:
                        prop_content = self.parse_uint(data_bin, curr_byte, tag.len_val_type)
                    else:
                        #print("WARN: Not implemented application tag: " + str(tag))
                        demisto.debug('WARN: Not implemented application tag: %s' % (str(tag)))


                except (ValueError, LookupError) as err:
                    prop_content = EncodingError(prop_id, curr_byte, err)

            curr_byte += tag.len_val_type

            return (prop_id, prop_content, curr_byte, tag_open_prop_id)

        def parse_adr(self, data_bin, curr_byte, length):
            if length == 6 and len(data_bin[curr_byte:]) >= 6:
                return "%02x:%02x:%02x:%02x:%02x:%02x" % struct.unpack("BBBBBB", data_bin[curr_byte:curr_byte+6])
            else:
                return self.parse_uint(data_bin, curr_byte, length)

        def parse_date(self, data_bin, curr_byte):
            return datetime.date(1900 + data_bin[curr_byte], data_bin[curr_byte+1], data_bin[curr_byte+2])

        def parse_time(self, data_bin, curr_byte):
            return datetime.time(data_bin[curr_byte], data_bin[curr_byte+1], data_bin[curr_byte+2])

        def parse_char_string(self, data_bin, curr_byte, length):
            if data_bin[curr_byte] == self.ENCODING_UTF8:
                return data_bin[curr_byte+1:curr_byte+length].decode("utf8")
            elif data_bin[curr_byte] == self.ENCODING_DBCS:
                return data_bin[curr_byte+1:curr_byte+length].decode("dbcs")
            elif data_bin[curr_byte] == self.ENCODING_JISX0208:
                return data_bin[curr_byte+1:curr_byte+length].decode("shift_jis")
            elif data_bin[curr_byte] == self.ENCODING_UCS2:
                return data_bin[curr_byte+1:curr_byte+length].decode("UTF-16BE")
            elif data_bin[curr_byte] == self.ENCODING_LATIN1:
                return data_bin[curr_byte+1:curr_byte+length].decode("iso-8859-1")
            else:
                demisto.info('WARN: Not implemented char string encoding: %s' % (str(data_bin[curr_byte])))

        def parse_uint(self, data_bin, curr_byte, length):
            if length > len(data_bin[curr_byte:]):
                #print("WARN: Expecting uint of length " + str(length) + " but have only " + str(len(data_bin[curr_byte:])) + " of payload left")
                return
            if length == 1:
                return data_bin[curr_byte]
            elif length == 2:
                return struct.unpack("!H", bytes(data_bin[curr_byte:curr_byte+2]))[0]
            elif length == 3:
                upper_two = struct.unpack("!H", bytes(data_bin[curr_byte:curr_byte+2]))[0]
                lower_one = data_bin[curr_byte+2]
                return upper_two << 8 + lower_one
            elif length == 4:
                return struct.unpack("!I", bytes(data_bin[curr_byte:curr_byte+4]))[0]
            elif length == 6:
                upper_two = struct.unpack("!H", bytes(data_bin[curr_byte:curr_byte+2]))[0]
                lower_four = struct.unpack("!I", bytes(data_bin[curr_byte+2:curr_byte+6]))[0]
                return upper_two << 32 + lower_four
            elif length == 7:
                return self.parse_uint(data_bin, curr_byte, 6) << 8 + self.parse_uint(data_bin, curr_byte+6, 1)
            else:
                demisto.debug('WARN: Not implemented length for uint parsing: %s' % (str(length)))


        def parse_error(self, data_bin, curr_byte, length):
            err_class = self.parse_uint(data_bin, curr_byte, length)
            curr_byte += length
            tag = Tag(data_bin, curr_byte)
            curr_byte += 1
            err_code = self.parse_uint(data_bin, curr_byte, tag.len_val_type)
            curr_byte += tag.len_val_type

            # Subtract length from curr_byte as it will be added again later
            return (BacError(err_class, err_code), curr_byte-length)


        def ctrl_network_msg(self):
            return self.npdu_ctrl & 0x80

        def ctrl_reserved_set(self):
            return self.npdu_ctrl & 0x50

        def ctrl_dnet_present(self):
            return self.npdu_ctrl & 0x20

        def ctrl_snet_present(self):
            return self.npdu_ctrl & 0x08

        def ctrl_reply_expected(self):
            return self.npdu_ctrl & 0x04

        def ctrl_priority(self):
            return self.npdu_ctrl & 0x03

        def seg_segmented(self):
            return self.apdu_seg & 0x02

        def seg_more(self):
            return self.apdu_seg & 0x01


    class Tag:
        """
        Class for handling BACnet tags.

        """

        def __init__(self, data_bin, curr_byte):

            if curr_byte >= len(data_bin):
                demisto.debug("WARN: Wanted to initialize tag after end of payload")
                return None

            self.number = data_bin[curr_byte] >> 4
            self.context_spec = (data_bin[curr_byte] & 0x08) >> 3
            self.len_val_type = data_bin[curr_byte] & 0x07

        def __str__(self):
            return ("context" if self.context_spec else "application") + " specific tag: number=" + str(self.number) + \
                " length/value/type=" + str(self.len_val_type)


    class EncodingError(Exception):
        """
        Class for handling encoding errors inside responses.

        """

        # Make all but first argument optional to enable pickle
        def __init__(self, prop_id, curr_byte=None, error=None):
            super(EncodingError, self).__init__("")
            self.prop_id = prop_id
            self.curr_byte = curr_byte
            self.error = error

        def __str__(self):
            return "encoding error: property " + str(self.prop_id) + ", curr_byte " + \
                str(self.curr_byte) + ", payload" + str(self.error)


    class BacError(Exception):
        """
        Class for handling BACnet errors in responses.
        """

        # Make all but first argument optional to enable pickle
        def __init__(self, err_class, err_code=None):
            super(BacError, self).__init__("")
            self.err_class = err_class
            self.err_code = err_code

        def __str__(self):
            return "error: class " + str(self.err_class) + ", code " + str(self.err_code)


    def bacnet_get_instance_id(host_info):
        instanceId = None
        bufferSize = 4096
        # host = host.split('.')
        # broadcast_host = host[0] + '.' + host[1] + '.' + host[2] + '.255'
        unconfirmed_req_who_is = unhexlify('810b000c0120ffff00ff1008')
        # print("Trying to get the instanceID for ", host_info)
        try:
            UDPClientSocket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)
            UDPClientSocket.setsockopt(socket.SOL_SOCKET, socket.SO_BROADCAST, 1)
            UDPClientSocket.settimeout(10)
            UDPClientSocket.sendto(unconfirmed_req_who_is, host_info)

            msgFromServer = UDPClientSocket.recvfrom(bufferSize)
            msg = msgFromServer[0]
            msg = msg.hex()
            if msg[0:8] == '810a0015':  # BACnet Virtual Link header check done
                if msg[8:12] == '0100':  # BACnet NPDU header check done
                    if msg[12:16] == '1000':  # BACnet Unconfirmed REQ (i-Am) check done
                        if msg[16:20] == 'c402':  # ObjectIdentifier device check done
                            instanceId = msg[20:26]
            return instanceId, None
        except socket.error as e:
            return instanceId, "Bacnet get instance id socket error: " + str(e)
        except Exception as e:
            demisto.error('Error looking up Device ID for: %s' % (str(host_info)))
            demisto.error("Error: "+str(e))
            return instanceId, str(e)


    def bacnet_get_device_info(destination, destination_port=47808, instance_id=0):
        bacnet_info = []
        hosts = [destination]
        port = destination_port
        error_mssg = ''
        for host in hosts:
            device_info = {}
            serverAddressPort = (host, port)
            if instance_id == 0:
                converted_instance_id, err_msg = bacnet_get_instance_id(serverAddressPort)
                if err_msg:
                    error_mssg = error_mssg + " -> " + err_msg
            else:
                converted_instance_id = (hex(instance_id).lstrip("0x").rstrip("L"))
            if converted_instance_id:
                bacnet_requests = {
                    'vendorIdentifier': unhexlify('810a0011010402751c0c0c02' + converted_instance_id + '1978'),
                    'vendor': unhexlify('810a0011010402751d0c0c02' + converted_instance_id + '1979'),
                    'model': unhexlify('810a001101040275140c0c02' + converted_instance_id + '1946'),
                    'description': unhexlify('810a0011010402750e0c0c02' + converted_instance_id + '191c'),
                    'firmwareVer': unhexlify('810a0011010402750f0c0c02' + converted_instance_id + '192c'),
                    'appSoftVersion': unhexlify('810a0011010402750c0c0c02' + converted_instance_id + '190c'),
                    'protocolRevision': unhexlify('810a001101040275170c0c02' + converted_instance_id + '198b'),
                    'protocolVersion': unhexlify('810a001101040275180c0c02' + converted_instance_id + '1962')
                }
                bufferSize = 4096
                UDPClientSocket = socket.socket(family=socket.AF_INET, type=socket.SOCK_DGRAM)
                UDPClientSocket.settimeout(10)
                for request in bacnet_requests:
                    try:
                        property_values = []
                        UDPClientSocket.sendto(bacnet_requests[request], serverAddressPort)
                        msgFromServer = UDPClientSocket.recvfrom(bufferSize)
                        msg = msgFromServer[0]
                        response = BacnetResponse(msg.hex())
                        for k, v in response.properties.items():
                            # print("Property ID: ", k, ", Property value: ", v)
                            # property_values["Property_ID"] = k
                            # property_values["Property_value"] = v
                            property_values.append(v)
                        device_info[request] = property_values[0]
                    except Exception as e:
                        demisto.error('Error fetching bacnet: %s' % (str(e)))
                        error_mssg = error_mssg + '-> Error fetching bacnet data for '+ str(request) + " request :" + str(e)
            else:
                error_mssg = error_mssg + "-> Failed to get BACnet instance ID for " + str(host)
            if device_info:
                demisto.info("bacnet device_info ", device_info)
                device_info['connect_evtContent.ip'] = host
                # device_info['deviceid'] = host
                device_info['sourceProtocol'] = 'bacnet'
                if all(attribute in device_info for attribute in req_attributes):
                    bacnet_info.append(device_info)
                else:
                    demisto.debug("Ignore device as vendor/model not found: " + str(host))
                    error_mssg = error_mssg + "-> No vendor/model found in response for " + str(host)
            else:
                error_mssg = error_mssg + "-> No device info received in response for " + str(host)
        return bacnet_info, error_mssg


    ''' CIP-ENIP MODE PROBE '''


    def cip_get_device_info(destination, destination_port=44818, mode='both'):
        cip_info = []
        hosts = [destination]
        port = destination_port
        error_mssg = ""
        # print("hosts", hosts)
        cip_request = unhexlify('63000000000000000000000000000000c1debed100000000')  # request identity packet
        for host in hosts:
            device_info = {}
            msg = None
            err_msg = None
            serverAddressPort = (host, port)
            try:
                if mode == 'tcp':
                    msg, err_msg = tcp_socket(cip_request, serverAddressPort)
                    if err_msg:
                        error_mssg = error_mssg + " -> " + err_msg
                elif mode == 'udp':
                    msg, err_msg = udp_socket(cip_request, serverAddressPort)
                    if err_msg:
                        error_mssg = error_mssg + " -> " + err_msg
                elif mode == 'both':
                    #print("Trying to get the data over UDP")
                    msg, err_msg = udp_socket(cip_request, serverAddressPort)
                    if err_msg:
                        error_mssg = error_mssg + " -> " + err_msg
                    if not msg:
                        #print("Trying to get the data over TCP")
                        msg, err_msg = tcp_socket(cip_request, serverAddressPort)
                        if err_msg:
                            error_mssg = error_mssg + " -> " + err_msg
                if not msg:
                    continue
                # print(msg)
                if msg[0] != 0x63 or len(msg) < 27:  # command = msg[0]
                    #print("Invalid response command")
                    continue
                if msg[26] != 0x0c:  # typeId = msg[26]
                    #print("Invalid response typeId")
                    continue
                if len(msg) > 49:
                    vendor_id = int.from_bytes(msg[48:50], "little")
                    device_info['vendor'] = cip_vendor_id_mapping[vendor_id]
                if len(msg) > 51:
                    device_type_id = int.from_bytes(msg[50:52], "little")
                    device_info['moduleType'] = cip_device_type_mapping[device_type_id]
                if len(msg) > 53:
                    device_info['productCode'] = int.from_bytes(msg[52:54], "little")
                if len(msg) > 55:
                    device_info['firmwareVer'] = str(msg[54]) + '.' + str(msg[55])
                if len(msg) > 61:
                    device_info['serialNumber'] = format(int.from_bytes(msg[58:62], "little"), 'X')
                if len(msg) > 63 + msg[62]:  # productNameLength = msg[62]
                    device_info['model'] = bytes(msg[63:63 + msg[62]]).decode("utf-8")
                cip_info[host] = device_info
            except Exception as e:
                #print("Error fetching CIP Ethernet/IP :", e)
                demisto.error('Error fetching CIP Ethernet/IP: %s' % (str(e)))
                error_mssg = error_mssg + '-> Error fetching CIP Ethernet/IP: ' + str(e)

            if device_info:
                device_info['connect_evtContent.ip'] = host
                # device_info['deviceid'] = host
                device_info['sourceProtocol'] = 'cip'
                if all(attribute in device_info for attribute in req_attributes):
                    cip_info.append(device_info)
                else:
                    demisto.debug("Ignore device as vendor/model not found: " + str(host))
                    error_mssg = error_mssg + "-> No vendor/model found in response for " + str(host)
            else:
                error_mssg = error_mssg + "-> No device info received in response for " + str(host)
        return cip_info, error_mssg


    ''' MODBUS MODE PROBE '''


    def parse_modbus_rsp(msg, device_info, server_address_port):
        if msg[7] == 43 and len(msg) > 15:  # modbus.func_code = Encapsulated Interface Transport
            more_follows = msg[11]
            next_object_id = msg[12]
            number_of_objects = msg[13]
            offset = 14
            for i in range(0, number_of_objects):
                object_id = msg[offset]
                object_len = msg[offset + 1]
                if not object_len:
                    break
                object_value = msg[offset+2:offset+2+object_len].decode("utf-8")
                if object_id in modbus_object_id_mapping:
                    device_info[modbus_object_id_mapping[object_id]] = object_value
                offset = offset + 2 + object_len
            if more_follows == '0xff' and next_object_id != '00':
                modbus_request = unhexlify('000100000005002b0e02' + '01')
                msg_ff, err_msg = tcp_socket(modbus_request, server_address_port)
                return parse_modbus_rsp(msg_ff, device_info, server_address_port)
        return device_info


    def modbus_get_device_info(destination, destination_port=502):
        modbus_info = []
        hosts = [destination]
        port = destination_port
        error_mssg = ""
        modbus_request = unhexlify('000100000005002b0e0200')  # request identity packet - Read Regular Device Identification
        for host in hosts:
            err_msg = None
            serverAddressPort = (host, port)
            msg, err_msg = tcp_socket(modbus_request, serverAddressPort)
            if err_msg:
                error_mssg = error_mssg + " -> " + err_msg
            if not msg:
                demisto.error("Error fetching Modbus info for " + host)
                error_mssg = error_mssg + "-> No response received for modbus request sent to "+ str(host)
                continue
            device_info = parse_modbus_rsp(msg, {}, serverAddressPort)
            # modbus_info[host] = parse_modbus_rsp(msg, {}, serverAddressPort)
            if "productCode" in device_info.keys() and "model" not in device_info.keys():
                device_info["model"] = device_info.pop("productCode")
            if device_info:
                device_info['connect_evtContent.ip'] = host
                # device_info['deviceid'] = host
                device_info['sourceProtocol'] = 'modbus'
                if all(attribute in device_info for attribute in req_attributes):
                    modbus_info.append(device_info)
                else:
                    demisto.debug("Ignore device as vendor/model not found: " + str(host))
                    error_mssg = error_mssg + "-> No vendor/model found in response for " + str(host)
            else:
                error_mssg = error_mssg + "-> No device info received in response for " + str(host)
        return modbus_info, error_mssg


    ''' SNMP MODE PROBE '''


    def get_mac_ip_map(host, port, oid, version):
        result = {}
        try:
            demisto.info('SNMP Polling started for host: %s and oid: %s' % (host, oid))
            raw_result = walk(host, port, oid, version)
            if type(raw_result) is tuple:
                for item in raw_result:
                    if type(item) is dict:
                        for k, v in item.items():
                            raw_ip = k.split(DOT)[-4:]
                            ip = DOT.join(raw_ip)
                            raw_mac = v[2:]
                            mac = ':'.join(a+b for a,b in zip(raw_mac[::2], raw_mac[1::2]))
                            demisto.info('SNMP Polled IP: %s and mac: %s' % (ip, mac))
                            result[mac] = ip
                        demisto.info('SNMP polling finished for host: %s and oid: %s' % (host, oid))
            elif type(raw_result) is dict:
                for k, v in raw_result.items():
                    raw_ip = k.split(DOT)[-4:]
                    ip = DOT.join(raw_ip)
                    raw_mac = v[2:]
                    mac = ':'.join(a+b for a,b in zip(raw_mac[::2], raw_mac[1::2]))
                    demisto.info('SNMP Polled IP: %s and mac: %s' % (ip, mac))
                    result[mac] = ip
                demisto.info('SNMP polling finished for host: %s and oid: %s' % (host, oid))
        except:
            traceback.print_exc()
        return result


    def walk(host, port, oid, version):
        result = {}
        err_mssg = ''
        if version == "SNMPv2":
            data = CommunityData(SNMP_COMMUNITY)
        elif version == "SNMPv1":
            if SNMP_COMMUNITY:
                data = CommunityData(SNMP_COMMUNITY)
            else:
                data = CommunityData('public')
        else:  # snmp version 3
            if SNMP_SECURITY_LEVEL == "noAuthNoPriv":
                data = UsmUserData(SNMP_USERNAME)
            elif SNMP_SECURITY_LEVEL == "authNoPriv":
                if not SNMP_AUTH_PROTOCOL or not SNMP_AUTH_PASSWORD:
                    err_mssg = "snmp version 3 authNoPriv requires SNMP authentication Protocol and authentication password. Check integration settings."
                    return result, err_mssg
                if SNMP_AUTH_PROTOCOL == "SHA":
                    data = UsmUserData(SNMP_USERNAME, SNMP_AUTH_PASSWORD,
                                       authProtocol=usmHMACSHAAuthProtocol)
                elif SNMP_AUTH_PROTOCOL == "MD5":
                    data = UsmUserData(SNMP_USERNAME, SNMP_AUTH_PASSWORD,
                                       authProtocol=usmHMACMD5AuthProtocol)
                else:
                    err_mssg = "snmp version 3 requires SNMP authentication Protocol. Check integration settings."
                    return result, err_mssg
            elif SNMP_SECURITY_LEVEL == "authPriv":
                if not SNMP_AUTH_PROTOCOL or not SNMP_AUTH_PASSWORD or not SNMP_PRIVACY_PROTOCOL or not SNMP_PRIVACY_PASSWORD:
                    err_mssg = "snmp version 3 authPriv requires SNMP authentication Protocol, authentication password, privacy protocol and privacy password. Check integration settings."
                    return result, err_mssg
                if SNMP_AUTH_PROTOCOL == "SHA" and SNMP_PRIVACY_PROTOCOL == "AES":
                    data = UsmUserData(SNMP_USERNAME, SNMP_AUTH_PASSWORD, SNMP_PRIVACY_PASSWORD,
                                       authProtocol=usmHMACSHAAuthProtocol,
                                       privProtocol=usmAesCfb128Protocol)
                elif SNMP_AUTH_PROTOCOL == "SHA" and SNMP_PRIVACY_PROTOCOL == "DES":
                    data = UsmUserData(SNMP_USERNAME, SNMP_AUTH_PASSWORD, SNMP_PRIVACY_PASSWORD,
                                       authProtocol=usmHMACSHAAuthProtocol,
                                       privProtocol=usmDESPrivProtocol)
                elif SNMP_AUTH_PROTOCOL == "MD5" and SNMP_PRIVACY_PROTOCOL == "AES":
                    data = UsmUserData(SNMP_USERNAME, SNMP_AUTH_PASSWORD, SNMP_PRIVACY_PASSWORD,
                                       authProtocol=usmHMACMD5AuthProtocol,
                                       privProtocol=usmAesCfb128Protocol)
                elif SNMP_AUTH_PROTOCOL == "MD5" and SNMP_PRIVACY_PROTOCOL == "DES":
                    data = UsmUserData(SNMP_USERNAME, SNMP_AUTH_PASSWORD, SNMP_PRIVACY_PASSWORD,
                                       authProtocol=usmHMACMD5AuthProtocol,
                                       privProtocol=usmDESPrivProtocol)
                else:
                    err_mssg = "snmp version 3 requires SNMP security credentials. Check integration settings."
                    return result, err_mssg
            else:
                err_mssg = "snmp version 3 requires SNMP security level. Check integration settings."
                return result, err_mssg

        for (errorIndication,errorStatus,errorIndex,varBinds) in nextCmd(SnmpEngine(),
                    data, UdpTransportTarget((host, port),timeout=1.0, retries=0), ContextData(),
                    ObjectType(ObjectIdentity(oid)),
                    lexicographicMode=False):
            if errorIndication:
                # print(errorIndication)
                demisto.info('Walk timeout error indication: %s host: %s oid: %s' % (str(errorIndication), host, oid))
                err_mssg = "SNMP Walk timeout error"
                break
            elif errorStatus:
                # print('%s at %s' % (errorStatus.prettyPrint(),
                #                    errorIndex and varBinds[int(errorIndex) - 1][0] or '?'))
                demisto.info('Walk error status: %s at %s host: %s oid: %s' % (errorStatus.prettyPrint(), errorIndex and varBinds[int(errorIndex) - 1][0] or '?', host, oid))
                err_mssg = "SNMP Walk error : " + str(errorStatus.prettyPrint())
                break
            else:
                for varBind in varBinds:
                    result[varBind[0].prettyPrint()] = str(varBind[1].prettyPrint())
        return result, err_mssg


    def snmp_auth_get_device_info(version, destination, destination_port=161):
        snmp_info = []
        hosts = [destination]
        port = destination_port
        error_mssg = ""
        if (version == "SNMPv1") or (version == "SNMPv2" and SNMP_COMMUNITY) or (version == "SNMPv3" and SNMP_SECURITY_LEVEL and SNMP_USERNAME):
            for host in hosts:
                snmp_sys_name = None
                raw_snmp_sys_descr, err_mssg = walk(host, destination_port, SNMP_SYS_DESC_OID, version)
                if err_mssg:
                    error_mssg = error_mssg + "-> " + err_mssg
                raw_snmp_sys_name, err_mssg = walk(host, destination_port, SNMP_SYS_NAME_OID, version)
                if err_mssg:
                    error_mssg = error_mssg + "-> " + err_mssg
                for k, v in raw_snmp_sys_name.items():
                    snmp_sys_name = v
                if raw_snmp_sys_descr:
                    snmp_sys_descr = raw_snmp_sys_descr[next(iter(raw_snmp_sys_descr))]
                    if snmp_sys_descr:
                        mac_ip_map = get_mac_ip_map(host, destination_port, SNMP_MAC_IP_PAIR_OID, version)
                        if get_mac_ip_map:
                            for mac, ip in mac_ip_map.items():
                                if ip == host:
                                    device_info = {}
                                    device_info['deviceid'] = mac
                                    device_info['connect_evtContent.ip'] = ip
                                    device_info['rawSNMPSysDescr'] = snmp_sys_descr
                                    if snmp_sys_name:
                                        device_info['SNMPSysName'] = snmp_sys_name
                                    device_info['sourceProtocol'] = version
                                    snmp_info.append(device_info)
                        else:
                            error_mssg = error_mssg + "-> No MAC to IP mapping received in response for " + str(host)
                else:
                    error_mssg = error_mssg + "-> No system description received in response for " + str(host)
        else:
            error_mssg = error_mssg + "-> Check integration settings for required fields."
        return snmp_info, error_mssg


    ''' FANUC FOCAS MODE PROBE '''


    def fanuc_focus_get_device_info(destination, destination_port=8193):
        fanuc_info = []
        hosts = [destination]
        port = destination_port
        error_mssg = ""
        for host in hosts:
            device_info = {}
            fanuc_model = ''
            serverAddressPort = (host, port)
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(10)
                sock.connect(serverAddressPort)
            except Exception as e:
                return fanuc_info, "error: " + str(e)
            # Connection open request
            conn_open_data, err_msg = send_receive_socket(sock, fanuc_focus_requests['connect_req'], 'connect_req')
            if err_msg:
                error_mssg = error_mssg + " -> " + err_msg
            if conn_open_data:
                if len(conn_open_data) < 10 and conn_open_data[6] != 0x01 and conn_open_data[7] != 0x02 and len(conn_open_data) != (int.from_bytes(conn_open_data[8:10], "big") + 10):
                    demisto.debug("FANUC Focas could not open connection with " + str(host))
                    error_mssg = error_mssg + "-> FANUC Focas open connection failed for " + str(host)
                    continue
                sys_info_data, err_msg = send_receive_socket(sock, fanuc_focus_requests['sysinfo_req'], 'sysinfo_req')
                if err_msg:
                    error_mssg = error_mssg + " -> " + err_msg
                if sys_info_data and len(sys_info_data) < 46:
                    demisto.debug('FANUC Focas: No valid Sys Info response received for ' + str(host))
                    error_mssg = error_mssg + '-> No valid sys info response received for ' + str(host)
                    continue
                if int.from_bytes(sys_info_data[:4], "big") != 2694881440: # Check a0 a0 a0 a0 (header)
                    demisto.debug('FANUC Focas: No valid header in Sys Info response received for ' + str(host))
                    error_mssg = error_mssg + '-> No valid header in sys info response received for ' + str(host)
                    continue
                if int.from_bytes(sys_info_data[8:10], "big") + 10 != len(sys_info_data):
                    demisto.debug('FANUC Focas: No valid length in payload for Sys Info response received for ' + str(host))
                    error_mssg = error_mssg + '-> No valid length in payload for sys info response received for ' + str(host)
                    continue
                if int.from_bytes(sys_info_data[14:20], "big") != 4295032856: # Check 00 01 00 01 00 18 (get sysinfo command)
                    demisto.debug('FANUC Focas: No valid header in Sys Info response received for ' + str(host))
                    error_mssg = error_mssg + '-> No valid header in sys info response received for ' + str(host)
                    continue
                if int.from_bytes(sys_info_data[20:26], "big") != 0: # Check 00 00 00 00 00 00 (ok - no error)
                    demisto.debug('FANUC Focas: Error in Sys Info response payload received for ' + str(host))
                    error_mssg = error_mssg + '-> Error in Sys info response payload received for ' + str(host)
                    continue
                # Parse the Model
                sysinfo_cnctype = sys_info_data[32:34].decode('utf-8')
                if sysinfo_cnctype == "PD":
                    fanuc_model += 'CNC Series Power Mate i-D'
                elif sysinfo_cnctype == "PH":
                    fanuc_model += 'CNC Series Power Mate i-H'
                elif sysinfo_cnctype == "PM":
                    fanuc_model += 'CNC Series Power Motion i'
                else:
                    fanuc_model += 'CNC Series ' + sysinfo_cnctype
                    if sys_info_data[28] & (1 << 1) > 0:  # Check if it's i series
                        fanuc_model += 'i'
                if sys_info_data[29] > 0:   # Model information
                    fanuc_addinfo_model = {1: 'A', 2: 'B', 3: 'C', 4: 'D', 6: 'F'}
                    if fanuc_addinfo_model.get(sys_info_data[29]):
                        fanuc_model += ' MODEL ' + fanuc_addinfo_model.get(sys_info_data[29])
                if fanuc_model:
                    device_info['model'] = fanuc_model

                # Parse Module Type
                sysinfo_mttype = sys_info_data[34:36].decode('utf-8')
                fanuc_module = {' M': 'Machining Center', ' T': 'Lathe', 'MM': 'M Series with 2 Path Control',
                                'TT': 'T Series with 2/3 Path Control', 'MT': 'T Series with Compound Machining Function',
                                ' P': 'Punch Press', 'L': 'Laser', ' W': 'Wire Cut'}
                if fanuc_module.get(sysinfo_mttype):
                    device_info['moduleType'] = fanuc_module.get(sysinfo_mttype)

                # Parse FirmwareVer
                sysinfo_version = sys_info_data[40:44].decode('utf-8')  # FirmwareVer
                if sysinfo_version:
                    device_info['firmwareVer'] = sysinfo_version
                # Unused fields from payload for now
                # sysinfo_axes = sys_info_data[30:32]
                # sysinfo_series = sys_info_data[36:40]
                # sysinfo_maxaxis = sys_info_data[44:46]
            if device_info:
                device_info['vendor'] = 'FANUC'
                device_info['connect_evtContent.ip'] = host
                device_info['sourceProtocol'] = 'FANUC Focas'
                if all(attribute in device_info for attribute in req_attributes):
                    fanuc_info.append(device_info)
                else:
                    demisto.debug("Ignore device as vendor/model not found: " + str(host))
                    error_mssg = error_mssg + "-> No vendor/model found in response for " + str(host)
            else:
                error_mssg = error_mssg + "-> No device info received in response for " + str(host)
        return fanuc_info, error_mssg


    ''' IEC 61850 MMS MODE PROBE '''


    def mms_get_device_info(destination, destination_port=102):
        mms_info = []
        hosts = [destination]
        port = destination_port
        error_mssg = ""
        for host in hosts:
            device_info = {}
            serverAddressPort = (host, port)
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(10)
                sock.connect(serverAddressPort)
            except Exception as e:
                return mms_info, "error: " + str(e)
            # COTP connection establishment
            cotp_data, err_msg = send_receive_socket(sock, mms_requests['COTP'], 'COTP')
            if err_msg:
                error_mssg = error_mssg + " -> " + err_msg
            if cotp_data:
                if cotp_data[5] != 0xd0:    # CC_connect_confirm
                    demisto.debug("MMS INFO: Could not negotiate COTP with " + str(host))
                    error_mssg = error_mssg + "-> COTP negotiation failed for " + str(host)
                    continue

                initiate_req_rsp, err_msg = send_receive_socket(sock, mms_requests['mms_initiate_req'], 'mms_initiate_req')
                if err_msg:
                    error_mssg = error_mssg + " -> " + err_msg
                if initiate_req_rsp and len(initiate_req_rsp) < 20:
                    demisto.debug("MMS INFO: No valid response received from " + str(host))
                    error_mssg = error_mssg + "-> No valid response received from " + str(host)
                    continue

                msg, err_msg = send_receive_socket(sock, mms_requests['mms_confirmed_req'], 'mms_confirmed_req')
                if err_msg:
                    error_mssg = error_mssg + " -> " + err_msg
                if msg:
                    if msg[3] == len(msg) and msg.find(b'\x02\x01\x01'):
                        offset = msg.find(b'\x02\x01\x01') + 3
                        if len(msg) > offset and msg[offset] == 0xa2 and (len(msg) == offset + msg[offset + 1] + 2):
                            offset += 2
                        elif len(msg) > offset and msg[offset] == 0xa2 and (len(msg) == offset + msg[offset + 2] + 3):
                            offset += 3
                        else:
                            error_mssg = error_mssg + "-> Could not find valid offset " + str(host)
                            continue
                        if len(msg) > offset and msg[offset] == 0x80 and (len(msg) >= offset + msg[offset + 1] + 2):
                            offset += 2
                            device_info["vendor"] = msg[offset : offset + msg[offset - 1]].decode("utf-8")
                            offset += msg[offset - 1]
                        else:
                            error_mssg = error_mssg + "-> Could not find valid vendor " + str(host)
                            continue
                        if len(msg) > offset and msg[offset] == 0x81 and (len(msg) >= offset + msg[offset + 1] + 2):
                            offset += 2
                            device_info["model"] = msg[offset : offset + msg[offset - 1]].decode("utf-8")
                            offset += msg[offset - 1]
                        else:
                            error_mssg = error_mssg + "-> Could not find valid model " + str(host)
                            continue
                        if len(msg) > offset and msg[offset] == 0x82 and (len(msg) >= offset + msg[offset + 1] + 2):
                            offset += 2
                            device_info["firmwareVer"] = msg[offset : offset + msg[offset - 1]].decode("utf-8")
                            offset += msg[offset - 1]
                        else:
                            error_mssg = error_mssg + "-> Could not find valid firmware version " + str(host)
                            continue
            if device_info:
                device_info['connect_evtContent.ip'] = host
                device_info['sourceProtocol'] = 'IEC 61850 MMS'
                if all(attribute in device_info for attribute in req_attributes):
                    mms_info.append(device_info)
                else:
                    demisto.debug("Ignore device as vendor/model not found: " + str(host))
                    error_mssg = error_mssg + "-> No vendor/model found in response for " + str(host)
            else:
                error_mssg = error_mssg + "-> No device info received in response for " + str(host)
        return mms_info, error_mssg


    ''' SIEMENS S7 MODE PROBE '''


    def parse_szl1(data):
        data_dict = {}
        if data[7] == 0x32:    # check protocol ID and length of response
            if len(data) >= 64:
                data_dict['moduleNumber'] = data[43:63].decode('utf-8').strip().replace('\x00', '')
            if len(data) >= 92:
                data_dict['model'] = data[71:91].decode('utf-8').strip().replace('\x00', '')
            if len(data) >= 124:
                data_dict['firmwareVer'] = 'v' + str(data[122]) + "." + str(data[123]) + str(data[124])
            if len(data) >= 150:
                data_dict['firmwareExt'] = data[127:147].decode('utf-8').strip().replace('\x00', '')
        return data_dict


    def parse_szl2(data):
        data_dict = {}
        if data[7] == 0x32:    # Check protocol ID
            offset = 0
            if data[30] != 0x1c:    # change offset to 4, this is where most of valid PLCs will fall
                offset = 4
            if len(data) >= 39 + offset + 32:
                data_dict['hostname'] = data[39+offset:(39+offset+32)].decode('utf-8').strip().replace('\x00', '')
            if len(data) >= 73 + offset + 32:
                data_dict['moduleType'] = data[73+offset:(73+offset+32)].decode('utf-8').strip().replace('\x00', '')
            if len(data) >= 107 + offset + 32:
                data_dict['plantIdentification'] = data[107+offset:(107+offset+32)].decode('utf-8').strip().replace('\x00', '')
            if len(data) >= 141 + offset + 32:
                data_dict['copyright'] = data[141+offset:(141+offset+32)].decode('utf-8').strip().replace('\x00', '')
            if len(data) >= 175 + offset + 32:
                data_dict['serialNumber'] = data[175+offset:(175+offset+32)].decode('utf-8').strip().replace('\x00', '')
            if len(data) >= 209 + offset + 32:
                data_dict['cpuName'] = data[209+offset:(209+offset+32)].decode('utf-8').strip().replace('\x00', '')
            if len(data) >= 243 + offset + 32:
                data_dict['serialNumMemoryCard'] = data[243+offset:(243+offset+32)].decode('utf-8').strip().replace('\x00', '')
        return data_dict


    def siemens_s7_get_device_info(destination, destination_port=102):
        siemens_s7_info = []
        hosts = [destination]
        port = destination_port
        error_mssg = ""
        for host in hosts:
            device_info = {}
            cotp_success = False
            err_msg = None
            serverAddressPort = (host, port)
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(10)
                sock.connect(serverAddressPort)
            except Exception as e:
                return siemens_s7_info, "error: " + str(e)
            # COTP connection establishment
            cotp_data, err_msg = send_receive_socket(sock, s7_requests['COTP1'], 'COTP1')
            if err_msg:
                error_mssg = error_mssg + " -> " + err_msg
            if cotp_data:
                cotp_success = True
            else:
                sock.close()
                time.sleep(2)
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(10)
                sock.connect(serverAddressPort)
                cotp_data, err_msg = send_receive_socket(sock, s7_requests['COTP2'], 'COTP2')
                if err_msg:
                    error_mssg = error_mssg + " -> " + err_msg
                if cotp_data:
                    cotp_success = True
            if cotp_success:
                if cotp_data[5] != 0xd0:    # CC_connect_confirm
                    demisto.debug("S7 INFO: Could not negotiate COTP with " + str(host))
                    error_mssg = error_mssg + "-> COTP negotiation failed for " + str(host)
                    continue
                rosctr_setup, err_msg = send_receive_socket(sock, s7_requests['ROSCTR_Setup'], 'ROSCTR_Setup')
                if err_msg:
                    error_mssg = error_mssg + " -> " + err_msg
                if rosctr_setup:
                    if rosctr_setup[7] != 0x32:
                        demisto.debug("S7 INFO: No response received from " + str(host))
                        error_mssg = error_mssg + "-> No response received from " + str(host)
                        continue
                    szl_data, err_msg = send_receive_socket(sock, s7_requests['first_SZL_Request'], 'first_SZL_Request')
                    if err_msg:
                        error_mssg = error_mssg + " -> " + err_msg
                    if szl_data:
                        device_info.update(parse_szl1(szl_data))
                        szl_data, err_msg = send_receive_socket(sock, s7_requests['second_SZL_Request'], 'second_SZL_Request')
                        if err_msg:
                            error_mssg = error_mssg + " -> " + err_msg
                        if szl_data:
                            device_info.update(parse_szl2(szl_data))
            else:
                error_mssg = error_mssg + "-> COTP Handshake failed for " + str(host)
            if device_info:
                device_info['connect_evtContent.ip'] = host
                # device_info['deviceid'] = host
                device_info['vendor'] = 'Siemens'
                device_info['sourceProtocol'] = 'Siemens-s7'
                if all(attribute in device_info for attribute in req_attributes):
                    siemens_s7_info.append(device_info)
                else:
                    demisto.debug("Ignore device as vendor/model not found: " + str(host))
                    error_mssg = error_mssg + "-> No vendor/model found in response for " + str(host)
            else:
                error_mssg = error_mssg + "-> No device info received in response for " + str(host)
        return siemens_s7_info, error_mssg


    ''' SIEMENS S7 COMM Plus MODE PROBE '''


    def siemens_s7_comm_plus_get_device_info(destination, destination_port=102):
        siemens_s7_comm_plus_info = []
        hosts = [destination]
        port = destination_port
        error_mssg = ""
        for host in hosts:
            device_info = {}
            err_msg = None
            try:
                snap7client = snap7.client.Client()
                snap7client.connect(host, 0, 0, port)
                # ipaddress, rack, slot, port
                snap7client.get_connected()
                deviceData = snap7client.get_cpu_info()
                if deviceData:
                    device_info['moduleType'] = deviceData.ModuleTypeName.decode('utf-8')
                    device_info['serialNumber'] = deviceData.SerialNumber.decode('utf-8')
                    device_info['hostname'] = deviceData.ASName.decode('utf-8')
                    device_info['copyright'] = deviceData.Copyright.decode('utf-8')
                    device_info['model'] = deviceData.ModuleName.decode('utf-8')
                    device_info['connect_evtContent.ip'] = host
                    # device_info['deviceid'] = host
                    device_info['vendor'] = 'Siemens'
                    device_info['sourceProtocol'] = 'Siemens-S7-Comm-Plus'
            except Exception as e:
                demisto.error('S7 Comm Plus client error while connecting: %s' % (str(host)))
                demisto.error("Error: "+str(e))

                demisto.debug("Trying again...")
                serverAddressPort = (host, port)
                try:
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(10)
                    sock.connect(serverAddressPort)
                except Exception as e:
                    return siemens_s7_comm_plus_info, "error: " + str(e)
                # COTP connection establishment
                cotp_data, err_msg = send_receive_socket(sock, s7_comm_plus_requests['COTP'], 'COTP')
                if err_msg:
                    error_mssg = error_mssg + " -> " + err_msg
                if cotp_data:
                    if cotp_data[5] != 0xd0:    # CC_connect_confirm
                        demisto.debug("S7 Comm Plus INFO: Could not negotiate COTP with " + str(host))
                        error_mssg = error_mssg + "-> COTP negotiation failed for " + str(host)
                        continue
                    create_obj_data, err_msg = send_receive_socket(sock, s7_comm_plus_requests['Create_Object'], 'Create_Object')
                    if err_msg:
                        error_mssg = error_mssg + " -> " + err_msg
                    if create_obj_data and len(create_obj_data) > 11:
                        if create_obj_data[11] != 0x32:
                            demisto.debug("S7 Comm Plus INFO: No response received from " + str(host))
                            error_mssg = error_mssg + "-> No response received from " + str(host)
                            continue
                        s7_comm_plus_data_offset = create_obj_data.find(b'\x82\x3f\x00\x15\x1b')
                        if s7_comm_plus_data_offset <= 0 or len(create_obj_data) < (s7_comm_plus_data_offset + 4):
                            demisto.debug("S7 Comm Plus INFO: No valid response received from " + str(host))
                            error_mssg = error_mssg + "-> No valid response received from " + str(host)
                            continue
                        data_length = create_obj_data[s7_comm_plus_data_offset + 4]
                        if data_length <= 0:
                            demisto.debug("S7 Comm Plus INFO: not data in response received from " + str(host))
                            error_mssg = error_mssg + "-> No data in response received from " + str(host)
                            continue
                        s7_comm_plus_data = create_obj_data[s7_comm_plus_data_offset+5:s7_comm_plus_data_offset+5+data_length].decode('utf-8')
                        if not s7_comm_plus_data:
                            demisto.debug("S7 Comm Plus INFO: No valid data in response received from " + str(host))
                            error_mssg = error_mssg + "-> No valid data in response received from " + str(host)
                            continue
                        s7_comm_plus_attributes = s7_comm_plus_data.split(';')
                        if len(s7_comm_plus_attributes) < 2:
                            demisto.debug("S7 Comm Plus INFO: No valid attributes in data received from " + str(host))
                            error_mssg = error_mssg + "-> No valid attributes in response received from " + str(host)
                            continue
                        device_info['model'] = s7_comm_plus_attributes[1]
                        device_info['firmwareVer'] = s7_comm_plus_attributes[2]
                        device_info['connect_evtContent.ip'] = host
                        # device_info['deviceid'] = host
                        device_info['vendor'] = 'Siemens'
                        device_info['sourceProtocol'] = 'Siemens-S7-Comm-Plus'

            if all(attribute in device_info for attribute in req_attributes):
                siemens_s7_comm_plus_info.append(device_info)
            else:
                demisto.debug("Ignore device as vendor/model not found: " + str(host))
                error_mssg = error_mssg + "-> No vendor/model found in response for " + str(host)
        return siemens_s7_comm_plus_info, error_mssg


    ''' CodeSysV3 MODE PROBE'''


    def get_codesys_address(remote_host, port):
        local_host = socket.gethostbyname(socket.gethostname())
        sender_address_int = int((format(int(repr(port)[-1]), '04b') + format(int(local_host.split('.')[-1]), '08b')) ,2)
        sender_address = f'{sender_address_int:04x}'
        receiver_address_int = int((format(int(repr(port)[-1]), '04b') + format(int(remote_host.split('.')[-1]), '08b')) ,2)
        receiver_address = f'{receiver_address_int:04x}'
        return receiver_address, sender_address


    def codesysv3_get_device_info(destination, destination_port=1740):
        codesys_v3_info = []
        hosts = [destination]
        port = destination_port
        error_mssg = ""
        for host in hosts:
            device_info = {}
            err_msg = None
            serverAddressPort = (host, port)
            receiver_address, sender_address = get_codesys_address(host, port)
            request_payload = unhexlify('c5744003001143cb'+receiver_address + sender_address+'000002c20004fd4b0000')
            msg, err_msg = udp_socket(request_payload, serverAddressPort)
            if err_msg:
                error_mssg = error_mssg + " -> " + err_msg
            if not msg:
                error_mssg = error_mssg + "-> No response received from " + str(host)
                continue
            if len(msg) < 60:
                error_mssg = error_mssg + "-> No valid response received from " + str(host)
                continue
            if msg[0] != 0xc5:  # Invalid magic byte
                error_mssg = error_mssg + "-> No valid response received from " + str(host)
                continue
            if msg[3] != 0x04:  # Invalid service ID
                error_mssg = error_mssg + "-> No valid response received from " + str(host)
                continue
            address_length_hex = msg[5]
            address_length_bin = bin(address_length_hex)[2:].zfill(8)
            address_length = (int(address_length_bin[:4], 2) + int(address_length_bin[4:], 2)) * 2

            if msg[8+address_length] != 0x80 or msg[9+address_length] != 0xc2:  # Invalid Package type not identification
                error_mssg = error_mssg + "-> No valid response received from " + str(host)
                continue

            node_info = msg[16+address_length:]
            node_name_length = int.from_bytes(node_info[6:8], "little")
            device_name_length = int.from_bytes(node_info[8:10], "little")
            vendor_name_length = int.from_bytes(node_info[10:12], "little")
            serial_no_length = node_info[28]
            oem_data_length = node_info[29]

            start_offset = 40
            end_offset = start_offset+(node_name_length*2)
            if len(node_info) >= end_offset:
                device_info['hostname'] = node_info[start_offset:end_offset].decode('utf-8').strip().replace('\x00', '')

            start_offset = end_offset + 2
            end_offset = start_offset + (device_name_length*2)
            if len(node_info) >= end_offset:
                device_info['model'] = node_info[start_offset:end_offset].decode('utf-8').strip().replace('\x00', '')

            start_offset = end_offset + 2
            end_offset = start_offset + (vendor_name_length*2)
            if len(node_info) >= end_offset:
                device_info['vendor'] = node_info[start_offset:end_offset].decode('utf-8').strip().replace('\x00', '')

            start_offset = end_offset + 2
            end_offset = start_offset + serial_no_length
            if len(node_info) >= end_offset:
                device_info['serialNumber'] = node_info[start_offset:end_offset].decode('utf-8').strip().replace('\x00', '')

            start_offset = end_offset
            end_offset = start_offset + oem_data_length
            if len(node_info) >= end_offset:
                device_info['oemData'] = node_info[start_offset:end_offset].hex()

            if all(attribute in device_info for attribute in req_attributes):
                device_info['connect_evtContent.ip'] = host
                # device_info['deviceid'] = host
                device_info['sourceProtocol'] = 'CodeSysV3'
                codesys_v3_info.append(device_info)
            else:
                demisto.debug("Ignore device as vendor/model not found: " + str(host))
                error_mssg = error_mssg + "-> No vendor/model found in response for " + str(host)
        return codesys_v3_info, error_mssg


    ''' WinRM MODE PROBE '''


    def winrm_get_device_info(destination, destination_port=5985, connection_test=False):
        winrm_info = []
        hosts = [destination]
        port = destination_port
        error_mssg = ""
        for host in hosts:
            map_ip_mapping = []
            software_ver_info = []
            sys_info_dict = {}
            serverAddressPort = host + ':' + str(port)
            if not WINRM_USERNAME or not WINRM_PASSWORD:
                return winrm_info, "-> Check integration settings for required fields."
            prot = winrm.protocol.Protocol(
                endpoint=f"http://{serverAddressPort}/wsman",
                transport="ntlm",
                username=WINRM_USERNAME,
                password=WINRM_PASSWORD,
                server_cert_validation="ignore"
            )
            try:
                shell = prot.open_shell()
            except Exception as e:
                return winrm_info, str(e)

            command = prot.run_command(shell, WINRM_GET_IP_MAC)
            out, err, status = prot.get_command_output(shell, command)
            if err:
                demisto.error('Error WinRM Probing: %s' % (str(err)))
                error_mssg = error_mssg + "-> Error while polling IP-MAC mapping using WinRM: " + str(err)
                continue
            raw_ip_mac = out.decode()
            if raw_ip_mac:
                split_raw_ip_mac = raw_ip_mac.strip().split('\n')
                for idx, item in enumerate(split_raw_ip_mac):
                    if idx == len(split_raw_ip_mac) - 1:
                        continue
                    item_split = item.strip().split(':')
                    for val in item_split:
                        if val.startswith('Physical') and split_raw_ip_mac[split_raw_ip_mac.index(item)+1].strip().startswith('IPv4 Address'):
                            map_ip_mapping.append({item_split[item_split.index(val)+1].strip().replace('-', ':') : split_raw_ip_mac[split_raw_ip_mac.index(item)+1].split(':')[1].replace('(Preferred)', '').strip()})
            if map_ip_mapping and connection_test:
                return map_ip_mapping, error_mssg
            command = prot.run_command(shell, WINRM_GET_SOFTWARE)
            out, err, status = prot.get_command_output(shell, command)
            if not err:
                raw_software_version_data = out.decode()
                if raw_software_version_data:
                    split_data = []
                    for row in raw_software_version_data.split('\n'):
                        row_split = row.split(',')
                        if len(row_split) > 3:
                            split_data.append([row_split[0], row_split[1], row_split[2], row_split[-1]])
                    split_data.pop(0)
                    for entry in split_data:
                        if len(entry) == 4 and entry[1] and entry[2] and entry[3]:
                            tmp_dict = {'Name': entry[1].replace('\r\r', ''),
                                        'Vendor': entry[2].replace('\r\r', ''),
                                        'Version': entry[3].replace('\r\r', '')
                                        }
                            software_ver_info.append(tmp_dict)
            else:
                demisto.error('Error WinRM Probing: %s' % (str(err)))
                error_mssg = error_mssg + "-> Error while polling list of software using WinRM: " + str(err)

            command = prot.run_command(shell, WINRM_GET_SYSTEMINFO)
            out, err, status = prot.get_command_output(shell, command)
            if not err:
                raw_system_info_data = out.decode()
                if raw_system_info_data:
                    keys_to_filter = ['OS', 'System', 'Product', 'Host']
                    for line in raw_system_info_data.split('\n'):
                        try:
                            k, v = line.split(':')
                        except ValueError:
                            continue
                        for attribute in keys_to_filter:
                            if k.startswith(attribute):
                                sys_info_dict[k.strip()] = v.strip().replace('\r\r', '')

                command = prot.run_command(shell, WINRM_GET_HOTFIX_ID)
                out, err, status = prot.get_command_output(shell, command)
                raw_hotfix = out.decode()
                if raw_hotfix:
                    sys_info_dict['Hotfix'] = raw_hotfix.strip().replace('\r\r','').split('\n')[1:-2]
                else:
                    error_mssg = error_mssg + "-> Error while polling hotfix info using WinRM: " + str(err)
            else:
                demisto.error('Error WinRM Probing: %s' % (str(err)))
                error_mssg = error_mssg + "-> Error while polling system info using WinRM: " + str(err)

            if software_ver_info or sys_info_dict:
                for mac_ip in map_ip_mapping:
                    for key, val in mac_ip.items():
                        device_info = dict()
                        device_info['connect_evtContent.ip'] = val
                        device_info['deviceid'] = key.lower()
                        device_info['sourceProtocol'] = 'WinRM'
                        if sys_info_dict:
                            device_info['sysInfo'] = sys_info_dict
                        if software_ver_info:
                            device_info['softwareVersion'] = software_ver_info
                        winrm_info.append(device_info)
            else:
                error_mssg = error_mssg + "-> No device info received in response for " + str(host)
        return winrm_info, error_mssg


    ''' Omron FINS MODE PROBE '''


    def omron_fins_get_device_info(destination, destination_port=9600):
        fins_info = []
        hosts = [destination]
        port = destination_port
        error_mssg = ""
        for host in hosts:
            device_info = {}
            serverAddressPort = (host, port)
            request_payload = unhexlify('800002000000006300ef050100')
            msg, err_msg = udp_socket(request_payload, serverAddressPort)
            if err_msg:
                error_mssg = error_mssg + " -> " + err_msg
            if not msg:
                error_mssg = error_mssg + "-> No response received from " + str(host)
                continue
            if not (msg[0] == 0xc0 or msg[0] == 0xc1 or msg[0] == 0x46):  # Invalid header byte
                error_mssg = error_mssg + "-> Invalid header byte " + str(host)
                continue
            header = struct.unpack("B", msg[0:1])[0]
            if not (header == 0xc0 or header == 0xc1 or header == 0x46):
                error_mssg = error_mssg + "-> Invalid header byte " + str(host)
                continue
            response_code = struct.unpack("H", msg[12:14])[0]
            if response_code != 0:
                error_mssg = error_mssg + "-> Invalid response code " + str(host)
                continue
            model = struct.unpack("20s", msg[14:34])
            if model:
                device_info['model'] = model[0].decode("utf-8").strip()
            firmwareVer = struct.unpack("20s", msg[34:54])[0]
            if firmwareVer:
                device_info['firmwareVer'] = firmwareVer.decode('utf-8').strip().replace('\x00', '')
            device_info['vendor'] = "Omron"
            if all(attribute in device_info for attribute in req_attributes):
                device_info['connect_evtContent.ip'] = host
                device_info['sourceProtocol'] = 'Omron FINS'
                fins_info.append(device_info)
            else:
                demisto.debug("Ignore device as vendor/model not found: " + str(host))
                error_mssg = error_mssg + "-> No vendor/model found in response for " + str(host)
        return fins_info, error_mssg


    ''' Mitsubishi MELSOFT Mode Probe '''


    def parse_melsoft_response(msg):
        device_info = {}
        if len(msg) > 2:
            packet_type = int.from_bytes(msg[0:2], "big")
            if packet_type in (55041, 55040) and len(msg) > 53:
                data_length = int.from_bytes(msg[19:21], "little")
                identifier_byte = int.from_bytes(msg[47:49], "big")
                if len(msg) - 21 == data_length:
                    if identifier_byte == 2848:   # Check for 0b20 DISCOVERY BYTES
                        data = msg[53:]
                        # src_ip = data[0:4]
                        # netmask = data[4:8]
                        # deviceid = data[8:14].hex()
                        deviceid = hex(data[8]).lstrip("0x") + ':' + \
                                   hex(data[9]).lstrip("0x") + ':' + \
                                   hex(data[10]).lstrip("0x") + ':' + \
                                   hex(data[11]).lstrip("0x") + ':' + \
                                   hex(data[12]).lstrip("0x") + ':' + \
                                   hex(data[13]).lstrip("0x")
                        device_info['deviceid'] = deviceid
                        device_info['model'] = data[14:30].decode("utf-8").strip().replace('\x00', '')
                        device_info['vendor'] = 'Mitsubishi Electric Corporation'
                    elif identifier_byte == 289:  # Check for 0121 CONNECT BYTES
                        data = msg[53:]
                        device_info['model'] = data[:16].decode("utf-8").strip().replace('\x00', '')
                        device_info['vendor'] = 'Mitsubishi Electric Corporation'
        return device_info


    def melsoft_get_device_info(destination, mode, destination_port):
        melsoft_info = []
        hosts = [destination]
        port = destination_port
        error_mssg = ""
        for host in hosts:
            serverAddressPort = (host, port)
            msg = None
            try:
                if mode == 'tcp':
                    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                    sock.settimeout(10)
                    sock.connect(serverAddressPort)
                    request_payload = unhexlify('5a0000ff')
                    msg, err_msg = send_receive_socket(sock, request_payload, 'melsoft_initial_query')
                    if msg:
                        request_payload = unhexlify('57000000001111070000ffff030000fe0300001e001c0a161400000000000000040000000000000000000000000b2001000000')
                        msg, err_msg = send_receive_socket(sock, request_payload, 'melsoft_discovery_query')
                        if err_msg:
                            error_mssg = error_mssg + " -> " + err_msg
                        if not msg:
                            request_payload = unhexlify('57000000001111070000ffff030000fe03000020001c0a161400000000000000000000000000000000000000000121010000000001')
                            msg, err_msg = send_receive_socket(sock, request_payload, 'melsoft_connect_query')
                            if err_msg:
                                error_mssg = error_mssg + " -> " + err_msg
                elif mode == 'udp':
                    request_payload = unhexlify('57010000001111070000ffff030000xfe0300001e001c0a161400000000000000040000000000000000000000000b2001000000')
                    msg, err_msg = udp_socket(request_payload, serverAddressPort)
                    if err_msg:
                        error_mssg = error_mssg + " -> " + err_msg
                    if not msg:
                        request_payload = unhexlify('57000000001111070000ffff030000fe03000020001c0a161400000000000000000000000000000000000000000121010000000001')
                        msg, err_msg = udp_socket(request_payload, serverAddressPort)
                        if err_msg:
                            error_mssg = error_mssg + " -> " + err_msg
                if not msg:
                    error_mssg = error_mssg + "-> No response received from " + str(host)
                    continue
                else:
                    device_info = parse_melsoft_response(msg)
                if all(attribute in device_info for attribute in req_attributes):
                    device_info['connect_evtContent.ip'] = host
                    device_info['sourceProtocol'] = 'MELSOFT'
                    melsoft_info.append(device_info)
                else:
                    demisto.debug("Ignore device as vendor/model not found: " + str(host))
                    error_mssg = error_mssg + "-> No vendor/model found in response for " + str(host)
            except Exception as e:
                return melsoft_info, "error: " + str(e)
        return melsoft_info, error_mssg


    ''' UPnP Mode Probe '''


    def parse_upnp_attribute(xml, xml_name, attribute_type):
        try:
            temp = xml.find(xml_name).text
            if attribute_type == "moduleType":
                attribute_type_regex = re.compile("device:(.+):")
                attribute_type_match = attribute_type_regex.search(temp)
                if attribute_type_match.group(1):
                    temp = re.sub(r"\B([A-Z])", r" \1", attribute_type_match.group(1))
            return temp
            # print('\t-> %s: %s' % (print_name, temp))
        except AttributeError:
            return None


    def parse_upnp_location(location):
        results = dict()
        try:
            resp = requests.get(location, timeout=5)
            try:
                xmlRoot = ET.fromstring(resp.text)
            except:
                return results, 'Failed XML parsing of location'
            results = {
                "moduleType": parse_upnp_attribute(xmlRoot, "./{urn:schemas-upnp-org:device-1-0}device/{urn:schemas-upnp-org:device-1-0}deviceType", "moduleType"),
                "hostname": parse_upnp_attribute(xmlRoot, "./{urn:schemas-upnp-org:device-1-0}device/{urn:schemas-upnp-org:device-1-0}friendlyName", "hostname"),
                "vendor": parse_upnp_attribute(xmlRoot, "./{urn:schemas-upnp-org:device-1-0}device/{urn:schemas-upnp-org:device-1-0}manufacturer", "vendor"),
                "vendorURL": parse_upnp_attribute(xmlRoot, "./{urn:schemas-upnp-org:device-1-0}device/{urn:schemas-upnp-org:device-1-0}manufacturerURL", "vendorURL"),
                "description": parse_upnp_attribute(xmlRoot, "./{urn:schemas-upnp-org:device-1-0}device/{urn:schemas-upnp-org:device-1-0}modelDescription", "description"),
                "model": parse_upnp_attribute(xmlRoot, "./{urn:schemas-upnp-org:device-1-0}device/{urn:schemas-upnp-org:device-1-0}modelName", "model"),
                # "Model Number": parse_upnp_attribute(xmlRoot, "./{urn:schemas-upnp-org:device-1-0}device/{urn:schemas-upnp-org:device-1-0}modelNumber", "Model Number),
                "serialNumber": parse_upnp_attribute(xmlRoot, "./{urn:schemas-upnp-org:device-1-0}device/{urn:schemas-upnp-org:device-1-0}serialNumber", "serialNumber"),
            }
            # if resp.headers.get('server'):
            #     results['server'] = str(resp.headers.get('server'))
            return results, None
        except requests.exceptions.ConnectionError:
            return results, 'Could not load location'
        except requests.exceptions.ReadTimeout:
            return results, 'Timeout reading from location'


    def upnp_get_device_info(destination, destination_port=1900):
        upnp_info = []
        hosts = [destination]
        port = destination_port
        error_mssg = ""
        for host in hosts:
            device_info = {}
            serverAddressPort = (host, port)
            location_regex = re.compile("location:[ ]*(.+)\r\n", re.IGNORECASE)
            ssdp_payload = ('M-SEARCH * HTTP/1.1\r\n' +
                            'HOST: 239.255.255.250:1900\r\n' +
                            'MAN: "ssdp:discover"\r\n' +
                            'MX: 1\r\n' +
                            'ST: ssdp:all\r\n' +
                            '\r\n')
            data, err_msg = udp_socket(ssdp_payload.encode('ASCII'), serverAddressPort)
            if err_msg:
                error_mssg = error_mssg + " -> " + err_msg
            if not data:
                error_mssg = error_mssg + "-> No response received from " + str(host)
                continue
            else:
                location_result = location_regex.search(data.decode('ASCII'))
                if location_result and location_result.group(1):
                    location = location_result.group(1)
                    device_info, err_msg = parse_upnp_location(location)
                    if err_msg:
                        error_mssg = error_mssg + " -> " + err_msg
            if all(attribute in device_info for attribute in req_attributes):
                device_info['connect_evtContent.ip'] = host
                device_info['sourceProtocol'] = 'UPnP'
                upnp_info.append(device_info)
            else:
                demisto.debug("Ignore device as vendor/model not found: " + str(host))
                error_mssg = error_mssg + "-> No vendor/model found in response for " + str(host)
        return upnp_info, error_mssg


    ''' AUTO MODE PROBE '''


    def get_service_name(port, proto):
        try:
            name = socket.getservbyport(int(port), proto)
        except Exception as e:
            return None
        return name


    def scan_port(host, port, proto):
        # print(host, port, proto)
        serverAddressPort = (host, port)
        if proto == 'tcp':
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(5)
                sock.connect(serverAddressPort)
                sock.close()
                return True
            except:
                return False
        elif proto == 'udp':
            UDP_IP = host
            MESSAGE = ""
            RPORT = port
            client = socket.socket(socket.AF_INET, socket.SOCK_DGRAM, socket.IPPROTO_UDP)
            if client == -1:
                # print("udp socket creation failed")
                client.close()
                return False
            sock1 = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
            if sock1 == -1:
                # print("icmp socket creation failed")
                client.close()
                sock1.close()
                return False
            try:
                client.sendto(MESSAGE.encode('utf_8'), (UDP_IP, RPORT))
                sock1.settimeout(1)
                data, addr = sock1.recvfrom(1024)
            except socket.timeout:
                #serv = get_service_name(RPORT, 'udp')
                #if not serv:
                #    client.close()
                #    sock1.close()
                #    return False
                #else:
                #    print('Port {}: Open'.format(RPORT))
                #    client.close()
                #    sock1.close()
                return True
            except socket.error as sock_err:
                if sock_err.errno == socket.errno.ECONNREFUSED:
                    # print(sock_err('Connection refused'))
                    demisto.debug('sock_err Connection refused')
                client.close()
                sock1.close()
                return False


    def get_port_range(port_range):
        a = port_range.split(',')
        b = []
        for item in a:
            try:
                if '-' in item:
                    start = int(item.split('-')[0])
                    end = int(item.split('-')[1])
                    for p in range(start, end + 1):
                        b.append(p)
                else:
                    b.append(int(item))
            except:
                continue
        return b


    def get_scan_info(destination, tcp_port='', udp_port=''):
        tcp_p = get_port_range(tcp_port)
        udp_p = get_port_range(udp_port)
        scan_result = []
        hosts = [destination]
        for host in hosts:
            host_result = {}
            tcp_list = []
            udp_list = []
            host_result["host"] = host
            for port in tcp_p:
                if scan_port(host, port, 'tcp'):
                    tcp_list.append({'Port': port, 'State': 'open'})
            host_result["TCP"] = tcp_list
            demisto.debug("List of open TCP port found for host " + str(host) + " are " + str(tcp_list))
            for port in udp_p:
                if scan_port(host, port, 'udp'):
                    udp_list.append({'Port': port, 'State': 'open'})
            host_result["UDP"] = udp_list
            demisto.debug("List of open UDP port found for host " + str(host) + " are " + str(udp_list))
            scan_result.append(host_result)
        return scan_result


    def autoProbe_v1_get_device_info(destination, tcp_port, udp_port, connection_test):
        raw_scan_result = {}
        scan_result = []
        scan_info = get_scan_info(destination, tcp_port, udp_port)
        raw_scan_result['Raw Scan Output'] = scan_info
        err_mssg = ''
        if connection_test and len(scan_info) > 0:
            return scan_info, err_mssg
        for entry in scan_info:
            host_val = entry["host"]
            for Val in entry['TCP']:
                if Val['State'] == 'open':
                    if Val['Port'] == 102:
                        s7ProbeResults, error_mssg = siemens_s7_get_device_info(host_val, 102)
                        if error_mssg:
                            err_mssg = error_mssg + '\n'
                        if s7ProbeResults:
                            raw_scan_result[host_val+'_siemensS7'] = s7ProbeResults
                            scan_result.extend(s7ProbeResults)
                        else:
                            s7CommPlusProbeResults, error_mssg = siemens_s7_comm_plus_get_device_info(host_val, 102)
                            if error_mssg:
                                err_mssg = error_mssg + '\n'
                            if s7CommPlusProbeResults:
                                raw_scan_result[host_val+'_siemensS7CommPlus'] = s7CommPlusProbeResults
                                scan_result.extend(s7CommPlusProbeResults)
                            else:
                                mmsProbeResults, error_msg = mms_get_device_info(host_val, 102)
                                if error_msg:
                                    err_mssg = error_mssg + '\n'
                                if mmsProbeResults:
                                    raw_scan_result[host_val+'_mms'] = mmsProbeResults
                                    scan_result.extend(mmsProbeResults)
                    elif Val['Port'] == 44818:
                        cipProbeResults, error_mssg = cip_get_device_info(host_val, 44818, 'tcp')
                        if error_mssg:
                            err_mssg = error_mssg + '\n'
                        if cipProbeResults:
                            raw_scan_result[host_val+'_cipEnip_tcp'] = cipProbeResults
                            scan_result.extend(cipProbeResults)
                    elif Val['Port'] == 502:
                        modbusProbeResults, error_mssg = modbus_get_device_info(host_val, 502)
                        if error_mssg:
                            err_mssg = error_mssg + '\n'
                        if modbusProbeResults:
                            raw_scan_result[host_val+'_modbus'] = modbusProbeResults
                            scan_result.extend(modbusProbeResults)
                    elif Val['Port'] == 5985:
                        winrmProbeResults, error_mssg = winrm_get_device_info(host_val, 5985)
                        if error_mssg:
                            err_mssg = error_mssg + '\n'
                        if winrmProbeResults:
                            raw_scan_result[host_val+'_winrm'] = winrmProbeResults
                            scan_result.extend(winrmProbeResults)
                    elif Val['Port'] == 8193:
                        fanucFocusProbeResults, error_mssg = fanuc_focus_get_device_info(host_val, 8193)
                        if error_mssg:
                            err_mssg = error_mssg + '\n'
                        if fanucFocusProbeResults:
                            raw_scan_result[host_val+'fanucFocus'] = fanucFocusProbeResults
                            scan_result.extend(fanucFocusProbeResults)
                    elif Val['Port'] == 5562:
                        melsoftProbeResults, error_mssg = melsoft_get_device_info(host_val, 'tcp', 5562)
                        if error_mssg:
                            err_mssg = error_mssg + '\n'
                        if melsoftProbeResults:
                            raw_scan_result[host_val+'_melsoft'] = melsoftProbeResults
                            scan_result.extend(melsoftProbeResults)
            for Val in entry['UDP']:
                if Val['State'] == 'open':
                    if Val['Port'] == 44818:
                        cipProbeResults, error_mssg = cip_get_device_info(host_val, 44818, 'udp')
                        if error_mssg:
                            err_mssg = error_mssg + '\n'
                        if cipProbeResults:
                            raw_scan_result[host_val+'_cipEnip_udp'] = cipProbeResults
                            scan_result.extend(cipProbeResults)
                    elif Val['Port'] == 47808:
                        bacnetProbeResults, error_mssg = bacnet_get_device_info(host_val, 47808, 0)
                        if error_mssg:
                            err_mssg = error_mssg + '\n'
                        if bacnetProbeResults:
                            raw_scan_result[host_val+'_bacnet'] = bacnetProbeResults
                            scan_result.extend(bacnetProbeResults)
                    elif Val['Port'] == 161:
                        snmpProbeResults, error_mssg = snmp_auth_get_device_info('SNMPv1', host_val, 161)
                        if error_mssg:
                            err_mssg = error_mssg + '\n'
                        if snmpProbeResults:
                            raw_scan_result[host_val+'_snmpv1'] = snmpProbeResults
                            scan_result.extend(snmpProbeResults)
                        elif SNMP_COMMUNITY:
                            snmpProbeResults, error_mssg = snmp_auth_get_device_info('SNMPv2', host_val, 161)
                            if error_mssg:
                                err_mssg = error_mssg + '\n'
                            if snmpProbeResults:
                                raw_scan_result[host_val+'_snmpv2'] = snmpProbeResults
                                scan_result.extend(snmpProbeResults)
                        elif SNMP_USERNAME:
                            snmpProbeResults, error_mssg = snmp_auth_get_device_info('SNMPv3', host_val, 161)
                            if error_mssg:
                                err_mssg = error_mssg + '\n'
                            if snmpProbeResults:
                                raw_scan_result[host_val+'_snmpv3'] = snmpProbeResults
                                scan_result.extend(snmpProbeResults)
                    elif Val['Port'] == 1740:
                        codesysv3ProbeResults, error_mssg = codesysv3_get_device_info(host_val, 1740)
                        if error_mssg:
                            err_mssg = error_mssg + '\n'
                        if codesysv3ProbeResults:
                            raw_scan_result[host_val+'_codesysv3'] = codesysv3ProbeResults
                            scan_result.extend(codesysv3ProbeResults)
                    elif Val['Port'] == 9600:
                        omronFinsProbeResults, error_mssg = omron_fins_get_device_info(host_val, 9600)
                        if error_mssg:
                            err_mssg = error_mssg + '\n'
                        if omronFinsProbeResults:
                            raw_scan_result[host_val+'_omronFins'] = omronFinsProbeResults
                            scan_result.extend(omronFinsProbeResults)
                    elif Val['Port'] == 5560:
                        melsoftProbeResults, error_mssg = melsoft_get_device_info(host_val, 'udp', 5560)
                        if error_mssg:
                            err_mssg = error_mssg + '\n'
                        if melsoftProbeResults:
                            raw_scan_result[host_val+'_melsoft'] = melsoftProbeResults
                            scan_result.extend(melsoftProbeResults)
                    elif Val['Port'] == 1900:
                        upnpProbeResults, error_mssg = upnp_get_device_info(host_val, 5000)
                        if error_mssg:
                            err_mssg = error_mssg + '\n'
                        if upnpProbeResults:
                            raw_scan_result[host_val+'_upnp'] = upnpProbeResults
                            scan_result.extend(upnpProbeResults)
        return scan_result, err_mssg


    ''' FETCH DEVICE INFO FUNCTION '''


    def fetch_device_info(protocol, ip, input_port=None, connection_test=False):

        resp = None
        error_mssg = ''
        device_info = {}

        if not input_port:
            ports = [default_protocols[protocol]]
        else:
            ports = []
            raw_ports = input_port.split(",")
            for raw_port in raw_ports:
                raw_port = raw_port.strip()
                if raw_port.isdigit() and int(raw_port) in range(1, 65536):
                    ports.append(int(raw_port))
            if len(ports) < 1:
                ports = [default_protocols[protocol]]

        for port in ports:
            if protocol == 'All':
                tcp_port = '102, 502, 5985, 44818'
                udp_port = '44818, 47808, 161, 1740, 9600, 5000, 1900'
                resp, error_mssg = autoProbe_v1_get_device_info(ip, tcp_port, udp_port, connection_test)
                if resp:
                    device_info = resp
                break
            elif protocol == 'BACnet':
                resp, error_mssg = bacnet_get_device_info(ip, port, 0)
            elif protocol == 'CIP Ethernet/IP':
                resp, error_mssg = cip_get_device_info(ip, port, 'both')
            elif protocol == 'Modbus':
                resp, error_mssg = modbus_get_device_info(ip, port)
            elif protocol == 'Siemens-S7':
                resp, error_mssg = siemens_s7_get_device_info(ip, port)
            elif protocol == 'Siemens-S7-Comm-Plus':
                resp, error_mssg = siemens_s7_comm_plus_get_device_info(ip, port)
            elif protocol in ['SNMPv1', 'SNMPv2', 'SNMPv3']:
                resp, error_mssg = snmp_auth_get_device_info(protocol, ip, port)
            elif protocol == 'CodeSysV3':
                resp, error_mssg = codesysv3_get_device_info(ip, port)
            elif protocol == 'WinRM':
                resp, error_mssg = winrm_get_device_info(ip, port, connection_test)
            elif protocol == 'IEC 61850 MMS':
                resp, error_mssg = mms_get_device_info(ip, port)
            elif protocol == 'Omron FINS':
                resp, error_mssg = omron_fins_get_device_info(ip, port)
            elif protocol == 'FANUC Focas':
                resp, error_mssg = fanuc_focus_get_device_info(ip, port)
            elif protocol == 'Mitsubishi MELSOFT TCP':
                resp, error_mssg = melsoft_get_device_info(ip, 'tcp', port)
            elif protocol == 'Mitsubishi MELSOFT UDP':
                resp, error_mssg = melsoft_get_device_info(ip, 'udp', port)
            elif protocol == 'UPnP':
                resp, error_mssg = upnp_get_device_info(ip, port)
            if resp:
                device_info = resp
                break

        if connection_test:
            if device_info:
                return 'ok'
            else:
                return 'Connection test Failed. ' + '\n' + error_mssg

        command_results = CommandResults(
            outputs_prefix='Device_Polling.DeviceInfo',
            outputs=device_info
        )
        return command_results


    """ MAIN FUNCTION """


    def main() -> None:

        params: Dict[str, Any] = demisto.params()
        args: Dict[str, Any] = demisto.args()
        command = demisto.command()

        mode = params["Mode"]
        port = params["Port"]
        # port_val = getDefaultPort(port, mode)
        demisto.debug(f"Excecuting command: {command} ..")

        try:
            if command == "test-module":
                proto = mode
                ip = params.get("connection_test_ip")
                if ip =='' or ip is None:
                    return_results("Connection test IP field is required.")
                if not is_valid_ipv4_address(ip):
                    return_results("Invalid IP address.")
                if port:
                    result = fetch_device_info(proto, ip, port, True)
                else:
                    result = fetch_device_info(proto, ip, None, True)
                return_results(result)

            elif command == "fetch-device-info-command":
                proto = args["proto"]
                ip = args["ip"]
                port = args.get("port", None)
                if port:
                    result = fetch_device_info(proto, ip, port)
                else:
                    result = fetch_device_info(proto, ip, None)
                return_results(result)

            elif command == "get-instance-protocol":
                result = {}
                result["mode"] = mode
                return_results(result)

            elif command == "get-instance-port":
                result = {}
                # port = params["Port"]
                # port_val = getDefaultPort(port, mode)
                # result["port"] = port_val
                result["port"] = params["Port"]
                return_results(result)

            else:
                raise NotImplementedError(f"Error, command not implemented: {command}")
        except Exception as exc:
            return_error(f"Error, failed to execute {command} command, error: {str(exc)}")


    if __name__ in ("__main__", "__builtin__", "builtins"):
        main()

    register_module_line('PANW IoT 3rd Party Integration - Asset Attribute Polling', 'end', __line__())
  subtype: python3
  type: python
sourcemoduleid: 'test integration '
