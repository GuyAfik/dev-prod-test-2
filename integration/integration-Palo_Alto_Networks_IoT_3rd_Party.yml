category: Network Security
commonfields:
  id: Palo Alto Networks IoT 3rd Party
  version: -1
configuration:
- display: Server URL
  name: url
  required: true
  type: 0
- display: Secret Access Key
  name: Access Key
  required: true
  type: 4
- display: Access Key ID
  name: Key ID
  required: true
  type: 4
- display: Long running instance
  name: longRunning
  required: false
  type: 8
- display: Incident type
  name: incidentType
  required: false
  type: 13
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: Base Integration for Palo Alto IoT third party integrations. This integration
  communicates with Palo Alto IoT Cloud to get alerts, vulnerabilities and devices.
display: Palo Alto Networks IoT 3rd Party
image: data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHgAAAAyCAYAAACXpx/YAAAABGdBTUEAALGPC/xhBQAADNlJREFUeAHtWgtwVNUZPufefeUdoqBUYnY3m5CQClR8YalSh9aiYqCVzuALaJVqO/XB1KqjYzO2+ADro2MZtXUyPLRaRE1ttU61ZIoWBwkgIRaS3ewGH6Ahj40J2WT33tPvv8m53F13SQJi1d47k5zXf/7/nO87/zn/OQlj9mcjYCNgI2AjYCNgI2AjYCNgI2AjYCNgI2AjYCNgI2AjYCNgI2AjYCNgI2AjYCNgI2AjYCPwf4oAH828o5eW3ci5aM2vC76UTr5rfqBG5cpr+S80v5Gu/YtQF/D66oUQ5w+Nhb8Ragt/6/MaV8Dr3SEEmz5s+2+wfcnnZVsZyVBXdeBmnekP64w911MdmJcq310duJfp4learr/Ss6B8Vmq7Xc6MwNTS0gnlfv+sQIn/R+Xl5adkljz6liMSTOQyIR4k9Vj9rlSSiVzU32aYFyLXJnn0RJSXlM7tS2gfaZq+WTD9SX1AP3X0vUcv6cgkaiVXyhgkc06efBnIPtck97CAJHnuF3m7lsP9KqYBb+AcRdFzNJ07PTmerWkJTkeuBGPIk5VKwUWVrLOmXAgoF2WoG9V5XFbi/z50/dLQwVnDlYsX/3xd7ZrbGWdXIUCYiLOrEW2vFJ5YtLKhoSEubS1cuFDdsW3bRWj/AeqmYIsJQL6fcR7EfvPyJOZ9pD5SH5PyI6VlPt95QmfXwO5UwZiXCdaCuGMXE45Hg23BHdb+M2bMcPZ0dV0qNDEfspWMi1IueC9S2FbqCk4Y93vrWK19M+cTf0Sc8IlsF0ypCUVCf6cyMOcBv/8aYHsRxjWVMZ4PW42Qedvpca3cs2dPB8lVVVW54v39OboQczH2dxL9Cf+ngqwjkUtKOOe3F9YF7xMLq1zdgwPPwbp5LkMZbPJrC18MPkmyo/kCXv/1Quirh2X3Q/9mTOiHqX05Z1sUl+vS5ubmg3Re6QPxesFEIFVOljGWVkeW5yw5+UxBFpHV3dH5KOZxLfp+Cg/OeAKT/m0w0mocRZV+f9mgLl6DfMYtFUqaVI975t69ew3C0gVZtEVrTHtZjjc15Qq/KhgOr6/wVngTLPY0FvLMVBkqY3wHFaYsa24LvRAIBNwiLs5VmH6RzsU2h+IOJZ3BoyXXMPTn3XHOxIfSaCq5oma2I1pdWjvGwAseO0QuiB6UuimlCYLU+ygP4GBXqJQ3P86jmO0BWYZn+RP9A4/IcqY02tF1B5QvQ7tJrtU2FpEDC/DWMq//OtKRPW5cBImH8vJDx04sgo9lGbartMFBY6yybqQUNntIj/yB/EBNTY2SjlzImjsZxneixrWny73lFcFgcMDhYINc5fB8NYqRR0yCx0IubRnR+YHVAP0nNHAMKslzDXK3v/+0LtiSMQdenO9TFX52S7jVwxzqGdAdluBgMkuxSqdggoJx5Q9DhPI7XQr3hiLhwlAkMpFz5W4pj3bs5AuTF4LZyFiF318Ocu8wqzhvge3pZNvhUGfBtrmAMedVsD2etl54TS3G8B52q1u401EcbIucAPsnYUzmghK6WGTqHU1GqN8jPeZPOLxhfe3a66yeC7sbVbdrPHDJUzijBYdQCJ9gHp3FH6Ps3lDozebW1tdpe6fdziD4KMk1VnQmckHGQjIIAGXgNaorlKLw5c3h8FYiMRQKNQDEmww9Q78UpmnnUjY7P/d3npycEtwpV8RV9RCuG3PougGD50t5kOJqbGgoleXUNC7EbPJQWQ9yfwrb75BtAgq2jW2Z2iGXC9vnUF51O1dM8pb4Q+HwA+6EOxHw+b5b6vNdy5l+NrUPf+O+7vOdJAtHkwquz7H061I9rqVEGnlqSyTyOI6tZ2Q75jprtne2R5ZlqhxXcqWVMZCsulz1shulKG+ylrFgjOBO07R47NChGwIl3pCIJz7GdeMfdN3ARE2CqR8CjowgI2gZfnwwLOjOrKx/JdlS1VTb36D2oqKixAdtbbeVen1tMdG3H976Kgw9AW8zFoDUgX00o20pM0Jq2BuS4Q3yTJd9BOf1Mo9U/VDZd5qlbGQVuHBxaqUsYyUbARWVAZzclkfnuVKJmQoVW7bbLGbI5OTk9FubHA7HAMpC1mFvzqazKdbb9wpAXYUGv2wbDogo6h7lx3OkIOaawHaekGVKYTtpLIiQsykoa99/oF7Xxa8BihlooT+2btZk7X+seczHMj7cEFI+2Euq03XFlJeiSkFdcLnC+UOyQqafKbmc9XOuzit8sfl1qT9TGu2I4hpw+IvFYrQqMZehD5P+z1Nr1y5A6QJZh7NvpUNVzhz/tZPzscXfbtaPkIHH7ZIitJ0/VfvUZFmmVMTj06xlprDG6MGuqyB7lqzHNlmDc3gGnYucKffI+rGmqkPA15K/pPExcRo5mVWC6yxpfO4ctzkfKWcoTSX5f0UuDUqIxAp4STbl6Uzhmp4CmrITQpatix0qPGHcnXtbW7dt2bKlX9eSt2jSk+lTFbbV2iZ44n66S1Id0txEQr/b2o7D+m2M0LQNnNpbwuG7cSZup3NR5+w8q/yR8tzBeqztCEbN46LS5yuhNoQCh8cnmLfMV3qj7FNWUlYJe3S1Mz4wH2pqauqUZZmaAQaRHK0O0F74Md1zSeCYt+UxeK4cENILogc7mgMlvh3vi7bpCG4myTZM4t/BSLAed+dKjE5WZ3d3dNThoWITxluJn6tlw0gpAqrNuB/XoU81ySKdF+s71FJa4mvEEXA6qiaaOrjy+J7W1mbY/gCCRjXkx8Pu8wiw3oQ3Tcd16nJTfoSMxnlzkohg92Is38EoSnDPngYCq1w5rgdifX1LMdWTSRb6H8LYrsSu0amL+DdRbziC0cbVXyTpGy4kbQtEciZyDXlcfAEynYlMXoXMaHlYoZkcHbnUfT/gOwV6L7GSi+Uc5dz5MxJws6wXsFUfpLzxCTYXZ+JK4L4UcnhNGv3n4bjqWcE2zlVxMTQcJpfxBk9OlgEgIuhn4bmHX5wEmz8UC4grkvSMMAR4fDvm8JwUw2LJo4WGOZAn42Esvow8EngvsdoD8jMgh4VwmFy6nuFa9KLUZU2TCJYNUJAUUB2uZwra1kQXlF4dxT33OJDLnKpyIez9U9pEqmO+b6gu5+ktkZadVN8UaTqA6BAk8N1SDiAM4qR+xpOTfQbySduflEmX7g6HP+IOdSrO7hXo126VAbgf0l339LPOOBtg91IbItkwQJ4HMltMWc5i8Kpah9t1JkhLCtRMmTQZxe28nsac2gRdm6B/E9UHI5FXcb5PgdzzGE+fRVaHzC68eF0YirTeZKlPyqJP+g/b9YO4Ytyc2mpMQLAr4Mp4ohRXprZjIKMOqKhvylMlc3jcp9BLlfFEJxITmZM1YbWnJYwW4hS//1Sd8/GaojTSOUg6J0+enJc1kGU8cJSdWfbJhg0bNDpTnX1O40iK58QTkjCSt350d40J1efwOFrkM6e1XebJNuz4dF0vLCgowHV76J0cjyH5uYlcw3HmL5nfg4hft9rW8/X4rl27rESxGX5/QTfnAVXXE568vGBqu7RJt4d169b5US6YMGHCuxRzyLZMaUaCqUMqycOr8/LCvwQ3CBjr3r5+TRLJYySXbGQimNrs79gRMIOsdKpk4EWebCWXZDlWJkheDJJRgicfBbnpbH6Z6+hZFF6f39jY2AWvLdq9e3fXNDxv0pychYW9rKvLGefceAsoKi7ubG9vz0ef7o0bNxZUVFT0tLzdkrczsrN75syZWZ2dnQ562KCbRKf6Xj71xy5xiNoGBwd5Xkeevt+930ky9I8DRVpxT7q/nh3RgyXY3dVlqxDCbSXPlXUyJU+O7lj/GA76Z0dzz5X9ZPpV8mB6J2cJbQdi0fNwQD6Bs30Oynj8EC8Jpm7gTJuGAJLOy+1CUa7nutiM59Ef65r+DBzkCjzoL8Bz55+w+/8GVyQ8nKhr0QcPZewGtA8iRrhL6LyMK6IIwdgcnM3LWSKBgIt/G3oP4D18icRVpmmDLNko08K6llvSkUvt5MmIvJcdDbnUfxI7tZYe0OXPokWLDlD9l/YTYhvAX22OH09vuHu46I/vCJjuh0ftdHC+vLW1dR8a3tU0cStE3gKpt4BUPAQpF+DhaTXIxH/LDL9F45UI+hDwsxjpxd+tF+O3QMyxHXLbcV3qha6TKC4w7Q5njrhFpwofj/LwtmIMnPQjkDgeZj4XnW63u3dA1/+qcv4WHi4uy83NjfdGo1vwty9tsL9/NgbxPAjZ5lZVI8hSmLpGV/SLXar64GBCu8ednf06j/G3YnrfXbgnqW63Y1U8kRiPPg+jbzHH0ymPx/fBrW5lQimlP3LAQ4sRZMZBMv5BAZbsz0bARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBGwEbARsBGwEbARuCzROC/A75cYaeLqTEAAAAASUVORK5CYII=
name: Palo Alto Networks IoT 3rd Party
script:
  commands:
  - arguments:
    - auto: PREDEFINED
      description: Type of Asset.
      name: asset_type
      predefined:
      - device
      - alert
      - vulnerability
      required: true
    - description: 'Increment time in minutes. Example: Increment Time = 15 mins will
        return input type assets modified or discovered within the last 15 minutes.
        A Null value will return full inventory (1000 MAX)'
      name: increment_time
    - description: '(Optional)Offset for paging: Null value will accumulate all results
        by default.'
      name: offset
    - description: '(Optional)Page size for paging: Null value will accumulate all
        results by default.'
      name: page_length
    - description: '(Optional)Comma separated list of PANW site names: Null value
        will accumulate results from all sites.'
      name: site_names
    - auto: PREDEFINED
      description: '(Optional)Comma separated list of PANW device tags: Null value
        will accumulate results from all tagged and untagged data.'
      name: tags
      predefined:
      - Cisco ISE:In Scope
      - Cisco ISE with pxGrid:In Scope
      - Aruba Clearpass:In Scope
      - Forescout:In Scope
    description: Returns a list of assets for the specified asset type.
    name: panw-iot-3rd-party-get-asset-list
    outputs:
    - contextPath: PanwIot3rdParty.Devices
      description: List of devices.
    - contextPath: PanwIot3rdParty.Alerts
      description: List of Alerts.
    - contextPath: PanwIot3rdParty.Vulnerabilities
      description: List of Vulnerabilities.
  - arguments:
    - auto: PREDEFINED
      description: Type of Asset.
      name: asset_type
      predefined:
      - device
      - alert
      - vulnerability
      required: true
    - description: Asset ID. MacAddress for device, zb_ticketid for alert and vulnerability.
      name: asset_id
      required: true
    description: For a given a asset ID (alert-id, vulnerability-id or mac-address)
      returns the asset details.
    name: panw-iot-3rd-party-get-single-asset
    outputs:
    - contextPath: PanwIot3rdParty.SingleAsset
      description: Asset Details.
  - arguments:
    - auto: PREDEFINED
      description: Status to be reported to PANW IoT Cloud.
      name: status
      predefined:
      - error
      - success
      - disabled
      required: true
    - description: Message to be sent to PANW IoT Cloud.
      name: message
      required: true
    - auto: PREDEFINED
      description: Name of PANW IoT 3rd Party Integration.
      name: integration_name
      predefined:
      - siem
      - ise
      - servicenow
      - qualys
      required: true
    - description: Name of customers defined integration name.
      name: custom_integration_name
    - description: Name of the playbook.
      name: playbook_name
      required: true
    - auto: PREDEFINED
      description: Type of asset associated with the status report.
      name: asset_type
      predefined:
      - device
      - alert
      - vulnerability
      required: true
    description: Sends a status message back to PANW IOT cloud.
    name: panw-iot-3rd-party-report-status-to-panw
  - arguments:
    - auto: PREDEFINED
      description: Input asset type.
      name: asset_type
      predefined:
      - device
      - alert
      - vulnerability
      required: true
    - auto: PREDEFINED
      description: Desired output format.
      name: output_format
      predefined:
      - CiscoISECustomAttributes
      - SIEM
      - ServiceNow
      required: true
    - description: List of input assets.
      isArray: true
      name: asset_list
    - description: ServiceNow ID and deviceid mapping.
      isArray: true
      name: servicenow_map
    - description: Incident triggered by PANW IoT cloud API.
      name: incident
    - description: User defined ServiceNow table configuration.
      name: customized_servicenow_config
    - description: PANW IoT device category name and ServiceNow category name map.
      name: iot_servicenow_category_map
    description: For a given asset (alert, device, vuln) converts it to 3rd party
      format.
    name: panw-iot-3rd-party-convert-assets-to-external-format
    outputs:
    - contextPath: PanwIot3rdParty.VulnerabilityCEFSyslogs
      description: List of CEF formatted vulnerability syslogs for SIEM.
    - contextPath: PanwIot3rdParty.AlertCEFSyslogs
      description: List of CEF formatted alert syslogs for SIEM.
    - contextPath: PanwIot3rdParty.DeviceCEFSyslogs
      description: List CEF formatted device syslogs for SIEM.
    - contextPath: PanwIot3rdParty.CiscoISEAttributes
      description: List Cisco ISE attribute dicts/maps.
    - contextPath: PanwIot3rdParty.AlertServiceNow
      description: Single SN formatted alert string.
    - contextPath: PanwIot3rdParty.VulnerabilityServiceNow
      description: Single SN formatted vulnerability string.
    - contextPath: PanwIot3rdParty.DeviceServiceNow
      description: List of upsert ready formatted device for SN.
  - arguments:
    - defaultValue: "15"
      description: specify minutes of active device
      name: active_range
    - defaultValue: "0"
      description: '(Optional)Offset for paging: Null value will accumulate all results
        by default.'
      name: offset
    - defaultValue: "1000"
      description: '(Optional)Page size for paging: Null value will accumulate all
        results by default.'
      name: pageLength
    - description: comma seperated site ids
      name: siteids
    - auto: PREDEFINED
      description: Return the active device list with only macs if it is true, else
        it will return all the details.
      name: mac_only
      predefined:
      - "true"
      - "false"
    - name: single_call
    description: Returns a list of MAC address of active devices.
    name: panw-iot-3rd-party-get-active-list
    outputs:
    - contextPath: PanwIot3rdParty.Devices
      description: List of MAC address of active devices.
      type: Unknown
  - arguments:
    - description: Device Data to update
      isArray: true
      name: DeviceData
      required: true
    - description: '(Optional)Page size for paging: Null value will accumulate all
        results by default.'
      name: pageLength
    - description: (Optional) Integration name
      name: IntegrationName
    - description: (Optional) Integration instance name
      name: IntegrationInstanceName
    description: send device data to IoT Cloud
    name: panw-iot-3rd-party-report-devices
    outputs:
    - contextPath: PanwIot3rdParty.ReportDevices
      description: Message for the reported devices.
  - arguments:
    - description: Vulnerability Data to update
      isArray: true
      name: VulnerabilityData
      required: true
    - description: (Optional) Batch id should be unique for each set of API
      name: batchId
    - description: (Optional) Integration name
      name: IntegrationName
    description: send vulnerability data to IoT Cloud
    name: panw-iot-3rd-party-report-vulnerabilities
    outputs:
    - contextPath: PanwIot3rdParty.ReportVulnerability
      description: Message for the reported vulnerabilities.
  - arguments:
    - description: PANW IoT Device Data
      isArray: true
      name: Devices
      required: true
    description: extract MAC address from PANW IoT device data
    name: panw-iot-3rd-party-extract-mac-address
    outputs:
    - contextPath: PanwIot3rdParty.DeviceMacAddress
      description: PANW IoT device MAC addresses
      type: String
  - arguments:
    - description: DNA Center client detail
      isArray: true
      name: DNAcClientData
      required: true
    description: extract device data from DNA Center client details
    name: panw-iot-3rd-party-extract-dnac-device-data
    outputs:
    - contextPath: PanwIot3rdParty.DeviceData
      description: PANW IoT device data
      type: String
  - arguments:
    - description: Client detail
      isArray: true
      name: clientData
      required: true
    - description: Integration Name
      name: client
      required: true
    description: extract client details
    name: panw-iot-3rd-party-extract-device-data
    outputs:
    - contextPath: PanwIot3rdParty.DeviceData
      description: PANW IoT device data
      type: String
  - arguments: []
    description: Return the PANW IoT customer id.
    name: panw-iot-3rd-party-get-customerid
    outputs:
    - contextPath: PanwIot3rdParty.customerid
      description: PANW IoT customer id.
  - arguments:
    - auto: PREDEFINED
      description: Type of vulnerability scan
      name: scan_type
      predefined:
      - qualys
      - tenable
      - rapid7
      required: true
    - description: List of scanner appliances
      isArray: true
      name: scanner_list
      required: true
    - description: Type of scan profile
      isArray: true
      name: profile_list
      required: true
    - description: Type of sites
      isArray: true
      name: site_list
    - name: scanner_sync
    description: Report vulnerability integration scan options
    name: panw-iot-3rd-party-report-vulnerability-scan-option
  - arguments:
    - name: xml_upload
    - name: pdf_upload
    - name: job_id
    - auto: PREDEFINED
      name: scan_type
      predefined:
      - qualys
      - tenable
      - rapid7
    - name: report_id
    - auto: PREDEFINED
      name: status
      predefined:
      - success
      - error
      required: true
    - name: message
    - name: ip
    description: Upload reports (PDF + XML) for specified scan to IoT Cloud
    name: panw-iot-3rd-party-upload-vulnerability-scan-report
  - arguments:
    - description: Meta data object
      name: MetaData
      required: true
    - description: Integration name
      name: IntegrationName
      required: true
    description: Send metadata to PANW IOT cloud
    name: panw-iot-3rd-party-report-metadata
  - arguments:
    - auto: PREDEFINED
      description: ACL sync status
      name: status
      predefined:
      - success
      - failed
      required: true
    - description: ACL status message
      name: message
    - description: Job ID of the ACL
      name: job_id
      required: true
    description: Reports ACLs sync status to IoT cloud
    name: panw-iot-3rd-party-report-aclsync-status
  - arguments:
    - description: IP Address
      name: ip
      required: true
    description: Get Device Details using IP Address
    name: panw-iot-3rd-party-device-details
    outputs:
    - contextPath: PanwIot3rdParty.DeviceDetails
      description: Device details of an IP
  - arguments: []
    description: 'Gets a list of active integrations and max number of integrations
      allowed '
    name: panw-iot-3rd-party-get-active-integrations
    outputs:
    - contextPath: PanwIot3rdParty.ActiveIntegrations
      description: List of active Integrations
  - arguments: []
    name: panw-iot-3rd-party-heartbeat
  - arguments:
    - description: subnet data to update
      isArray: true
      name: subnet_data
      required: true
    - description: '(Optional)Page size for paging: Null value will accumulate all
        results by default.'
      name: page_length
    - description: (Optional) Integration Name
      name: integration_name
    - auto: PREDEFINED
      description: overwrites the subnet data available in PANW IoT cloud
      name: data_overwrite
      predefined:
      - "true"
      - "false"
    - auto: PREDEFINED
      description: overwrites the subnet site available in PANW IoT cloud
      name: site_overwrite
      predefined:
      - "true"
      - "false"
    description: Sends subnet data to IoT Cloud
    name: panw-iot-3rd-party-report-subnets
    outputs:
    - contextPath: PanwIot3rdParty.ReportSubnets
      description: Message for the reported subnets
  - arguments:
    - description: Specify File Entry ID
      name: file_upload
      required: true
    - auto: PREDEFINED
      description: Specify which API to be called
      name: api
      predefined:
      - NODE_GRAPH
      - L2L3
      - ENDPOINTS
      required: true
    description: Upload ND Files to PANW Backend
    name: panw-iot-3rd-party-upload-network-discovery-file
  - arguments:
    - description: Panorama Security Rules
      isArray: true
      name: security_rules
      required: true
    - description: Device Group
      name: device_group
      required: true
    description: Reports the panorama security rules to PANW IoT cloud
    name: panw-iot-3rd-party-send-panorama-rules
    outputs:
    - contextPath: PanwIot3rdParty.PanoramaSecurtityRules
  - arguments:
    - description: Array of panorama security rules uuid
      isArray: true
      name: uuids
      required: true
    description: Purges the security rules which are not part of these list of uuids.
    name: panw-iot-3rd-party-panorama-rules-uuid-purge
    outputs:
    - contextPath: PanwIot3rdParty.PanoramaSecurtityRules.UUID.Result
      description: Purges the security rules which are not part of these list of uuids.
  - arguments:
    - name: upload_file
    - name: floor_id
    name: panw-iot-3rd-party-upload-floorplan
  - arguments:
    - isArray: true
      name: location_map
    name: panw-iot-3rd-party-upload-location-map
  dockerimage: demisto/panw-iot:1.0.0.79918
  longRunning: true
  runonce: false
  script: |
    register_module_line('Palo Alto Networks IoT 3rd Party', 'start', __line__())























    import urllib3
    import shutil
    import gc
    from typing import Dict, Any
    import traceback
    import ssl
    import collections
    import threading
    import websocket as wsc
    from threading import Thread

    # Disable insecure warnings
    urllib3.disable_warnings()

    DEFAULT_HEADERS = {
        'X-Access-Key': demisto.params().get("Access Key"),
        'X-Key-Id': demisto.params().get("Key ID"),
        # 'Content-Type': 'application/json',
    }

    BASE_URL = demisto.params().get("url")
    if not BASE_URL.endswith("/"):
        BASE_URL = BASE_URL + "/"
    if not BASE_URL.startswith("https://") and not BASE_URL.startswith("http://"):
        BASE_URL = "https://" + BASE_URL

    #CUSTOMER_ID = demisto.params().get("Customer ID")
    CUSTOMER_ID = BASE_URL.split("https://")[1].split(".iot")[0]
    DEFAULT_PAGE_SIZE = 1000

    DEMISTO_URLS = demisto.demistoUrls()
    XSOAR_URL = None
    if 'server' in DEMISTO_URLS:
        XSOAR_URL = DEMISTO_URLS['server']

    XSOAR_PARAM_APIS = [
        "xsoar/heartbeat",
        "xsoar/integrations",
        "xsoar/status",
        "xsoar/device/scanDetails",
        "xsoar/device/reportUpload",
        "xsoar/device/aims",
        "xsoar/device/aims/metaInfo",
        "xsoar/profile/aclSync/status"
    ]

    API_TYPE_MAP = {
        "device": {
            "list_url": "pub/v4.0/device/list",
            "single_asset_url": "pub/v4.0/device",
            "context_path": "PanwIot3rdParty.Devices",
        },
        "alert": {
            "list_url": "pub/v4.0/alert/list",
            "single_asset_url": "pub/v4.0/alert",
            "context_path": "PanwIot3rdParty.Alerts",
        },
        "vulnerability": {
            "list_url": "pub/v4.0/vulnerability/list",
            "single_asset_url": "pub/v4.0/vulnerability",
            "context_path": "PanwIot3rdParty.Vulnerabilities",
        }
    }

    ARUBA_CP_FIELD_MAP = {
        "ip address": ["PanwIoTIP"],
        "ip_address": ["PanwIoTIP"],
        "profile": ["PanwIoTProfile"],
        "category": ["PanwIoTCategory"],
        "risk_score": ["PanwIoTRiskScore"],
        "confidence": ["PanwIoTConfidence"],
        "confidence_score": ["PanwIoTConfidence"],
        "tag": ["PanwIoTTag"],
        "asset_tag": ["PanwIoTTag"],
        "Tags": ["PanwIoTTag"],
        "hostname": ["PanwIoTHostname"],
        "osCombined": ["PanwIoTOS"],
        "model": ["PanwIoTModel"],
        "vendor": ["PanwIoTVendor"],
        "Serial_Number": ["PanwIoTSerial"],
        "endpoint_protection": ["PanwIoTEPP"],
        "AET": ["PanwIoTAET"],
        "External Network": ["PanwIoTInternetAccess"],
    }

    CISCO_ISE_FIELD_MAP = {
        "ip": ["ZingboxIpAddress", "PanwIoTIpAddress"],
        "ip address": ["ZingboxIP", "PanwIoTIP"],
        "ip_address": ["ZingboxIP", "PanwIoTIP"],
        "profile": ["ZingboxProfile", "PanwIoTProfile"],
        "category": ["ZingboxCategory", "PanwIoTCategory"],
        "risk_score": ["ZingboxRiskScore", "PanwIoTRiskScore"],
        "risk score": ["ZingboxRiskScore", "PanwIoTRiskScore"],
        "confidence": ["ZingboxConfidence", "PanwIoTConfidence"],
        "confidence score": ["ZingboxConfidence", "PanwIoTConfidence"],
        "confidence_score": ["ZingboxConfidence", "PanwIoTConfidence"],
        "tag": ["ZingboxTag", "PanwIoTTag"],
        "asset_tag": ["ZingboxTag", "PanwIoTTag"],
        "Tags": ["ZingboxTag", "PanwIoTTag"],
        "hostname": ["ZingboxHostname", "PanwIoTHostname"],
        "osCombined": ["ZingboxOS", "PanwIoTOS"],
        "model": ["ZingboxModel", "PanwIoTModel"],
        "vendor": ["ZingboxVendor", "PanwIoTVendor"],
        "Serial Number": ["ZingboxSerial", "PanwIoTSerial"],
        "Serial_Number": ["ZingboxSerial", "PanwIoTSerial"],
        "endpoint protection": ["ZingboxEPP", "PanwIoTEPP"],
        "endpoint_protection": ["ZingboxEPP", "PanwIoTEPP"],
        "AET": ["ZingboxAET", "PanwIoTAET"],
        "External Network": ["ZingboxInternetAccess", "PanwIoTInternetAccess"],
    }
    INT_FIELDS = ["risk_score", "risk score", "confidence", "confidence score", "confidence_score"]

    DEVICE_FIELDS_MAP = [
        ("ip_address", "dvc="),
        ("mac_address", "dvcmac="),
        ("hostname", "dvchost="),
        ("profile", "cs1Label=Profile cs1="),
        ("category", "cs2Label=Category cs2="),
        ("profile_type", "cs3Label=ProfileType cs3="),
        ("vendor", "cs4Label=Vendor cs4="),
        ("model", "cs5Label=Model cs5="),
        ("vlan", "cs6Label=Vlan cs6="),
        ("site_name", "cs7Label=Site cs7="),
        ("risk_score", "cs8Label=RiskScore cs8="),
        ("risk_level", "cs9Label=RiskLevel cs9="),
        ("subnet", "cs10Label=Subnet cs10="),
        ("number_of_critical_alerts", "cs11Label=NumCriticalAlerts cs11="),
        ("number_of_warning_alerts", "cs12Label=NumWarningAlerts cs12="),
        ("number_of_caution_alerts", "cs13Label=NumCautionAlerts cs13="),
        ("number_of_info_alerts", "cs14Label=NumInfoAlerts cs14="),
        ("first_seen_date", "cs15Label=FirstSeenDate cs15="),
        ("confidence_score", "cs16Label=ConfidenceScore cs16="),
        ("os_group", "cs17Label=OsGroup cs17="),
        ("os/firmware_version", "cs18Label=OsFirmwareVersion cs18="),
        ("OS_Support", "cs19Label=OsSupport cs19="),
        ("OS_End_of_Support", "cs20Label=OsEndOfSupport cs20="),
        ("Serial_Number", "cs21Label=SerialNumber cs21="),
        ("endpoint_protection", "cs22Label=EndpointProtection cs22="),
        ("NetworkLocation", "cs23Label=NetworkLocation cs23="),
        ("AET", "cs24Label=AET cs24="),
        ("DHCP", "cs25Label=DHCP cs25="),
        ("wire_or_wireless", "cs26Label=WireOrWireless cs26="),
        ("SMB", "cs27Label=SMB cs27="),
        ("Switch_Port", "cs28Label=SwitchPort cs28="),
        ("Switch_Name", "cs29Label=SwitchName cs29="),
        ("Switch_IP", "cs30Label=SwitchIp cs30="),
        ("services", "cs31Label=Services cs31="),
        ("is_server", "cs32Label=IsServer cs32="),
        ("NAC_profile", "cs33Label=NAC_Profile cs33="),
        ("NAC_profile_source", "cs34Label=NAC_ProfileSource cs34="),
        ("Access_Point_IP", "cs35Label=AccessPointIp cs35="),
        ("Access_Point_Name", "cs36Label=AccessPointName cs36="),
        ("SSID", "cs37Label=SSID cs37="),
        ("Authentication_Method", "cs38Label=AuthMethod cs38="),
        ("Encryption_Cipher", "cs39Label=EncryptionCipher cs39="),
        ("AD_Username", "cs40Label=AD_Username cs40="),
        ("AD_Domain", "cs41Label=AD_Domain cs41="),
        ("Applications", "cs42Label=Applications cs42="),
        ("Tags", "cs43Label=Tags cs43="),
        ("os_combined", "cs44Label=os_combined cs44=")]

    VULNERABILITY_FIELDS_MAP = [
        ("ip", "dvc="),
        ("deviceid", "dvcmac="),
        ("name", "dvchost="),
        ("profile", "cs1Label=Profile cs1="),
        ("display_profile_category", "cs2Label=Category cs2="),
        ("profile_vertical", "cs1Labe3=Profile cs3="),
        ("vendor", "cs4Label=Vendor cs4="),
        ("model", "cs5Label=Model cs5="),
        ("vlan", "cs6Label=Vlan cs6="),
        ("site_name", "cs7Label=Site cs7="),
        ("risk_score", "cs8Label=RiskScore cs8="),
        ("risk_level", "cs9Label=RiskLevel cs9="),
        ("subnet", "cs10Label=Subnet cs10="),
        ("vulnerability_name", "cs11Label=vulnerabilityName cs11="),
        ("detected_date", "cs12Label=DetectionDate cs12="),
        ("remediate_instruction", "cs13Label=RemediateInstructions cs13="),
        ("remediate_checkbox", "cs14Label=RemediateCheckbox cs14="),
        ("first_seen_date", "cs15Label=FirstSeenDate cs15="),
        ("confidence_score", "cs16Label=ConfidenceScore cs16="),
        ("os", "cs17Label=OsGroup cs17="),
        ("os/firmware_version", "cs18Label=OsFirmwareVersion cs18="),
        ("osCombined", "cs19Label=OsSupport cs19="),
        ("OS_End_of_Support", "cs20Label=OsEndOfSupport cs20="),
        ("Serial_Number", "cs21Label=SerialNumber cs21="),
        ("endpoint_protection", "cs22Label=EndpointProtection cs22="),
        ("NetworkLocation", "cs23Label=NetworkLocation cs23="),
        ("AET", "cs24Label=AET cs24="),
        ("DHCP", "cs25Label=DHCP cs25="),
        ("wire_or_wireless", "cs26Label=WireOrWireless cs26="),
        ("SMB", "cs27Label=SMB cs27="),
        ("Switch_Port", "cs28Label=SwitchPort cs28="),
        ("Switch_Name", "cs29Label=SwitchName cs29="),
        ("Switch_IP", "cs30Label=SwitchIp cs30="),
        ("services", "cs31Label=Services cs31="),
        ("is_server", "cs32Label=IsServer cs32="),
        ("NAC_profile", "cs33Label=NAC_Profile cs33="),
        ("NAC_profile_source", "cs34Label=NAC_ProfileSource cs34="),
        ("Access_Point_IP", "cs35Label=AccessPointIp cs35="),
        ("Access_Point_Name", "cs36Label=AccessPointName cs36="),
        ("SSID", "cs37Label=SSID cs37="),
        ("Authentication_Method", "cs38Label=AuthMethod cs38="),
        ("Encryption_Cipher", "cs39Label=EncryptionCipher cs39="),
        ("AD_Username", "cs40Label=AD_Username cs40="),
        ("AD_Domain", "cs41Label=AD_Domain cs41="),
        ("Applications", "cs42Label=Applications cs42="),
        ("Tags", "cs43Label=Tags cs43=")]

    AIMS_METADATA_REPORT_FIELD_MAPPINGS = {
        'FacilityMaps': 'Facility Maps',
        'VendorMaps': 'Vendor Maps',
        'EquipmentTypeMaps': 'Equipment Type Maps',
        'CostCenterMaps': 'Cost Center Maps',
        'EmployeeList': 'Employee List',
        'WorkOrderPriorityList': 'Work Order Priority List',
        'WorkOrderResponse': 'Work Order'
    }

    AIMS_METADATA_API_FIELD_MAPPINGS = {
        'FacilityMaps': 'facility_map',
        'VendorMaps': 'vendor_map',
        'EquipmentTypeMaps': 'equipment_type_map',
        'CostCenterMaps': 'cost_center_map',
        'EmployeeList': 'employeeList',
        'WorkOrderPriorityList': 'priorityData'
    }


    HEARTBEAT_INTERVAL = 30
    DEFAULT_CONNECT_TIMEOUT = 60
    DEFAULT_REQUEST_TIMEOUT = 60

    ssl_params={}
    ssl_params['cert_reqs']=ssl.CERT_NONE
    ssl_params['check_hostname'] = False
    proxy_params = {'proxy_host': None, 'proxy_port': None, 'proxy_usr': None, 'proxy_pwd': None}

    class ReadWriteLock:
        """ A lock object that allows many simultaneous "read locks", but
        only one "write lock." """

        def __init__(self):
            self._read_ready = threading.Condition(threading.Lock(  ))
            self._readers = 0

        def acquire_read(self):
            """ Acquire a read lock. Blocks only if a thread has
            acquired the write lock. """
            self._read_ready.acquire(  )
            try:
                self._readers += 1
            finally:
                self._read_ready.release(  )

        def release_read(self):
            """ Release a read lock. """
            self._read_ready.acquire(  )
            try:
                self._readers -= 1
                if not self._readers:
                    self._read_ready.notifyAll(  )
            finally:
                self._read_ready.release(  )

        def acquire_write(self):
            """ Acquire a write lock. Blocks until there are no
            acquired read or write locks. """
            self._read_ready.acquire(  )
            while self._readers > 0:
                self._read_ready.wait(  )

        def release_write(self):
            """ Release a write lock. """
            self._read_ready.release(  )

    class WebSocketClient():
        """Base for web socket clients.
        """

        def __init__(self, cloud_url, cmd_handler, app_id,
                     connect_timeout=DEFAULT_CONNECT_TIMEOUT,
                     request_timeout=DEFAULT_REQUEST_TIMEOUT):
            self.cloud_url = cloud_url
            self.command_handler = cmd_handler
            self.app_id = app_id
            self.connect_timeout = connect_timeout
            self.request_timeout = request_timeout
            self.message_history = collections.OrderedDict()

        def start_loop(self):
            global ssl_params
            global proxy_params
            self.connect()
            try:
                self.ws.run_forever(sslopt=ssl_params,
                            http_proxy_host=proxy_params['proxy_host'],
                            http_proxy_port=proxy_params['proxy_port'],
                            http_proxy_auth=(proxy_params['proxy_usr'],proxy_params['proxy_pwd']))
            except KeyboardInterrupt:
                self.close()

        def connect(self):
            """Connect to the server.
            :param str url: server URL.
            """

            demisto.info("Connecting to PANW IoT Cloud websocket %s" % self.cloud_url)
            #headers = httputil.HTTPHeaders({'Content-Type': APPLICATION_JSON})

            self.rw = ReadWriteLock()
            self.rw.acquire_write()
            self.ws = wsc.WebSocketApp(url=self.cloud_url,
                                  on_open=self._on_connection_success,
                                  on_message=self._read_messages,
                                  on_error=self._on_connection_error,
                                  on_close=self._on_connection_close)

            self.rw.release_write()

        def send(self, data):
            """Send message to the server
            :param str data: message.
            """
            self.rw.acquire_read()
            if not self.ws:
                raise RuntimeError('PANW IoT Cloud Web socket connection is closed.')

            demisto.results("Sending Data = %s" % data)
            self.ws.send(json.dumps(data))
            self.rw.release_read()

        def close(self):
            """Close connection.
            """
            self.rw.acquire_write()
            if not self.ws:
                raise RuntimeError('PANW IoT Cloud Web socket connection is already closed.')

            self.ws.close()
            self.ws = None
            self.rw.release_write()

        def _read_messages(self, ws, msg):
            try:
                jobj = json.loads(msg)
                try:
                    replyto = jobj['replyTo']
                except KeyError:
                    replyto = None
                try:
                    msgid = jobj['id']
                    cmdt = jobj['cmdt']
                    cmd = jobj['cmd']
                    opType = cmd['opType']
                    demisto.info("Received PANW IoT cloud command type: %s, command %s" % (cmdt, cmd))

                    result = {'id': msgid, 'replyTo': replyto,
                              'IsSuccessful': True,
                              'Errors': []}
                    # Command Received, send success (based on design)
                    self.send(result)
                    if 'CustomFields' in cmd:
                        custom_fields = cmd['CustomFields']
                        if 'scannerId' in custom_fields:
                            cmd['CustomFields']['scannerid'] = custom_fields['scannerId']
                        if 'siteId' in custom_fields:
                            cmd['CustomFields']['siteid'] = custom_fields['siteId']
                        if 'profileId' in custom_fields:
                            cmd['CustomFields']['profileid'] = custom_fields['profileId']
                        if 'scanType' in custom_fields:
                            cmd['CustomFields']['scantype'] = custom_fields['scanType']
                    # TODO: check for custom fields per incident type and return errors if keyerrors found.

                    # TODO: get a list of all known opTypes and create new incident only for those
                    if opType != "connectionTest":
                        data = {
                            "type": cmd['type'],
                            "name": cmd['name'],
                            "severity": cmd['severity'],
                            "customFields": cmd['CustomFields'],
                            "details": cmd['details'],
                            "createInvestigation" : True
                        }
                        demisto.createIncidents([data])

                except KeyError:
                    demisto.error("PANW IoT Cloud Server returned json is missing expected fields: %s" % msg)

            except ValueError as ex:
                demisto.error("Failed to decode PANW IoT cloud server message %s as JSON %s" % (msg, ex))

            #thread.start_new_thread(self._on_message, (msg,))

        # def _on_message(self, msg):
        #     """This is called when new message is available from the server.
        #     :param str msg: server message.
        #     """
        #     demisto.info("Received message = %s", msg)

        def _on_connection_success(self, ws):
            """This is called on successful connection ot the server.
            """
            peeraddr = ws.sock.sock.getpeername()
            sockaddr = ws.sock.sock.getsockname()

            demisto.info("PANW IoT Cloud Websocket Connected! %s - %s" % (sockaddr, peeraddr))

        def _on_connection_close(self, ws):
            """This is called when server closed the connection.
            """
            demisto.error("PANW IoT Cloud Websocket Closed")
            time.sleep(5)
            self.start_loop()

        def _on_connection_error(self, ws, exception):
            """This is called in case if connection to the server could
            not established.
            """
            demisto.error("PANW IoT Cloud Websocket Error - %s" % exception)
            time.sleep(5)
            self.connect()

    def http_request(method, url, api_params={}, data=None, files=None, form_data=False):

        if form_data:
            if 'Content-Type' in DEFAULT_HEADERS:
                del DEFAULT_HEADERS['Content-Type']
        else:
            DEFAULT_HEADERS['Content-Type'] = 'application/json'

        params = {
            'customerid': CUSTOMER_ID,
        }

        for api in XSOAR_PARAM_APIS:
            if api in url:
                params.update({"xsoar_url": XSOAR_URL})

        if api_params is not None:
            params.update(api_params)
        # return_outputs(params)
        try:
            LOG(f'running {method} request with url={url}')
            response = requests.request(method, url, headers=DEFAULT_HEADERS, params=params, data=data, verify=False, files=files)
        except requests.exceptions.ConnectionError as e:
            err_msg = f'Failed to connect to PANW IoT Cloud. Verify assess_key, key_id and url are correct. {e}'
            raise requests.exceptions.ConnectionError(err_msg)

        if response.status_code not in {200, 201, 202, 204}:
            err_msg = f'Error in API call to PANW IoT Cloud  [{response.status_code}] - {response.text}'
            raise Exception(err_msg)

        if response.status_code in (201, 204):  # 201-Created OR 204-No Content
            return
        try:
            response = response.json()
        except ValueError:
            err_msg = f'Failed to parse ouput for API call {url}'
            raise ValueError(err_msg)

        return response

    def cleanup_sites(sites):
        # clean up empty space between site names
        site_list = sites.split(',')
        result_sites = ""
        for site in site_list:
            temp_site = site
            temp_site = temp_site.rstrip(' ')
            temp_site = temp_site.strip(' ')
            result_sites = result_sites + temp_site + ","
        return result_sites.rstrip(',')

    def get_asset_list(args):
        """
        Returns a list of assets for the specifed asset type.
        """
        asset_type = args.get('asset_type')
        increment_time = args.get('increment_time')
        page_length = args.get('page_length')
        offset = args.get('offset')
        site_names = args.get('site_names')
        tags = args.get('tags')

        url = BASE_URL + API_TYPE_MAP[asset_type]['list_url']
        one_call = False
        devices_with_macs = 0
        devices_without_macs = 0

        # if either page_length or offset is set, we dont need to accumulate results
        if page_length or offset:
            one_call = True

        asset_list = []

        if page_length is None:
            page_length = DEFAULT_PAGE_SIZE
        if offset is None:
            offset = '0'

        params = {
            'offset': str(offset),
            'pagelength': str(page_length),
        }

        if increment_time is not None:
            if asset_type == "device":
                poll_time = int(round(time.time() * 1000)) - int(increment_time) * 60 * 1000
                params['last_poll_time'] = str(poll_time)
            else:
                stime = datetime.now() - timedelta(minutes=int(increment_time))
                params['stime'] = str(stime)

        if asset_type == "device":
            params['detail'] = 'true'
            if tags is not None:
                params['tags'] = str(tags)
        elif asset_type == "vulnerability":
            params['groupby'] = 'device'

        # popluate site name for all asset types if available
        if site_names is not None:
            params['site_names'] = cleanup_sites(str(site_names))

        # gather all the results, break if the return size is less than requested page size
        while True:
            response = http_request('GET', url, params)
            size = 0
            if asset_type == "device":
                device_list = response.get('devices')
                for device in device_list:
                    if "deviceid" in device:
                        deviceid = device['deviceid']
                        if is_mac_address(deviceid):
                            devices_with_macs += 1
                        else:
                            devices_without_macs += 1
                asset_list.extend(device_list)
                size = response.get('total')
            else:
                asset_list.extend(response.get('items'))
                size = len(response.get('items'))
            if one_call or size < int(page_length):
                break
            else:
                new_offset = int(offset) + int(page_length)
                params['offset'] = str(new_offset)
                offset = new_offset

        op_data = {
            "Asset Type": asset_type
        }
        if asset_type == "device":
            if tags is not None:
                op_data["Devices pulled with tag(s)"] = str(tags)
            if site_names is not None:
                op_data['Devices pulled from Site(s)'] = str(site_names)
            op_data['Devices with mac address'] = devices_with_macs
            op_data['Devices without mac address'] = devices_without_macs
        op_data['Total assets pulled'] = len(asset_list)

        return CommandResults(
            readable_output=tableToMarkdown("Asset import summary:", op_data, removeNull=True),
            outputs_prefix=API_TYPE_MAP[asset_type]['context_path'],
            outputs=asset_list
        )


    def get_single_asset(args):
        """
        For input asset type and asset ID,
        returns the asset details.
        """

        asset_type = args.get('asset_type')
        asset_id = args.get('asset_id')

        if asset_type is None:
            raise TypeError("Invalid Asset Type")
        if asset_id is None:
            raise TypeError("Invalid Asset ID")

        params = {}
        if asset_type == 'device':
            params['detail'] = 'true'
            params['deviceid'] = str(asset_id)
        elif asset_type == 'alert':
            params['zb_ticketid'] = str(asset_id)
        elif asset_type == 'vulnerability':
            params['groupby'] = 'device'
            params['zb_ticketid'] = str(asset_id)
        else:
            raise TypeError("Invalid Asset Type")

        url = BASE_URL + API_TYPE_MAP[asset_type]['single_asset_url']

        data = http_request('GET', url, params)

        if asset_type in ['alert', 'vulnerability']:
            data = data.get('items')
        msg = f'Successfully pulled {asset_type} ({asset_id}) from PANW IoT Cloud'

        return CommandResults(
            readable_output=msg,
            outputs_prefix="PanwIot3rdParty.SingleAsset",
            outputs=data
        )

    def get_device_details(ip):
        """
        For input device ip, it
        returns the device details.
        """
        # return_outputs(ip)
        params = ip
        # return_outputs(params)
        url = BASE_URL + 'pub/v4.0/device/ip'
        data = http_request('GET', url, params)
        msg = f'Successfully pulled {ip} from PANW IoT Cloud'

        return CommandResults(
            readable_output=data,
            outputs_prefix="PanwIot3rdParty.DeviceDetails",
            outputs=data
        )

    def report_status_to_iot_cloud(args):
        """
        Reports status details back to PANW IoT Cloud.
        """
        status = args.get('status')
        message = args.get('message')
        integration_name = args.get('integration_name')
        playbook_name = args.get('playbook_name')
        asset_type = args.get('asset_type')
        custom_integration_name = args.get('custom_integration_name', None)

        curr_time = int(round(time.time() * 1000))

        data = {
            "playbook_name": playbook_name,
            "integration_name": integration_name,
            "message": message,
            "status": status,
            "type": asset_type,
            "timestamp": curr_time
        }
        if custom_integration_name != None:
            data["custom_integration_name"] = custom_integration_name
        api_data = json.dumps(data)

        url = BASE_URL + "pub/v4.0/xsoar/status"
        response = http_request('POST', url, None, api_data)
        data["iot_cloud_response"] = response

        return CommandResults(
            readable_output=tableToMarkdown("Reporting Status:", data, removeNull=True)
        )


    def convert_vulnerability_list_to_cef(vulnerability_list=None):
        """
        Converts a PANW IoT vulnerability list to CEF formatted syslogs.
        """
        data = []
        risk_level_map = {'Critical': '10', 'High': '6', 'Medium': '3', 'Low': '1'}

        for vulnerability in vulnerability_list:
            line = "INFO:siem-syslog:CEF:0|PaloAltoNetworks|PANWIOT|1.0|vulnerability|"
            if "vulnerability_name" in vulnerability:
                line += vulnerability['vulnerability_name'] + "|"
            if "risk_level" in vulnerability:
                if vulnerability["risk_level"] in risk_level_map:
                    line += risk_level_map[vulnerability["risk_level"]] + "|"
                else:
                    line += "1|"  # default severity

            for t in VULNERABILITY_FIELDS_MAP:
                input_field = t[0]
                output_field = t[1]
                # print input_field, output_field
                if input_field in vulnerability:
                    val = vulnerability[input_field]
                else:
                    val = ""
                if output_field and val:
                    line += str(output_field) + str(val) + " "
            data.append(line)

        return data


    def convert_alert_list_to_cef(alert_list=None):
        """
        Converts a PANW IoT alert list to CEF formatted syslogs.
        """
        data = []
        for alert in alert_list:
            if alert is not None and "msg" in alert and "status" in alert["msg"] and alert["msg"]["status"] == "publish":
                msg = alert['msg']
                line = "CEF:0|PaloAltoNetworks|PANWIOT|1.0|PaloAltoNetworks Alert:policy_alert|"

                if "name" in alert:
                    line += alert["name"] + "|"
                if "severityNumber" in alert:
                    line += str(alert["severityNumber"]) + "|"
                if "deviceid" in alert:
                    line += f'dvcmac={alert["deviceid"]} '
                if "fromip" in msg:
                    line += f'src={msg["fromip"]} '
                if "toip" in msg:
                    line += f'dst={msg["toip"]} '
                if "hostname" in msg:
                    line += f'shost={msg["hostname"]} '
                if "toURL" in msg:
                    line += f'dhost={msg["toURL"]} '
                if "id" in msg:
                    line += f'fileId={msg["id"]} '
                    line += "fileType=alert "

                if "date" in alert:
                    line += f'rt={str(alert["date"])} '
                if "generationTimestamp" in msg:
                    line += f'deviceCustomDate1={str(msg["generationTimestamp"])} '

                description = None
                values = []
                if "description" in alert:
                    description = alert["description"]
                if "values" in msg:
                    values = msg["values"]

                line += f'cs1Label=Description cs1={description} '
                line += f'cs2Label=Values cs2={str(values)} '
                data.append(line)

        return data


    def convert_device_list_to_cef(device_list=None):
        """
        Converts a PANW IoT device attribute list to CEF formatted syslogs.
        """
        data = []
        for device_map in device_list:
            if 'mac_address' in device_map:
                line = "INFO:siem-syslog:CEF:0|PaloAltoNetworks|PANWIOT|1.0|asset|Asset Identification|1|"
                for t in DEVICE_FIELDS_MAP:
                    input_field = t[0]
                    output_field = t[1]
                    # print input_field, output_field
                    if input_field in device_map:
                        val = device_map[input_field]
                    else:
                        val = ""
                    if output_field and val:
                        line += str(output_field) + str(val) + " "
                data.append(line)
        return data


    def convert_device_list_to_ise_attributes(device_list=None):
        """
        Converts a PANW IoT device attribute list to Cisco ISE custom attributes.
        """
        data = []
        for device_map in device_list:
            if 'deviceid' in device_map:
                if device_map['deviceid'] is None or device_map['deviceid'] == "":
                    continue
                attribute_list = {}
                attribute_list['mac'] = device_map['deviceid']
                if not is_mac_address(attribute_list['mac']):
                    continue
                zb_attributes = {}
                for field in device_map:
                    if device_map[field] is None or device_map[field] == "":
                        continue
                    if field in CISCO_ISE_FIELD_MAP:
                        if field in INT_FIELDS:
                            try:
                                int_val = int(device_map[field])
                            except Exception:
                                continue
                            zb_attributes[CISCO_ISE_FIELD_MAP[field][0]] = int_val
                            zb_attributes[CISCO_ISE_FIELD_MAP[field][1]] = int_val
                        else:
                            zb_attributes[CISCO_ISE_FIELD_MAP[field][0]] = device_map[field]
                            zb_attributes[CISCO_ISE_FIELD_MAP[field][1]] = device_map[field]
                attribute_list['zb_attributes'] = zb_attributes
                data.append(attribute_list)

        return data


    def convert_device_list_to_aruba_cp_attributes(device_list=None):
        """
        Converts a PANW IoT device attribute list to Aruba ClearPass custom attributes.
        """
        data = []
        for device_map in device_list:
            if 'deviceid' in device_map:
                if device_map['deviceid'] is None or device_map['deviceid'] == "":
                    continue
                attribute_list = {}
                attribute_list['mac'] = device_map['deviceid']
                if not is_mac_address(attribute_list['mac']):
                    continue
                zb_attributes = {}
                for field in device_map:
                    if device_map[field] is None or device_map[field] == "":
                        continue
                    if field in ARUBA_CP_FIELD_MAP:
                        if field in INT_FIELDS:
                            try:
                                int_val = int(device_map[field])
                            except Exception:
                                continue
                            for each_field in ARUBA_CP_FIELD_MAP[field]:
                                zb_attributes[each_field] = int_val
                        else:
                            for each_field in ARUBA_CP_FIELD_MAP[field]:
                                zb_attributes[each_field] = device_map[field]

                attribute_list['zb_attributes'] = zb_attributes
                data.append(attribute_list)
        return data


    def convert_alert_to_servicenow(args):
        """
        Converts a PANW IoT alert to ServiceNow table formatted.
        """
        incident = args.get('incident')
        asset_list = args.get('asset_list')
        alert = asset_list[0]
        comments_and_work_notes = str(incident['comments_and_work_notes'])
        url = str(incident['url'])
        urgency = str(incident['urgency'])
        incident.setdefault('user_email', 'cannot find any email')
        # user_email = incident['user_email']
        zb_ticketid = incident['correlation_id']
        incident_url = str(incident['incidentURL'])
        user_comments = str(incident['user_comments'])

        alert.setdefault('msg', {}).setdefault('impact', 'Sorry, no impact available to display so far!')
        alert.setdefault('msg', {}).setdefault('recommendation', {}).setdefault(
            'content', ['Sorry, no recommendation available to display so far!'])
        alert.setdefault('location', 'Sorry, location is not provided')
        alert.setdefault('category', 'Sorry, category is not provided')
        alert.setdefault('profile', 'Sorry, profile is not provided')
        alert.setdefault('description', 'Sorry, description is not provided')
        alert.setdefault('name', '')

        impact = alert['msg']['impact']
        recommendations = alert['msg']['recommendation']['content']
        recommendation_text = ''
        alert_description = str(alert['description'])
        category = str(alert['category'])
        profile = str(alert['profile'])
        location = str(alert['location'])
        short_description = str(alert['name'])

        for rec in recommendations:
            recommendation_text += '*' + rec + '\n'

        new_line = '\n'
        description = (
            f'Summary{new_line}{alert_description}{new_line}{new_line}Category: {category}{new_line}Profile: {profile}'
            f'{new_line}{new_line}Impact{new_line}{impact}{new_line}{new_line}Recommendations{new_line}'
            f'{recommendation_text}{new_line}Device URL{new_line}{url}'
        )

        data = (
            f'urgency={urgency};location={location};short_description={short_description};'
            f'comments_and_work_notes={comments_and_work_notes};description={description};'
            f'correlation_id={zb_ticketid};impact=3;company=Palo Alto Networks;opened_by=svc_panw_iot;'
            f'u_comments={user_comments};u_security_incident={incident_url};'
        )

        return data


    def convert_vulnerability_to_servicenow(args):
        incident = args.get('incident')
        comments_and_work_notes = str(incident['comments_and_work_notes'])
        url = str(incident['url'])
        urgency = str(incident['urgency'])
        incident.setdefault('user_email', 'cannot find any email')
        # user_email = incident['user_email']
        zb_ticketid = incident['correlation_id']
        incident_url = str(incident['incidentURL'])
        user_comments = str(incident['user_comments'])

        recommendations = str(incident['recommendations'])
        impact = str(incident['impact'])
        vuln_description = str(incident['description'])

        asset_list = args.get('asset_list')
        vuln = asset_list[0]
        vuln.setdefault('category', 'Sorry, category is not provided')
        vuln.setdefault('profile', 'Sorry, profile is not provided')
        vuln.setdefault('location', 'Sorry, location is not provided')
        category = str(vuln['category'])
        profile = str(vuln['profile'])
        location = str(vuln['location'])
        short_description = str(vuln['name'])

        new_line = '\n'
        description = (
            f'Summary{new_line}{vuln_description}{new_line}{new_line}Category: {category}{new_line}Profile: {profile}'
            f'{new_line}{new_line}Impact{new_line}{impact}{new_line}{new_line}Recommendations{new_line}'
            f'{recommendations}{new_line}Device URL{new_line}{url}'
        )

        data = (
            f'urgency={urgency};location={location};short_description={short_description};'
            f'comments_and_work_notes={comments_and_work_notes};description={description};'
            f'correlation_id={zb_ticketid};impact=3;company=Palo Alto Networks;opened_by=svc_panw_iot;'
            f'u_comments={user_comments};u_security_incident={incident_url};'
        )
        return data


    def convert_device_to_servicenow_format(device, sn_device_fields_names, category_map):
        device_fields_mapping = {
            "hostname": "name",
            "ip_address": "ip_address",
            "deviceid": "mac_address"
        }
        u_category = str(sn_device_fields_names.get("u_category"))
        u_iot_tag = str(sn_device_fields_names.get("u_iot_tag"))
        u_iot_vendor = str(sn_device_fields_names.get("u_iot_vendor"))
        u_iot_model = str(sn_device_fields_names.get("u_iot_model"))
        u_iot_os = str(sn_device_fields_names.get("u_iot_os"))
        u_iot_ssid = str(sn_device_fields_names.get("u_iot_ssid"))
        u_iot_site = str(sn_device_fields_names.get("u_iot_site"))
        u_iot_vlan = str(sn_device_fields_names.get("u_iot_vlan"))
        u_iot_wired_wireless = str(sn_device_fields_names.get("u_iot_wired_wireless"))
        u_os_support = str(sn_device_fields_names.get("u_os_support"))
        u_profile = str(sn_device_fields_names.get("u_profile"))
        device_custome_fields_mapping = {
            "category": u_category,
            "profile": u_profile,
            "display_tags": u_iot_tag,
            "vendor": u_iot_vendor,
            "model": u_iot_model,
            "os_group": u_iot_os,
            "SSID": u_iot_ssid,
            "site_name": u_iot_site,
            "vlan": u_iot_vlan,
            "wire_or_wireless": u_iot_wired_wireless,
            "os_support": u_os_support
        }
        instance = {}
        fields = ''
        custom_fields = ''

        for field in device_fields_mapping:
            sn_name = device_fields_mapping[field]
            value = ''
            if field in device:
                if device[field] is not None:
                    value = str(device[field])
            else:
                value = ' '
            fields += (sn_name + "=" + value + ";")
        instance["fields"] = fields

        for field in device_custome_fields_mapping:
            sn_name = device_custome_fields_mapping[field]
            value = ''
            if field in device:
                if device[field] is not None:
                    if category_map and (field == "category"):
                        iot_category = device[field]
                        value = str(category_map.setdefault(iot_category, iot_category))
                    else:
                        value = str(device[field])
            else:
                value = ' '
            custom_fields += (sn_name + "=" + value + ";")

        instance["custom_fields"] = custom_fields
        return instance


    def get_servicenow_upsert_devices(args):
        sn_id_deviceids = {}
        # servicenow_map should be list of ServiceNow table ID and deviceid mapping
        if "servicenow_map" in args:
            sn_id_deviceids = args.get("servicenow_map")
            # there will be a case that SN will return No Result Found string result.
            # We need to handle it here.
            if isinstance(sn_id_deviceids, str):
                sn_id_deviceids = {}
        device_list = args.get("asset_list")
        ids_map = {}
        if sn_id_deviceids:
            for i in range(len(sn_id_deviceids)):
                ids = sn_id_deviceids[i]
                sn_id = ''
                if "ID" in ids:
                    sn_id = ids["ID"]
                else:
                    sn_id = ids['sys_id']
                deviceid = ids["mac_address"]
                ids_map[deviceid] = sn_id

        update_list = []
        insert_list = []
        sn_device_fields_names = {}
        config = args.get("customized_servicenow_config")
        category_map = args.get("iot_servicenow_category_map")
        if isinstance(config, str):
            sn_device_fields_names = json.loads(config)
        else:
            sn_device_fields_names = config

        if category_map and isinstance(category_map, str):
            category_map = json.loads(category_map)
        for i in range(len(device_list)):
            device = device_list[i]
            deviceid = device["deviceid"]
            instance = convert_device_to_servicenow_format(device, sn_device_fields_names, category_map)
            if (not ids_map) or (deviceid not in ids_map):
                insert_list.append(instance)
            else:
                sn_id = ids_map[deviceid]
                instance["sys_id"] = sn_id
                update_list.append(instance)

        result = {
            "insert": insert_list,
            "update": update_list,
            "update_count": len(update_list),
            "insert_count": len(insert_list)
        }
        return result


    def convert_asset_to_external_format(args):
        """
        For a given asset (alert, device, vuln) converts it
        to specified 3rd party format.
        """

        prefix_map = {
            "device": {
                "SIEM": "PanwIot3rdParty.DeviceCEFSyslogs",
                "CiscoISECustomAttributes": "PanwIot3rdParty.CiscoISEAttributes",
                "ArubaClearPassCustomAttributes": "PanwIot3rdParty.ArubaClearPassAttributes",
                "ServiceNow": "PanwIot3rdParty.DeviceServiceNow"
            },
            "alert": {
                "SIEM": "PanwIot3rdParty.AlertCEFSyslogs",
                "ServiceNow": "PanwIot3rdParty.AlertServiceNow"
            },
            "vulnerability": {
                "SIEM": "PanwIot3rdParty.VulnerabilityCEFSyslogs",
                "ServiceNow": "PanwIot3rdParty.VulnerabilityServiceNow"
            }
        }

        asset_type = args.get('asset_type')
        output_format = args.get('output_format')
        asset_list = args.get('asset_list')
        data = []
        readable_res = ''

        if output_format == "ServiceNow":
            if asset_list:
                if asset_type == "device":
                    data = get_servicenow_upsert_devices(args)
                    update_count = data.get('update_count')
                    insert_count = data.get('insert_count')
                    readable_res = f'Converted Device list to {update_count} updated devices and {insert_count} inserted {output_format} devices'
                elif asset_type == 'alert':
                    data = convert_alert_to_servicenow(args)
                    correlation_id = args.get('incident')['correlation_id']
                    readable_res = f'Converted Alert {correlation_id} to {output_format}'
                elif asset_type == 'vulnerability':
                    data = convert_vulnerability_to_servicenow(args)
                    correlation_id = args.get('incident')['correlation_id']
                    readable_res = f'Converted Vulnerability {correlation_id} to {output_format}'
            else:
                err_msg = f'Output format ServiceNow not supported for {asset_type}'
                raise TypeError(err_msg)

        elif output_format == "SIEM":
            if asset_list:
                if asset_type == "device":
                    data = convert_device_list_to_cef(asset_list)
                elif asset_type == 'alert':
                    data = convert_alert_list_to_cef(asset_list)
                elif asset_type == "vulnerability":
                    data = convert_vulnerability_list_to_cef(asset_list)
                else:
                    err_msg = f'Output format SIEM not supported for {asset_type}'
                    raise TypeError(err_msg)
            readable_res = f'Converted {len(data)} {asset_type} to {output_format}'

        elif output_format == 'CiscoISECustomAttributes':
            if asset_list:
                if asset_type == 'device':
                    data = convert_device_list_to_ise_attributes(asset_list)
                else:
                    err_msg = f'Output format CiscoISECustomAttributes not supported for {asset_type}'
                    raise TypeError(err_msg)
            readable_res = f'Converted {len(data)} {asset_type} to {output_format}'

        elif output_format == 'ArubaClearPassCustomAttributes':
            if asset_list:
                if asset_type == 'device':
                    data = convert_device_list_to_aruba_cp_attributes(asset_list)
                else:
                    err_msg = f'Output format ArubaClearPassCustomAttributes not supported for {asset_type}'
                    raise TypeError(err_msg)
            readable_res = f'Converted {len(data)} {asset_type} to {output_format}'

        prefix = prefix_map[asset_type][output_format]

        return CommandResults(
            readable_output=readable_res,
            outputs_prefix=prefix,
            outputs=data
        )


    def get_active_list(args):
        """
        Returns a list mac address of active devices
        """
        asset_type = 'device'
        page_length = int(args.get('pageLength'))
        offset = int(args.get('offset'))
        active_range = int(args.get('active_range'))
        siteids = args.get('siteids')
        mac_only = args.get('mac_only')
        single_call = args.get('single_call')

        if page_length == None:
            page_length = DEFAULT_PAGE_SIZE
        if offset == None:
            offset = 0
        if active_range == None:
            active_range = 15
        if mac_only == None:
            mac_only = 'true'

        stime = datetime.now() - timedelta(minutes=int(active_range))

        params = {
            'active_only': 'true',
            # 'mac_only': 'true',
            'stime': str(stime.strftime("%Y-%m-%dT%H:%MZ")),
            'offset': str(offset),
            'pagelength': str(page_length)
        }
        if mac_only == 'true':
            params['mac_only'] = 'true'

        if siteids != None:
            params['site_names'] = str(siteids)

        asset_list = []

        url = BASE_URL + API_TYPE_MAP[asset_type]['list_url']

        # gather all the results, break if the return size is less than requested page size
        while True:
            response = http_request('GET', url, params)
            asset_list.extend(response.get('devices'))
            size = response.get('total')
            if single_call == "yes":
                break
            if size < page_length:
                break
            else:
                offset += page_length
                params['offset'] = str(offset)

        op_data = {
            "asset type": asset_type,
            "assets pulled": len(asset_list)
        }

        res = []
        rt = {
            "sites": str(siteids),
            "active_list": asset_list
        }
        res.append(rt)

        return CommandResults(
            readable_output=tableToMarkdown("Asset import summary:", op_data, removeNull=True),
            outputs_prefix=API_TYPE_MAP[asset_type]['context_path'],
            outputs=res
        )


    def report_aims_devices(args):
        """
        Returns a number of devices sent to IoT Cloud
        """
        device_data = args.get('DeviceData')
        # total = device_data.get('total', 0)
        url = BASE_URL + "pub/v4.0/xsoar/device/aims"
        demisto.info("Reporting devices_dict to PANW IoT cloud. Source - aims. Data - %s" % (str(device_data)))
        response = http_request('POST', url, None, device_data)
        gc.collect()
        demisto.info(f'Response from report-device for aims API {response}')
        return CommandResults(
            readable_output=f'AIMS devices data updated',
        )

    def report_subnets(args):
        """
        Returns a number of subnets sent to IoT Cloud
        """
        integration_name = args.get('integration_name', '')

        subnetData = args.get('subnet_data')
        data_overwrite = args.get('data_overwrite')
        site_overwrite = args.get('site_overwrite')
        data_overwrite_boolean = False
        if data_overwrite is not None and data_overwrite.lower() == 'true':
            data_overwrite_boolean=True
        site_overwrite_boolean = False
        if site_overwrite is not None and site_overwrite.lower() == 'true':
            site_overwrite_boolean=True

        pagelength = args.get('page_length')
        if pagelength == None:
            page_length = DEFAULT_PAGE_SIZE
        else:
            page_length = int(pagelength)

        params = None
        if 'ipam_infoblox' in integration_name:
            params = {
                'updateSource': 'ipam_infoblox'
            }

        elif 'ipam_bluecat' in integration_name:
            params = {
                'updateSource': 'ipam_bluecat'
            }
        elif 'ipam_generic' in integration_name:
            params = {
                'updateSource': 'ipam_generic'
            }
        elif 'ipam_solarwinds' in integration_name:
            params = {
                'updateSource': 'ipam_solarwinds'
            }

        url = BASE_URL + "pub/v4.0/network/subnetBulkUpdate"
        data = {}
        total = len(subnetData)
        updated = 0
        while total > 0:
            if total > page_length:
                offset = total - page_length
            else:
                offset = 0
            data['subnetlist'] = subnetData[offset:total]
            data['siteOverwrite'] = site_overwrite_boolean
            data['dataOverwrite'] = data_overwrite_boolean
            # demisto.info("total: "+ str(total) + " subnetData: "+ str(subnetData))
            source=''
            if params is not None and 'updateSource' in params.keys():
                source = params['updateSource']
            else:
                source='unknown'
            demisto.info("Reporting subnets to PANW IoT cloud. Source - %s. Data - %s" % (source, json.dumps(data)))
            response = http_request('PUT', url, params, json.dumps(data))
            time.sleep(0.5)
            if 'numOfUpdatedSubnets' in response:
                updated += response.get('numOfUpdatedSubnets')
            total = offset

        if integration_name == 'ipam_solarwinds':
                op={}
                op['numOfUpdatedSubnets']=updated
                return CommandResults(
                    readable_output=f'{updated} subnet data updated',
                    outputs_prefix="PanwIot3rdParty.ReportSubnets",
                    outputs=op
                )

        return CommandResults(
            readable_output=f'{updated} subnets data updated',
            outputs_prefix="PanwIot3rdParty.ReportSubnets",
            outputs=f'{updated} subnets data updated'
        )

    def report_devices(args):
        """
        Returns a number of devices sent to IoT Cloud
        """
        integration_name = args.get('IntegrationName', '')
        integration_instance_name = args.get('IntegrationInstanceName', '')
        if 'aims' in integration_name:
            response = report_aims_devices(args)
            return response
        else:
            DeviceData = args.get('DeviceData')

            pagelength = args.get('pageLength')
            if pagelength == None:
                page_length = DEFAULT_PAGE_SIZE
            else:
                page_length = int(pagelength)

            params = None
            if 'cisco_wlc' in integration_name:
                params = {
                    'updateSource': 'cisco_wlc'
                }
            elif 'aruba_wlc' in integration_name:
                params = {
                    'updateSource': 'aruba_wlc'
                }
            elif 'aruba_central' in integration_name:
                params = {
                    'updateSource': 'aruba_central'
                }
            elif 'rockwell' in integration_name:
                params = {
                    'updateSource': 'rockwell'
                }
            elif 'microsoft_defender_xdr' in integration_name:
                params = {
                    'updateSource': 'microsoft_defender_xdr'
                }
            elif 'snmp' in integration_name:
                params = {
                    'updateSource': 'snmp'
                }
            elif 'nuvolo' in integration_name:
                params = {
                    'updateSource': 'nuvolo'
                }
            elif 'cortex_xdr' in integration_name:
                params = {
                    'updateSource': 'cortex_xdr'
                }
            elif 'sccm' in integration_name:
                params = {
                    'updateSource': 'sccm'
                }
            elif 'crowdstrike_falcon' in integration_name:
                params = {
                    'updateSource': 'crowdstrike_falcon'
                }
            elif 'splunk' in integration_name:
                params = {
                    'updateSource': 'splunk'
                }
            elif 'cisco_meraki' in integration_name:
                params = {
                    'updateSource': 'cisco_meraki'
                }
            elif 'device_polling' in integration_name:
                params = {
                    'updateSource': 'device_polling'
                }
            elif 'solarwinds_udt' in integration_name:
                params = {
                'updateSource': 'solarwinds_udt'
                }
            elif 'cisco_ise' in integration_name:
                params = {
                    'updateSource': 'cisco_ise'
                }
            elif 'ms_entra_id' in integration_name:
                params = {
                    'updateSource': 'ms_entra_id'
                }
            elif 'aruba_airwave' in integration_name:
                params = {
                    'updateSource': 'aruba_airwave'
                }
            if integration_instance_name !='':
                params['updateIntegrationInstance']=integration_instance_name
            url = BASE_URL + "pub/v4.0/device/bulkUpdate"
            data = {}
            total = len(DeviceData)
            updated = 0
            upserted = 0
            while total > 0:
                if total > page_length:
                    offset = total - page_length
                else:
                    offset = 0
                data['devicelist'] = DeviceData[offset:total]
                source=''
                if params is not None and 'updateSource' in params.keys():
                    source = params['updateSource']
                elif 'config_source' in DeviceData[0]:
                    source = DeviceData[0]['config_source']
                else:
                    source='unknown'
                demisto.info("Reporting devices to PANW IoT cloud. Source - %s. Data - %s" % (source, data))
                response = http_request('PUT', url, params, json.dumps(data))
                time.sleep(0.5)
                if 'updatedDeviceNum' in response:
                    updated += response.get('updatedDeviceNum')
                if 'upsertedDeviceNum' in response:
                    upserted += response.get('upsertedDeviceNum')
                total = offset
            if integration_name == 'cisco_meraki' or integration_name == 'microsoft_defender_xdr' or \
                integration_name == 'solarwinds_udt' or integration_name == 'ms_entra_id' or \
                integration_name == 'aruba_airwave':
                op={}
                op['upsertedDeviceNum']=upserted
                op['updatedDeviceNum']=updated
                return CommandResults(readable_output=f'{updated} device data updated and {upserted} device data upserted',outputs_prefix="PanwIot3rdParty.ReportDevices",outputs=op)
            return CommandResults(
                readable_output=f'{updated} device data updated',
                outputs_prefix="PanwIot3rdParty.ReportDevices",
                outputs=f'{updated} device data updated'
            )

    def report_vulnerabilities(args):
        """
        Returns a number of vulnerabilities sent to IoT Cloud
        In the VulnerabilityData, there will be an endpoint that provides 100 CVE-findings per API.
        """
        integration_name = args.get('IntegrationName', '')

        VulnerabilityData = args.get('VulnerabilityData')

        batchId = args.get('batchId')

        params = None
        if 'tanium' in integration_name:
            params = {
                'source': 'tanium'
            }
        if 'ms_defender_xdr' in integration_name:
            params = {
                'source': 'ms_defender_xdr'
            }
        url = BASE_URL + "pub/v4.0/thirdPartyScan"
        updated = 0

        source=''
        data = {}
        if params is not None and 'source' in params.keys():
            source = params['source']
        else:
            source='unknown'

        data.update({
            'batch_id': batchId,
            'device_list': VulnerabilityData
        })

        demisto.info("Reporting vulnerabilities to PANW IoT cloud. Source - %s. Data - %s" % (source, data))
        response = http_request('PUT', url, params, json.dumps(data))
        time.sleep(0.5)
        updated = response.get('updatedDeviceNum')

        return CommandResults(
            readable_output=f'{updated} vulnerability data updated',
            outputs_prefix="PanwIot3rdParty.ReportDevices",
            outputs=f'{updated} vulnerability data updated'
        )


    def extract_mac_address(args):
        """
        Returns mac address list of PANW IoT device data
        """
        dc = args.get('Devices')

        res = []
        total = 0
        for ds in dc:
            macs = []
            dd = ds['active_list']

            for dv in dd:
                if "deviceid" in dv:
                    mac = dv['deviceid']
                    if 17 == len(mac):
                        macs.append(mac)

            rd = {
                "sites": ds['sites'],
                "mac_list": macs
            }
            res.append(rd)
            total += len(macs)

        return CommandResults(
            readable_output=f'{total} MAC addresses extracted',
            outputs_prefix="PanwIot3rdParty.DeviceMacAddress",
            outputs=res
        )


    def extract_prime_device_data(args):
        """
        Returns PANW IoT device data
        """
        client_data = args.get('clientData')
        res = []
        for entity in client_data:
            try:
                data = {'deviceid': entity['macAddress'].lower(),
                        'config_source': 'prime'
                        }
                if 'connectionType' not in entity or 'errorCode' in entity['connectionType']:
                    continue

                data = {'deviceid': entity['macAddress'].lower(),
                        'config_source': 'prime'
                        }
                if 'WIRED' == entity['connectionType']:
                    data['WireWireless'] = 'wired'
                    try:
                        data['switch_name'] = entity['deviceName']
                        data['switchName'] = entity['deviceName']
                    except:
                        data['switch_name'] = ''
                        data['switchName'] = ''
                    try:
                        data['switch_ip'] = entity['deviceIpAddress']['address']
                        data['switchIP'] = entity['deviceIpAddress']['address']
                    except:
                        data['switch_ip'] = ''
                        data['switchIP'] = ''
                    try:
                        data['switch_if_name'] = entity['clientInterface']
                        data['switchPort'] = entity['clientInterface']
                    except KeyError:
                        try:
                            data['switch_if_name'] = entity['ifDescr']
                            data['switchPort'] = entity['ifDescr']
                        except:
                            data['switch_if_name'] = ''
                            data['switchPort'] = ''
                    except:
                        data['switch_if_name'] = ''
                        data['switchPort'] = ''
                    try:
                        data['if_descr'] = entity['ifDescr']
                    except:
                        data['if_descr'] = ''
                    try:
                        vLan = entity['vlan']
                        data['vlan'] = int(vLan)
                    except:
                        pass
                    try:
                        data['vlan_name'] = entity['vlanName']
                        data['vlan_source'] = 'cisco prime'
                    except:
                        data['vlan_name'] = ''
                        data['vlan_source'] = 'cisco prime'

                else:
                    data['WireWireless'] = 'wireless'
                    try:
                        data['ap_ip'] = entity['apIpAddress']['address']
                    except:
                        data['ap_ip'] = ''
                    try:
                        data['ap_mac'] = entity['apMacAddress']
                    except:
                        data['ap_mac'] = ''
                    try:
                        data['ap_name'] = entity['apName']
                    except:
                        data['ap_name'] = ''
                    try:
                        data['SSID'] = entity['ssid']
                    except:
                        data['SSID'] = ''
                    try:
                        data['ap_slot_id'] = entity['apSlotId']
                    except:
                        data['ap_slot_id'] = ''
                try:
                    data['vlan'] = int(entity['vlan'])
                except:
                    data['vlan'] = ''
                try:
                    data['location'] = entity['location']
                except:
                    data['location'] = ''
                try:
                    data['speed'] = entity['speed']
                except:
                    data['speed'] = ''
                try:
                    data['protocol'] = entity['protocol']
                except:
                    data['protocol'] = ''
                try:
                    data['policy_type'] = entity['policyType']
                except:
                    data['policy_type'] = ''
                res.append(data)
            except:
                pass
        return CommandResults(
            readable_output=f'{len(res)} of {len(client_data)} client detail extracted',
            outputs_prefix="PanwIot3rdParty.DeviceData",
            outputs=res
        )

    def extract_cisco_wlc_device_data(args):
        """
        Returns PANW IoT device data
        """
        client_data = args.get('clientData')
        if not isinstance(client_data, dict):
            client_data = json.loads( client_data )
        res = []
        ap_list = client_data.get('_source', {}).get('evtContent', {}).get('ap_list', [])

        for access_point in ap_list:
            clients_list = access_point.get('client_list', [])
            for client in clients_list:
                try:
                    data = {}

                    data['apName'] = access_point.get('apName', '')
                    data['apIPAddress'] = access_point.get('apIPAddress', '')
                    data['apMacAddress'] = access_point.get('ethernetMAC', '')
                    data['apModel'] = access_point.get('apModel', '')
                    data['location'] = access_point.get('location', '')

                    if 'bluetoothType' in client:
                        data["isBluetooth"] = True
                        data["macAddress"] = client.get('macAddress', '').lower()
                        data["bluetoothType"] = client.get('bluetoothType', '')
                        data["bluetoothDeviceType"] = client.get('bluetoothDeviceType', '')
                        data["frequency"] = client.get('frequency', '')
                        data["channel"] = client.get('channel', '')
                        data["connectionState"] = client.get('connectionState', '')
                        data["connectedDuration"] = client.get('connectedDuration', '')
                        data["rssi"] = client.get('rssi', '')
                    else:
                        data['macAddress'] = client.get('macAddress', '').lower()
                        data['ipAddress'] = client.get('ipAddress', '')
                        data['radio'] = client.get('radio', '')
                        data['connectionState'] = client.get('clientState', '')
                        data['wlanId'] = client.get('wlanId', '')
                        data['SSID'] = client.get('SSID', '')
                        data['connectedDuration'] = client.get('connectedDuration', '')
                        data['authentication'] = client.get('authenticated', '')
                        data['status'] = client.get('status', '')
                        data['authMethod'] = client.get('authMethod', '')
                        data['encryptionCipher'] = client.get('encryptionCipher', '')
                        data['rssi'] = client.get('rssi', '')
                        data['snr'] = client.get('snr', '')
                        data['apRadioSlotId'] = client.get('slot', '')
                        data['country'] = access_point.get('country', '')

                    # apppending device devices array
                    res.append(data)
                except:
                    pass

        return CommandResults(
            readable_output=f'{len(res)} of {len(client_data)} client detail extracted',
            outputs_prefix="PanwIot3rdParty.DeviceData",
            outputs=res
        )


    def extract_aruba_wlc_device_data(args):
        """
        Returns PANW IoT device data
        """
        client_data = args.get('clientData')
        client_data = json.loads(client_data)
        res = []
        ap_list = client_data.get('_source', {}).get('evtContent', {}).get('ap_list', [])
        total_clients = client_data.get('_source', {}).get('evtContent', {}).get('totalAPs', '')

        for access_point in ap_list:
            clients_list = access_point.get('client_list', [])
            for client in clients_list:
                try:
                    data = {}

                    # Device data (distinct for all devices)
                    data['macAddress'] = client.get('macAddress', '').lower()
                    data['ipAddress'] = client.get('ipAddress', '')
                    data['radio'] = client.get('radio', '')
                    data['connectionState'] = client.get('status', '')
                    data['SSID'] = client.get('SSID', '')
                    data['connectedDuration'] = client.get('connectedDuration', '')
                    data['authMethod'] = client.get('authMethod', '')
                    data['encryptionCipher'] = access_point.get('monitor_ap_list', {}).get('encryptionCipher', '')
                    data['rssi'] = client.get('rssi', '')
                    data['snr'] = client.get('snr', '')
                    data['authenticationStatus'] = client.get('authenticationStatus', '')
                    data['BSSID'] = client.get('BSSID', '')
                    data['deviceType'] = client.get('deviceType', '')
                    data['wlanId'] = client.get('wlanId', '')
                    data['apRadioSlotId'] = client.get('slot_id', '')

                    # BT devices fields
                    data['bluetoothType'] = client.get('bluetoothType', '')
                    data['bluetoothDeviceType'] = client.get('bluetoothDeviceType', '')
                    data['connectionState'] = client.get('connectionState', '')
                    data['connectedDuration'] = client.get('connectedDuration', '')
                    data['hwType'] = client.get('hwType', '')
                    data['fwVersion'] = client.get('fwVersion', '')
                    data['bluetoothAddressType'] = client.get('bluetoothAddressType', '')
                    data['bluetoothCompanyId'] = client.get('bluetoothCompanyId', '')

                    # AP data (common for all devices)
                    data['apName'] = access_point.get('apName', '')
                    data['apIPAddress'] = access_point.get('apIPAddress', '')
                    data['apMacAddress'] = access_point.get('apMacAddress', '')
                    data['apModel'] = access_point.get('apModel', '')
                    data['location'] = access_point.get('location', '')
                    data['apEncryptionCipher'] = access_point.get('monitor_ap_list', {}).get('encryptionCipher', '')
                    data['country'] = access_point.get('country', '')

                    # Removing keys with no values
                    data = {k: v for k, v in data.items() if v}

                    # Adding a flag to device type
                    data['isBluetooth'] = client.get('isBluetooth', '')

                    # apppending device devices array
                    res.append(data)
                except:
                    pass

        return CommandResults(
            readable_output=f'{len(res)} of {len(client_data)} client detail extracted',
            outputs_prefix="PanwIot3rdParty.DeviceData",
            outputs=res
        )


    def get_external_tenantid() -> str:
        """
        Return the customer id.
        """
        readable_res = f'Customer id is {CUSTOMER_ID}'
        return CommandResults(
            readable_output=readable_res,
            outputs_prefix="PanwIot3rdParty.customerid",
            outputs=CUSTOMER_ID
        )


    def extract_dnac_device_data(args):
        """
        Returns PANW IoT device data
        """
        client_data = args.get('DNAcClientData')
        res = []
        for dc in client_data:
            data = {}
            if 'detail' not in dc or 'errorCode' in dc['detail']:
                continue
            try:
                data['config_source'] = 'dnac'
                data['deviceid'] = dc['detail']['hostMac'].lower()
            except:
                pass
            try:
                wire_wireless = dc['detail']['hostType']
                if wire_wireless != None:
                    data['WireWireless'] = wire_wireless
            except:
                pass

            try:
                if dc['detail']['vlanId'] != None and 0 != dc['detail']['vlanId']:
                    data['vlan'] = int(dc['detail']['vlanId'])
            except:
                pass
            try:
                if None != dc['detail']['location']:
                    data['location'] = dc['detail']['location']
            except:
                pass

            if 'WireWireless' in data and 'WIRED' == data['WireWireless']:
                try:
                    nwDeviceName = dc['connectionInfo']['nwDeviceName']
                    if nwDeviceName != None:
                        data['switch_name'] = nwDeviceName
                        data['switchName'] = nwDeviceName
                except:
                    pass
                try:
                    nwDeviceMac = dc['connectionInfo']['nwDeviceMac']
                    if nwDeviceMac != None:
                        data['switch_mac'] = nwDeviceMac
                except:
                    pass
                try:
                    linkSpeed = dc['detail']['linkSpeed']
                    if linkSpeed != None:
                        data['speed'] = linkSpeed
                except:
                    pass
                try:
                    dc_port = dc['detail']['port']
                    if dc_port != None:
                        data['switch_if_name'] = dc_port
                        data['switchPort'] = dc_port
                except:
                    pass
                try:
                    for nd in dc['topology']['nodes']:
                        if nd['description'] == 'SWITCH':
                            node_ip = nd['ip']
                            if node_ip != None:
                                data['switch_ip'] = node_ip
                                data['switchIP'] = node_ip
                                break
                except:
                    pass
            else:
                try:
                    nwDeviceName = dc['connectionInfo']['nwDeviceName']
                    if nwDeviceName != None:
                        data['ap_name'] = nwDeviceName
                except:
                    pass
                try:
                    nwDeviceMac = dc['connectionInfo']['nwDeviceMac']
                    if nwDeviceMac != None:
                        data['ap_mac'] = nwDeviceMac
                except:
                    pass
                try:
                    slotId = dc['detail']['slotId']
                    if slotId != None:
                        data['ap_slot_id'] = slotId
                except:
                    pass
                try:
                    ssid = dc['detail']['ssid']
                    if ssid != None:
                        data['SSID'] = ssid
                except:
                    pass
                try:
                    protocol = dc['connectionInfo']['protocol']
                    if protocol != None:
                        data['protocol_name'] = protocol
                except:
                    pass
                try:
                    for nd in dc['topology']['nodes']:
                        if nd['description'] == 'AP':
                            node_ip = nd['ip']
                            if node_ip != None:
                                data['ap_ip'] = node_ip
                                break
                except:
                    pass

            res.append(data)

        return CommandResults(
            readable_output=f'{len(res)} of {len(client_data)} client detail extracted',
            outputs_prefix="PanwIot3rdParty.DeviceData",
            outputs=res
        )


    def report_vulnerability_scan_options_to_iot_cloud(args):
        curr_time = int(round(time.time() * 1000))
        scanner_input = args.get('scanner_list')
        profile_input = args.get('profile_list')
        site_input = args.get('site_list')
        scanner_sync = args.get('scanner_sync')

        if scanner_input == None or profile_input == None:
            raise Exception("Inputs can not be empty or None")

        data = {
            "scannerList": scanner_input,
            "profileList": profile_input,
            "scanType": args.get('scan_type'),
            "timestamp": curr_time,
            "syncScanners": bool(scanner_sync),
        }

        if site_input is not None:
            data['siteList'] = site_input

        api_data = json.dumps(data)
        url = BASE_URL + "pub/v4.0/xsoar/device/scanDetails"
        response = http_request('POST', url, None, api_data)
        data["iot_cloud_response"] = response

        return CommandResults(
            readable_output=tableToMarkdown("Vulnerabity scanning option report status:", data, removeNull=True)
        )

    def upload_nd_files_to_backend(args):

        file_upload = args.get('file_upload')
        api = args.get('api')

        if file_upload == None:
            raise Exception("file_upload can not be None")
        file_path = demisto.getFilePath(file_upload)['path']
        file_name = demisto.getFilePath(file_upload)['name']
        params = {}

        try:
            shutil.copy(file_path, file_name)
        except Exception:
            raise Exception('Failed to prepare file for upload.')
        files = {
            'file': (file_name, open(file_name, 'rb'), 'text/plain', {'Expires': '0'}),
        }

        data1 = {}
        url=""
        if api == 'NODE_GRAPH':
            url = BASE_URL + "pub/v4.0/network/ndNodeGraphBulkUpdate"
        elif api == 'ENDPOINTS':
            url = BASE_URL + "pub/v4.0/network/ndNodeEndpointBulkUpdate"
        else:
            url = BASE_URL + "pub/v4.0/network/ndNodeL2L3BulkUpdate"

        response = http_request('PUT', url, api_params=params, data=None, files=files, form_data=True)

        # data1["File upload to cloud response: %s"] = response

        # return CommandResults(
        #     readable_output=tableToMarkdown("Network Discovery File Upload :", data1, removeNull=True)
        # )
        return response

    def upload_vulnerability_scan_report_to_iot_cloud(args):
        status = args.get('status')
        ip = args.get('ip')
        job_id = args.get('job_id')
        if status == "success":

            xml_upload = args.get('xml_upload')
            pdf_upload = args.get('pdf_upload')
            if xml_upload == None or pdf_upload == None:
                raise Exception("pdf_upload , xml_upload can not be None")
            xml_file_path = demisto.getFilePath(xml_upload)['path']
            pdf_file_path = demisto.getFilePath(pdf_upload)['path']
            xml_file_name = demisto.getFilePath(xml_upload)['name']
            pdf_file_name = demisto.getFilePath(pdf_upload)['name']
            if job_id is None:
                params = (
                    ('scanType', args.get('scan_type')),
                    ('reportid', args.get('report_id')),
                    ('pdfFileName', pdf_file_name),
                    ('xmlFileName', xml_file_name),
                    # error or success, if success then all fields need be files, if error then just message and status + jobid
                    ('status', args.get('status')),
                    ('message', args.get('message')),
                )
            else:
                params = (
                    ('jobid', args.get('job_id')),
                    ('scanType', args.get('scan_type')),
                    ('reportid', args.get('report_id')),
                    ('pdfFileName', pdf_file_name),
                    ('xmlFileName', xml_file_name),
                    # error or success, if success then all fields need be files, if error then just message and status + jobid
                    ('status', args.get('status')),
                    ('message', args.get('message')),
                )


            try:
                shutil.copy(xml_file_path, xml_file_name)
                shutil.copy(pdf_file_path, pdf_file_name)
            except Exception:
                raise Exception('Failed to prepare file for upload.')
            files = {
                pdf_file_name: (pdf_file_name, open(pdf_file_name, 'rb'), 'application/pdf', {'Expires': '0'}),
                xml_file_name: (xml_file_name, open(xml_file_name, 'rb'), 'application/xml', {'Expires': '0'}),
            }
        else:
            if job_id is None:
                params = (
                    # error or success, if success then all fields need be files, if error then just message and status + jobid
                    ('status', args.get('status')),
                    ('message', args.get('message')),
                )
                files = None
            else:
                params = (
                    ('jobid', args.get('job_id')),
                    # error or success, if success then all fields need be files, if error then just message and status + jobid
                    ('status', args.get('status')),
                    ('message', args.get('message')),
                )
                files = None
        data1 = {}
        url = BASE_URL + "pub/v4.0/xsoar/device/reportUpload"
        response = http_request('POST', url, api_params=params, data=None, files=files, form_data=True)

        if ip is None:
            data1["Report upload cloud response: %s"] = response
        else:
            data1["Report upload cloud response for IP: %s" % ip] = response

        return CommandResults(
            readable_output=tableToMarkdown("Vulnerability Report Upload Command:", data1, removeNull=True)
        )


    def connection_test_command() -> str:
        """
        Try to get a single device from the Cloud to test connectivity.
        """
        params = {
            'offset': '0',
            'pagelength': '1',
            'detail': 'false',
        }
        url = f"{BASE_URL}{API_TYPE_MAP['device']['list_url']}"
        http_request('GET', url, params)

        return 'ok'


    def process_metadata_for_aims(meta_data_dict, report_summary):
        if 'WorkOrderResponse' not in str(meta_data_dict):
            meta_data_dict = json.loads(str(meta_data_dict).replace('\"', '"'))
        metadata_dict = dict()
        metadata_report = dict()
        for key, metadata in meta_data_dict.items():
            if key in ('FacilityMaps', 'VendorMaps', 'EquipmentTypeMaps', 'CostCenterMaps', 'EmployeeList', 'WorkOrderPriorityList'):
                report_field_name = AIMS_METADATA_REPORT_FIELD_MAPPINGS.get(key)
                api_field_name = AIMS_METADATA_API_FIELD_MAPPINGS.get(key)
                metadata_dict[api_field_name] = metadata
                metadata_report[report_field_name] = len(metadata)
            elif key == 'WorkOrderResponse':
                report_summary['Asset Type'] = 'Details'
                report_field_name = AIMS_METADATA_REPORT_FIELD_MAPPINGS.get(key)
                metadata_dict = metadata
                metadata_report[report_field_name] = 'Created work order number {}'.format(metadata.get('work_order_number'))
        report_summary.update(metadata_report)
        metadata_dict['updateTime'] = round(time.time() * 1000)
        metadata_dict['custom_integration_name'] = 'aims'
        return metadata_dict, report_summary


    def report_metadata(args):
        """
        Returns a report of metadata sent to IoT Cloud
        """
        report_summary = {'Asset Type': 'Total Assets Reported'}
        url = BASE_URL + "pub/v4.0/xsoar/device/aims/metaInfo"
        input_meta_data_dict = args.get('MetaData')
        integration_name = args.get('IntegrationName', '')
        if 'aims' in integration_name:
            metadata_dict, report_summary = process_metadata_for_aims(input_meta_data_dict, report_summary)
            response = http_request('POST', url, None, json.dumps(metadata_dict))
        return CommandResults(
            readable_output=tableToMarkdown("Asset Report Summary:", report_summary, removeNull=True)
        )

    def report_aclsync_status(args):
        """
        Return a acl sync status to IoT Cloud
        """
        url = BASE_URL + "pub/v4.0/xsoar/profile/aclSync/status"
        status=args.get('status')
        message=args.get('message')
        # params = {"jobid", args.get('job_id')}
        params = {"jobid": args.get('job_id')}
        data = {
            "message": message,
            "status": status
        }
        api_data = json.dumps(data)
        data1={}
        response = http_request('POST', url, api_params=params, data=api_data)
        data1["Status Report to IoT Cloud"] = str(status)
        return CommandResults(
            readable_output=tableToMarkdown("ACL Sync status is reported:", data1, removeNull=True)
        )

    def get_active_integrations():
        """
        Returns a list of active integrations and max number of integrations allowed.

        """
        url = BASE_URL + "pub/v4.0/xsoar/integrations"
        response = http_request('GET', url)
        active_integrations = response.get('active_integrations')
        max_integrations = response.get('max_integrations')

        op_data = {
            "active_integrations" : active_integrations,
            "max_integrations" : max_integrations
        }

        return CommandResults(
            readable_output=tableToMarkdown("PANW IoT Active Integrations:", op_data, removeNull=True),
            outputs_prefix='PanwIot3rdParty.ActiveIntegrations',
            outputs=op_data
        )

    def send_heartbeat():
        """
        Sends a heartbeat to the PANW IoT cloud - To be used for on-prem connection health.
        """
        op_data = {}
        url = BASE_URL + "pub/v4.0/xsoar/heartbeat"
        data = {
            "version": "2.0.23",
            "ip": XSOAR_URL
        }
        api_data = json.dumps(data)
        response = http_request('GET', url, data=api_data)

        op_data["success"] = response.get('success')

        return CommandResults(
            readable_output=tableToMarkdown("Cloud heartbeat response:", op_data, removeNull=True)
        )

    def heartbeat_task():
        while True:
            try:
                time.sleep(HEARTBEAT_INTERVAL)
                send_heartbeat()
            except Exception as ex:
                demisto.error("PANW IoT Cloud Heartbeat failed - %s" % str(ex))
                pass

    def handle_panw_cloud_connection():
        # Start Heartbeat thread
        hb_thread = Thread(target=heartbeat_task)
        hb_thread.start()
        # Should have here an endless loop

        DEFAULT_HEADERS = {
            'X-Access-Key': demisto.params().get("Access Key"),
            'X-Key-Id': demisto.params().get("Key ID"),
            # 'Content-Type': 'application/json',
        }

        cloud_url = BASE_URL.replace("https", "wss")
        cloud_url = cloud_url + "wss/connect?app=xsoar&tenantid=%s&key_id=%s&access_key=%s&active_xsoar_endpoint=%s" % (CUSTOMER_ID, DEFAULT_HEADERS['X-Key-Id'], DEFAULT_HEADERS['X-Access-Key'],XSOAR_URL)

        ws_client = WebSocketClient(cloud_url, None, None)
        ws_client.start_loop()

    def report_panorama_rules(args):
        """
        Returns a number of subnets sent to IoT Cloud
        """
        page_length=100
        securityRules = args.get('security_rules')
        device_group = args.get('device_group')
        params = {
            'updateSource': 'panorama',
            'device_group':device_group
        }
        url = BASE_URL + "pub/v4.0/network/securityRules"
        data = {}
        total = len(securityRules)
        updated = 0
        upserted = 0
        while total > 0:
            if total > page_length:
                offset = total - page_length
            else:
                offset = 0
            data['ruleList'] = securityRules[offset:total]
            source=''
            if params is not None and 'updateSource' in params.keys():
                source = params['updateSource']
            else:
                source='unknown'
            demisto.info("Reporting panorama security rules to PANW IoT cloud. Source - %s. Data - %s" % (source, json.dumps(data)))
            response = http_request('PUT', url, params, json.dumps(data))
            time.sleep(0.5)
            updated += response.get('updatedSecurityRulesNum')
            upserted += response.get('upsertedSecurityRulesNum')
            total = offset
        op={}
        op['updated']=updated
        op['upserted']=upserted
        return CommandResults(
            readable_output=op,
            outputs_prefix="PanwIot3rdParty.PanoramaSecurtityRules",
            outputs=op
        )

    def upload_location_floorplan(args):
        upload_file = args.get('upload_file')
        if not upload_file:
            raise Exception("Upload file not be None")
        floor_id = args.get('floor_id')
        if not floor_id:
            raise Exception("Floor ID not be None")

        file_path = demisto.getFilePath(upload_file)['path']
        file_name = demisto.getFilePath(upload_file)['name']
        params = {}

        try:
            shutil.copy(file_path, file_name)
        except Exception as e:
            raise Exception('Failed to prepare file for upload. %s' % str(e))
        files = {
            'file': (file_name, open(file_name, 'rb')),
        }
        params = (
            ('floorid', floor_id),
            )

        url = BASE_URL + "pub/v4.0/location/floorPlan"
        response = http_request('PUT', url, api_params=params, data=None, files=files, form_data=True)
        return response

    def upload_location_map(args):
        location_map = args.get('location_map')
        if not location_map:
            raise Exception("Location Map not be None")
        url = BASE_URL + "pub/v4.0/location/map"
        data = {"campuses": location_map}
        response = http_request('PUT', url, api_params=None, data=json.dumps(data))
        return response

    def report_panorama_rules_uuids_to_purge(args):
        """
        Returns a number of panorama security rules purged in PANW IoT Cloud
        """
        page_length=100
        panorama_security_rules_uuids = args.get('uuids')
        params = {}
        url = BASE_URL + "pub/v4.0/network/purgeRules"
        data={}
        pageLength=10000
        removed=0
        total = len(panorama_security_rules_uuids)
        while total > 0:
            if total > page_length:
                offset = total - page_length
            else:
                offset = 0
            data['whiteList'] = panorama_security_rules_uuids[offset:total]
            demisto.info("Reporting panorama security rules uuids to PANW IoT cloud to purge. Source - panorama. Data - %s" % (json.dumps(data)))
            response = http_request('DELETE', url, params, json.dumps(data))
            time.sleep(0.5)
            removed += int(response.get('removedRules'))
            total = offset
        op={}
        op['removed']=removed
        return CommandResults(
            readable_output=op,
            outputs_prefix="PanwIot3rdParty.PanoramaSecurtityRules.UUID.Result",
            outputs=op
        )

    def main() -> None:
        """main function, parses args and runs command functions
        """
        command = demisto.command()
        args = demisto.args()
        demisto.debug(f'Command being called is {command}')
        try:
            if command == 'test-module':
                return_results(connection_test_command())
            elif command == 'panw-iot-3rd-party-get-asset-list':
                results = get_asset_list(args)
                return_results(results)
            elif command == 'panw-iot-3rd-party-get-single-asset':
                results = get_single_asset(args)
                return_results(results)
            elif command == 'panw-iot-3rd-party-report-status-to-panw':
                results = report_status_to_iot_cloud(args)
                return_results(results)
            elif command == 'panw-iot-3rd-party-convert-assets-to-external-format':
                results = convert_asset_to_external_format(args)
                return_results(results)
            elif command == 'panw-iot-3rd-party-get-active-list':
                results = get_active_list(args)
                return_results(results)
            elif command == 'panw-iot-3rd-party-report-devices':
                results = report_devices(args)
                return_results(results)
            elif command == 'panw-iot-3rd-party-report-vulnerabilities':
                results = report_vulnerabilities(args)
                return_results(results)
            elif command == 'panw-iot-3rd-party-extract-mac-address':
                results = extract_mac_address(args)
                return_results(results)
            elif command == 'panw-iot-3rd-party-extract-dnac-device-data':
                results = extract_dnac_device_data(args)
                return_results(results)
            elif command == 'panw-iot-3rd-party-get-customerid':
                results = get_external_tenantid()
                return_results(results)
            elif command == 'panw-iot-3rd-party-report-vulnerability-scan-option':
                results = report_vulnerability_scan_options_to_iot_cloud(args)
                return_results(results)
            elif command == 'panw-iot-3rd-party-upload-vulnerability-scan-report':
                results = upload_vulnerability_scan_report_to_iot_cloud(args)
                return_results(results)
            elif command == 'panw-iot-3rd-party-extract-device-data':
                client = args.get('client')
                if client == 'prime':
                    results = extract_prime_device_data(args)
                    return_results(results)
                elif client == 'cisco_wlc':
                    results = extract_cisco_wlc_device_data(args)
                    return_results(results)
                elif client == 'aruba_wlc':
                    results = extract_aruba_wlc_device_data(args)
                    return_results(results)
                else:
                    return_error(f'No client Integration found')
            elif command == 'panw-iot-3rd-party-report-metadata':
                results = report_metadata(args)
                return_results(results)
            elif command == 'panw-iot-3rd-party-report-aclsync-status':
                results = report_aclsync_status(args)
                return_results(results)
            elif command == 'panw-iot-3rd-party-device-details':
                results = get_device_details(args)
                return_results(results)
            elif command == 'panw-iot-3rd-party-get-active-integrations':
                results = get_active_integrations()
                return_results(results)
            elif command == 'panw-iot-3rd-party-heartbeat':
                results = send_heartbeat()
                return_results(results)
            elif demisto.command() == 'long-running-execution':
                handle_panw_cloud_connection()
            elif command == 'panw-iot-3rd-party-report-subnets':
                results = report_subnets(args)
                return_results(results)
            elif command == 'panw-iot-3rd-party-upload-network-discovery-file':
                results = upload_nd_files_to_backend(args)
                return_results(results)
            elif command == 'panw-iot-3rd-party-send-panorama-rules':
                results = report_panorama_rules(args)
                return_results(results)
            elif command == 'panw-iot-3rd-party-panorama-rules-uuid-purge':
                results = report_panorama_rules_uuids_to_purge(args)
                return_results(results)
            elif command == 'panw-iot-3rd-party-upload-floorplan':
                results = upload_location_floorplan(args)
                return_results(results)
            elif command == 'panw-iot-3rd-party-upload-location-map':
                results = upload_location_map(args)
                return_results(results)


            # Log exceptions and return errors
        except Exception as e:
            demisto.error(traceback.format_exc())  # print the traceback
            return_error(f'Failed to execute {demisto.command()} command.\nError:\n{str(e)}')


    ''' ENTRY POINT '''
    if __name__ in ('__main__', '__builtin__', 'builtins'):
        main()










    register_module_line('Palo Alto Networks IoT 3rd Party', 'end', __line__())
  subtype: python3
  type: python
sourcemoduleid: Palo Alto Networks IoT 3rd Party
