category: Network Security
commonfields:
  id: PANW IoT 3rd Party Integration - Aruba Central
  version: -1
configuration:
- additionalinfo: Aruba Central domain url to access it from integration
  display: Domain URL
  name: domain_url
  required: true
  type: 0
- display: Customer ID
  name: customer_id
  required: true
  type: 4
- display: Client ID
  name: client_id
  required: true
  type: 4
- display: Client Secret
  name: client_secret
  required: true
  type: 4
- display: Username
  name: credentials
  required: true
  type: 9
contentitemexportablefields:
  contentitemfields:
    definitionid: ""
    fromServerVersion: ""
    itemVersion: ""
    packID: ""
    packName: ""
    prevname: ""
    propagationLabels:
    - all
    toServerVersion: ""
description: Aruba Central offers centralized management interface for managing wireless,
  WAN, and wired networks in distributed environments.
detaileddescription: |-
  ## Aruba Central Integration

  ##### Details for Aruba Central Rest API workflow

  Please configure the instance by providing following mandatory details:

  - Name of the instance
    - Domain base URL(Refer section below for more information)
  - Client ID
  - Client Secret
  - Customer ID
  - Username
  - Password


  Details on how to choose domain base URL
    - For Aruba Central on-prem
      - To access the API Gateway interface, you must ensure that the FQDN in the API Gateway URL resolves to the same IP address as the Aruba Central server.
      - To avoid any error in the server certification, make sure that you include the API gateway FQDN as a Subject Alternate Name (SAN) in the certificate. For more information, refer to official Aruba Central (on-premises) User Guide.
       - The API Gateway is apigw-<clusterFQDN> by default. Make sure that this URL is added in DNS record for VIP of the Central On-Premise cluster. For example, if the Central On-Premise cluster FQDN is yodacop-vip.arubathena.com, then the API Gateway URL will be apigw-yodacop-vip.arubathena.com.
    - For Aruba Central on-cloud
      - Choose Aruba Central API Gateway URL from table below based on the geographical cluster where your account is registered.
  ##### Table: Domain URLs for API Gateway Access

  | **Region**        | **API Gateway Domain URL**                              |
  |--------------------|--------------------------------------------------------------|
  | US-1                    | app1-apigw.central.arubanetworks.com            |
  | US-2                    | apigw-prod2.central.arubanetworks.com          |
  | US-East1           | apigw-us-east-1.central.arubanetworks.com    |
  | US-West4          | apigw-uswest4.central.arubanetworks.com      |
  | EU-1                    | eu-apigw.central.arubanetworks.com                  |
  | EU-Central2     | apigw-eucentral2.central.arubanetworks.com |
  | EU-Central3     | apigw-eucentral3.central.arubanetworks.com |
  | Canada-1          | apigw-ca.central.arubanetworks.com                  |
  | China-1              | apigw.central.arubanetworks.com.cn                  |
  | APAC-1               |  api-ap.central.arubanetworks.com                       |
  | APAC-EAST1     | apigw-apaceast.central.arubanetworks.com     |
  | APAC-SOUTH1 | apigw-apacsouth.central.arubanetworks.com |


  ##### Details for Aruba Central Streaming API workflow.

  Please configure the instance by providing following mandatory details:

  - Username
  - WSS Key
  - Aruba Central Base URL
  - Palo Alto Base URL
  - Palo Alto Access Key
  - Palo Alto Key ID

  ## Test Configuration

  After providing the mandatory details, please test the configuration using the Test button.

  ---
display: PANW IoT 3rd Party Integration - Aruba Central
image: data:image/png;base64,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
name: PANW IoT 3rd Party Integration - Aruba Central
script:
  commands:
  - arguments:
    - name: token_data
    description: Fetch access token checks whether stored token is expired or not,
      if yes then renew it otherwise return as it is.
    name: fetch-access-token
  - arguments:
    - defaultValue: "False"
      description: Get wired clients.
      name: get_wired_clients
      required: true
      type: unknown
    - description: Access token to call API
      name: access_token
      required: true
    - defaultValue: "1000"
      name: limit
    - defaultValue: "0"
      name: offset
    description: Get all the clients. (Get Wireless clients by defualt, if customer
      has not selected the get wired client checkbox in job)
    name: get-all-clients
  - arguments: []
    description: Get access and refresh token
    name: get-access-refresh-token
  dockerimage: demisto/panw-iot:1.0.0.79918
  runonce: false
  script: |
    register_module_line('PANW IoT 3rd Party Integration - Aruba Central', 'start', __line__())


    import requests
    import time
    from datetime import datetime, timedelta
    import json
    import re


    class ArubaCentralAPI:
        """
        Class to use aruba central API
        """

        def __init__(self):
            self.aruba_domain_url = self.check_aruba_central_host()
            self.customer_id = demisto.params().get("customer_id")
            self.client_id = demisto.params().get("client_id")
            self.username = demisto.params().get("credentials", {}).get("identifier")
            self.password = demisto.params().get("credentials", {}).get("password")
            self.client_secret = demisto.params().get("client_secret")
            self.csrf, self.session = self.get_csrf_token_and_session()
            self.auth_code = self.get_auth_code()

        def check_aruba_central_host(self):
            """
            Function will check whether hostname/ip-address is valid or not.
            """
            aruba_domain_url = demisto.params().get("domain_url")
            try:
                if not aruba_domain_url.startswith('https://'):
                    aruba_domain_url = 'https://'+aruba_domain_url
                if aruba_domain_url.startswith('http://'):
                    aruba_domain_url = None
                    demisto.error("http:// is not valid for API access method, expected https")
            except Exception as ex:
                demisto.error('Error while validating Aruba Central Domain url' + str(ex))
            return aruba_domain_url

        def is_mac_address(self, mac):
            """
            Test for valid mac address

            :type mac: ``str``
            :param mac: MAC address in the form of AA:BB:CC:00:11:22

            :return: True/False
            :rtype: ``bool``
            """

            if re.search(r'([0-9A-F]{2}[:]){5}([0-9A-F]){2}', mac.upper()) is not None:
                return True
            else:
                return False

        def is_ip_address(self, ip):
            """
            Test for valid ip address

            :type ip: ``str``
            :param ip: IP address in the form of 192.168.0.1

            :return: True/False
            :rtype: ``bool``
            """
            ip_regex = "^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$"
            if(re.search(ip_regex, ip)):
                return True
            else:
                return False

        def is_vlan(self, vlan):
            """
            Test for valid vlan
            """
            if isinstance(vlan, int):
                if vlan >= 1 and vlan <= 4094:
                    return True
            return False

        def get_csrf_token_and_session(self):
            """
            This function returns csrf_token and session
            """
            csrf_token = ""
            session = ""
            try:
                url = f"{self.aruba_domain_url}/oauth2/authorize/central/api/login"

                params = {"client_id": self.client_id}
                payload = {"username": self.username, "password": self.password}
                headers = {"Content-Type": "application/json"}
                response = requests.request("POST", url, params=params, json=payload, headers=headers)
                res = response.json().get("status", "")
                if res is True:
                    csrf_token = response.cookies["csrftoken"]
                    session = response.cookies["session"]
            except Exception as e:
                demisto.error("Error while getting session details " + str(e))
            time.sleep(2)
            return csrf_token, session

        def get_auth_code(self):
            """
            This function returns authorization_code
            """
            auth_code = ""
            try:
                authcode_url = f"{self.aruba_domain_url}/oauth2/authorize/central/api"
                ses = "session=" + self.session
                auth_headers = {
                    "X-CSRF-TOKEN": self.csrf,
                    "Content-type": "application/json",
                    "Cookie": ses,
                }
                payload = {"customer_id": self.customer_id}
                params = {"client_id": self.client_id, "response_type": "code", "scope": "all"}
                resp = requests.request("POST", authcode_url, params=params, json=payload, headers=auth_headers)
                if resp.status_code == 200:
                    auth_code = resp.json()["auth_code"]
                else:
                    auth_code = resp.json()
            except Exception as e:
                demisto.error("Error while getting authorization_code " + str(e))
            time.sleep(2)
            return auth_code

        def get_access_and_refresh_token(self):
            """
            This function returns access_token and refresh_token
            """
            token_dict = {}
            try:
                token_url = f"{self.aruba_domain_url}/oauth2/tokens"
                token_data = {"grant_type": "authorization_code", "code": self.auth_code}
                resp = requests.request("POST", token_url, data=token_data, auth=(self.client_id, self.client_secret))
                if resp.status_code == 200:
                    token_dict["access_token"] = resp.json().get("access_token", None)
                    token_dict["refresh_token"] = resp.json().get("refresh_token", None)
                    token_dict["expires_in"] = resp.json().get("expires_in", None)
                    token_dict["token_time"] = time.time()
                else:
                    token_dict = resp.json()
            except Exception as e:
                demisto.error("Error while getting access_token " + str(e))
            return token_dict

        def is_expired(self, token_time, expires_in):
            """
            This function will check access_token is expired or not
            """
            try:
                expires_in = int(expires_in)
                expires_in = timedelta(seconds=expires_in)
                token_time = datetime.fromtimestamp(token_time)
                current_time = datetime.fromtimestamp(time.time())
                time_diff = current_time - token_time
                if re.search("[a-zA-Z]", time_diff) is None:
                    if time_diff <= expires_in:
                        return False
            except Exception as ex:
                demisto.error("Error while checking token is expired or not" + str(ex))
            return True

        def fetch_access_token(self):
            """
            This function will fetch access token as follows:-

            1. First it will get token_data and check whether token_data has access_token or not if yes, then it will check
            if it is expired or not if not then it will return the token_data as it is.

            2. Other wise it will call a function to refresh the access_token from refresh_token.
            """
            try:
                token_data = demisto.args().get("token_data", "")
                if "access_token" in token_data:
                    res = json.loads(token_data)
                    refresh_token = res.get("refresh_token", "")
                    token_time = res.get("token_time", "")
                    expires_in = res.get("expires_in", "")
                    if token_time != "" and refresh_token != "":
                        if self.is_expired(token_time, expires_in) is True:
                            token_data = self.refresh_access_token(refresh_token)
                        return token_data
            except Exception as ex:
                demisto.error("Error while fetching access token" + str(ex))
            return token_data

        def refresh_access_token(self, token):
            """
            This function update the access token without having to repeat the authentication
            process by using the old refresh token
            """
            token_dict = {}
            try:
                refresh_token_url = f"{self.aruba_domain_url}/oauth2/token"
                data = {"grant_type": "refresh_token", "refresh_token": token}
                resp = requests.request("POST", refresh_token_url, data=data, auth=(self.client_id, self.client_secret))
                if resp.status_code == 200:
                    token_dict["access_token"] = resp.json().get("access_token", None)
                    token_dict["refresh_token"] = resp.json().get("refresh_token", None)
                    token_dict["expires_in"] = resp.json().get("expires_in", None)
                    token_dict["token_time"] = time.time()
                else:
                    token_dict = resp.json()
                    error = resp.json().get('error_description', '')
                    if error and error == 'Invalid refresh_token':
                        token_dict = self.get_access_and_refresh_token()
            except Exception as e:
                demisto.error("Error while renewing access token" + str(e))
            return token_dict

        def http_request(self, method, access_token, api_endpoint, limit, offset):
            response = ""
            try:
                url = self.aruba_domain_url + "/" + api_endpoint
                headers = {"authorization": f"Bearer {access_token}", "Accept": "application/json"}
                params = {"offset": offset, "limit": limit}
                response = requests.request(method, url, params=params, headers=headers)
                response = response.json()
            except Exception as e:
                demisto.error("Error while getting API data" + str(e))
            return response

        def get_wireless_client_data(self, client_data):
            """
            This function will map the wireless client fields according to PAN IoT.
            """
            data = {}
            try:
                if client_data:
                    mac_address = client_data.get("macaddr", "")
                    if mac_address:
                        check_mac_address = self.is_mac_address(mac_address)
                        if check_mac_address:
                            data["deviceid"] = mac_address
                            ip_address = client_data.get("ip_address", "")
                            if ip_address:
                                check_ip_address = self.is_ip_address(ip_address)
                                if check_ip_address:
                                    data["ip"] = ip_address
                            encryption_cipher = client_data.get("encryption_method", "")
                            if encryption_cipher:
                                data["encryption_cipher"] = encryption_cipher
                            network = client_data.get("network", "")
                            if network:
                                data["network"] = network
                            rssi = client_data.get("signal_strength", "")
                            if rssi:
                                if isinstance(rssi, int):
                                    data["rssi"] = str(rssi)
                            ap_mac = client_data.get("associated_device_mac", "")
                            if ap_mac:
                                check_ap_mac = self.is_mac_address(ap_mac)
                                if check_ap_mac:
                                    data["ap_mac"] = ap_mac
                            vlan = client_data.get("vlan", "")
                            if vlan:
                                check_vlan = self.is_vlan(vlan)
                                if check_vlan:
                                    data["vlan"] = vlan
                            authentication = client_data.get("authentication_type", "")
                            if authentication:
                                data["authentication"] = authentication
                            snr = client_data.get("snr", "")
                            if snr:
                                if isinstance(snr, int):
                                    data["snr"] = snr
                            bssid = client_data.get("bssid", "")
                            if bssid:
                                check_bssid = self.is_mac_address(bssid)
                                if check_bssid:
                                    data["bssid"] = bssid
                            wired_wireless = client_data.get("client_type", "")
                            if wired_wireless == 'WIRELESS':
                                data["wired_wireless"] = wired_wireless.lower()
                            hostname = client_data.get("name", "")
                            if hostname:
                                data["hostname"] = hostname
                            ap_name = client_data.get("associated_device", "")
                            if ap_name:
                                data["ap_name"] = ap_name
                            radio = client_data.get("connection", "")
                            if radio:
                                data["radio"] = radio
                            apRadioSlotId = client_data.get("radio_number", "")
                            if apRadioSlotId:
                                if isinstance(apRadioSlotId, int):
                                    data["apRadioSlotId"] = apRadioSlotId
            except Exception as ex:
                demisto.error("Error while getting wireless clients data" + str(ex))
            return data

        def get_wired_client_data(self, client_data):
            """
            This function will map the wired client fields according to PAN IoT.
            """
            data = {}
            try:
                if client_data:
                    mac_address = client_data.get("macaddr", "")
                    if mac_address:
                        check_mac_address = self.is_mac_address(mac_address)
                        if check_mac_address:
                            data["deviceid"] = mac_address
                            ip_address = client_data.get("ip_address", "")
                            if ip_address:
                                check_ip_address = self.is_ip_address(ip_address)
                                if check_ip_address:
                                    data["ip"] = ip_address
                            switch_mac = client_data.get("interface_mac", "")
                            if switch_mac:
                                check_switch_mac = self.is_mac_address(switch_mac)
                                if check_switch_mac:
                                    data["switch_mac"] = switch_mac
                            vlan = client_data.get("vlan", "")
                            if vlan:
                                check_vlan = self.is_vlan(vlan)
                                if check_vlan:
                                    data["vlan"] = vlan
                            authentication = client_data.get("authentication_type", "")
                            if authentication:
                                data["authentication"] = authentication
                            wired_wireless = client_data.get("client_type", "")
                            if wired_wireless == 'WIRED':
                                data["wired_wireless"] = wired_wireless.lower()
                            hostname = client_data.get("name", "")
                            if hostname:
                                data["hostname"] = hostname
                            switch_name = client_data.get("associated_device", "")
                            if switch_name:
                                data["switch_name"] = ap_name
            except Exception as ex:
                demisto.error("Error while getting wired clients data" + str(ex))
            return data

        def get_clients_data(self, data):
            """
            This function will extract wireless and wired clients data.
            """
            clients = []
            try:
                for _data in data:
                    client_type = _data.get("client_type", "")
                    if client_type == "WIRELESS":
                        wireless_client = self.get_wireless_client_data(_data)
                        if wireless_client:
                            clients.append(wireless_client)
                    if client_type == "WIRED":
                        wired_client = self.get_wired_client_data(_data)
                        if wired_client:
                            clients.append(wired_client)
            except Exception as ex:
                demisto.error("Error while getting clients data" + str(ex))
            return clients

        def get_all_clients(self):
            """
            This function will get all clients data.
            """
            clients = ""
            res = ""
            try:
                get_wired_clients = demisto.args().get("get_wired_clients", "")
                access_token = demisto.args().get("access_token", "")
                limit = demisto.args().get("limit", "")
                offset = demisto.args().get("offset", "")
                if get_wired_clients is True:
                    end_point = "monitoring/v2/clients"
                else:
                    end_point = "monitoring/v1/clients/wireless"
                res = self.http_request("GET", access_token, end_point, limit, offset)
                if isinstance(res, dict):
                    data = res.get("clients", "")
                    if data:
                        clients = self.get_clients_data(data)
                        res.update({"clients": clients})
            except Exception as ex:
                demisto.error("Error while getting all clients" + str(ex))
            return res


    def main():
        demisto.debug(f"Command being called is {demisto.command()}")
        test_res = ""
        try:
            if demisto.command() == "test-module":
                test_res = ""
                try:
                    api_login = ArubaCentralAPI()
                    test_res = api_login.auth_code
                    if test_res:
                        if isinstance(test_res, str):
                            return_results('ok')
                        else:
                            return_results(test_res)
                    else:
                        return_results('Domain url is incorrect')
                except Exception as e:
                    return_error("Aruba got exception: %s" % str(e))

            if demisto.command() == "fetch-access-token":
                try:
                    api_login = ArubaCentralAPI()
                    return_results(api_login.fetch_access_token())
                except Exception as e:
                    return_error("fetch-access-token command got exception: %s" % str(e))

            if demisto.command() == "get-all-clients":
                try:
                    api_login = ArubaCentralAPI()
                    return_results(api_login.get_all_clients())
                except Exception as e:
                    return_error("get-all-clients command got exception: %s" % str(e))

            if demisto.command() == "get-access-refresh-token":
                try:
                    api_login = ArubaCentralAPI()
                    return_results(api_login.get_access_and_refresh_token())
                except Exception as e:
                    return_error("get-access-refresh-token command got exception: %s" % str(e))
        except Exception as e:
            return_error(f"Failed to execute {demisto.command()} command.\nError:\n{str(e)}")


    if __name__ in ("__main__", "__builtin__", "builtins"):
        main()

    register_module_line('PANW IoT 3rd Party Integration - Aruba Central', 'end', __line__())
  subtype: python3
  type: python
sourcemoduleid: Aruba Central
